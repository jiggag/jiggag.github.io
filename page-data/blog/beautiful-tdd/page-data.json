{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/blog/beautiful-tdd/",
    "result": {"data":{"markdownRemark":{"html":"<h3>그동안의 테스트</h3>\n<p>항상 계획에만 존재하는 것, <code>테스트 코드 작성하기</code>이다.</p>\n<p>그러나 이번에 더미 데이터로 확인하는데 한계가 있는 여러 케이스를 확인해보고자\n<code>테스트를 작성해 두면 마음이 편안해질 수 있겠지</code> 하며 테스트 코드를 작성한 것이 시작이였다.\n(아마 데이터가 충분했다면 그냥 지나갔을지 모른다)</p>\n<p>그동안 작성한 테스트 코드는 단순한 유틸, 비즈니스 로직을 확인하는 정도였고 컴포넌트 렌더링 테스트도 해봤다고 하기 쑥쓰러운 수준이다.\n모든게 완료된 후 로직 검증 및 리팩터링, 훗날의 코드 지킴이를 위한 차원에서 작성한 것들이 대부분이라\n<code>해본적이 없는 건 아니지만 해봤다고 하기 민망한</code> 그 사이 어디쯤이다.</p>\n<hr>\n<h3>그렇게 시작한 도전기</h3>\n<p>이번에도 마찬가지로 비즈니스 로직, 헬퍼 함수를 테스트하고 있었다.\n하지만 비즈니스 로직은 커스텀 훅으로 분리하는 작업을 하다보니 테스트 코드 작성하는게 조금 불편하다고 느껴졌다.</p>\n<p>훅을 테스트하는게 아니라면 훅 안에서 사용하는 로직만 따로 분리해서 다시 테스트를 해야하는데, 그럼 불필요하게 코드가 분리되는 모양이 되었다.</p>\n<p>그리고 이 훅을 사용하는 컴포넌트에서 훅이 반환하는 결과에 따라 레이아웃이 변경되는 것도 테스트하면 좋겠다고 생각이 들고 있었다.</p>\n<pre><code class=\"language-tsx\">// useCustomHook.test.tsx\nimport useCustomHook from './useCustomHook';\n\n...\n\nit('커스텀 훅 테스트', () => {\n  const customHook = useCustomHook({ value: 0 });\n  expect(customHook.value).toBe(1);\n});\n</code></pre>\n<p>근데 이처럼 훅을 테스트하려고 하면 <code>Error: Invalid hook call. Hooks can only be called inside of the body of a function component.</code> 에러가 발생하였다.\n훅을 테스트하려면 임의의 컴포넌트로 래핑해서 호출해야하는 것이였다.</p>\n<p>하지만 매번 훅을 감싸고 훅의 반환값을 상태로 갖는 컴포넌트를 만들어서 확인하는 것은 너무 귀찮다고 생각이 들었는데,\n커스텀 훅을 테스트할 수 있는 라이브러리가 당연히 있었고 그렇게 <a href=\"https://github.com/testing-library/react-hooks-testing-library\">@testing-library/react-hooks</a> 를 이용해보기로 하였다.</p>\n<hr>\n<h3>@testing-library/react-hooks</h3>\n<pre><code class=\"language-tsx\">import { renderHook, act } from '@testing-library/react-hooks';\nimport useCustomHook from './useCustomHook';\n\ninterface CustomHook {\n  value: number;\n  increment: () => void;\n}\n\nit('커스텀 훅 테스트', () => {\n  const { result } = renderHook(useCustomHook, { initialProps: {\n    value: 1,  \n  }});\n  expect(result.current.value).toBe(1);\n\n\n  act(() => {\n    result.current.increment();\n  })\n  \n  expect(result.current.value).toBe(2);\n})\n</code></pre>\n<p>예시처럼 <code>renderHook</code>으로 테스트하고자 하는 훅을 감싸면 <a href=\"https://react-hooks-testing-library.com/reference/api#renderhook-result\"><code>RenderHookResult</code></a> 을 반환하는데, 훅의 반환값이 <code>result.current</code>에 들어가게 된다.</p>\n<p>어떻게 훅을 테스트할 수 있게 되었을까?</p>\n<p><a href=\"https://github.com/testing-library/react-hooks-testing-library/blob/21a20baf4c92e94055d725ce96a29b73aa0fa9cd/src/native/pure.ts#L8\"><code>renderHook</code></a> 내부적으로 <a href=\"https://github.com/testing-library/react-hooks-testing-library/blob/21a20baf4c92e94055d725ce96a29b73aa0fa9cd/src/helpers/createTestHarness.tsx#L6\">컴포넌트 래핑하는 구조</a> 로 보인다.\n(<a href=\"https://react-hooks-testing-library.com/installation#renderer\">여기</a> 서 친절하게도 이미 렌더러에 대해 이야기해주고 있었다)\n모든건 라이브러리가 해주니 온전히 커스텀 훅 로직 테스트만 할 수 있게 되었다.</p>\n<p>훅의 상태를 업데이트하는 무언가를 호출한다면 <a href=\"https://reactjs.org/docs/test-utils.html#act\"><code>act</code></a> 로 감싸서 업데이트를 확인할 수 있었다.\n리액트 사이클을 동작하는 것처럼 만들어주는 모양이다. (비동기 처리에 대해서는 <a href=\"https://github.com/testing-library/react-hooks-testing-library/blob/21a20baf4c92e94055d725ce96a29b73aa0fa9cd/src/core/asyncUtils.ts#L39\"><code>act</code>를 한번 더 래핑한 <code>waitFor*</code></a> 를 사용해야한다)</p>\n<p>그렇다면 왜 <code>result.current</code> 형태를 갖게 되었을까?</p>\n<p><a href=\"https://github.com/testing-library/react-hooks-testing-library/blob/21a20baf4c92e94055d725ce96a29b73aa0fa9cd/src/helpers/createTestHarness.tsx#L11\">커스텀 훅을 래핑한 컴포넌트</a> 에서 렌더링 될 때 마다 <code>setValue</code> 업데이트가 진행되는데, 이를 실제 상태 업데이트가 아니라 <code>result.current</code>가 참조하고 있는 <code>value</code>에 단순히 배열을 추가하는 형태이다(<code>mutable</code>).</p>\n<p>따라서 <code>const { value } = result.current</code> 로 분해해서 사용하게 되면 <a href=\"https://github.com/testing-library/react-hooks-testing-library/blob/21a20baf4c92e94055d725ce96a29b73aa0fa9cd/src/core/index.ts#L7\"><code>result.current</code></a> 는 테스트 훅이 렌더링 될 때 마다 새로 추가된 값을 들고 있지만 <code>value</code>는 분해 시점에 할당된 값을 반환하게 된다.\n(항상 <code>result.current.value</code>를 해야하는 이유이다)</p>\n<pre><code class=\"language-tsx\">const { result, rerender } = renderHook(() => useCustomHook({ value: 2 }));\nconst { result } = renderHook(useCustomHook, {\n  initialProps: {\n    value: 2,\n  }\n});\nconst { result } = renderHook(({ value }) => useCustomHook(value), {\n  initialProps: {\n    value: 2,\n  },\n  wrapper: ({ children }) => &#x3C;>{children}&#x3C;/>,\n});\n</code></pre>\n<p>다양한 형태로 <code>renderHook</code>을 사용할 수 있는데, <code>renderHook</code>이 반환하는 <code>rerender</code>는 어떤 상황에서 써야하는 것일까?</p>\n<p>일반적으로 훅 상태가 업데이트 되는 상황이라면 내부 함수를 호출할텐데, <code>rerender</code>가 필요한 시점은 언제일까?\n훅을 사용하는 외부 상황이 변경되었을때, 훅의 콜백 상태 또는 <code>cleanup</code>(<code>unmount</code>라는 함수로 따로 테스트 할 수 있다)을 테스트하고자 리렌더를 필요로 하게 된다.</p>\n<p>내부 상태 업데이트 함수를 호출할때에는 <code>act</code>로 감싸는 것과 다르게, <code>rerender</code>는 업데이트된 <code>props</code>를 파라미터로 넘겨주는 (실제 훅이 다시 렌더되는 것 처럼) <code>rerender({ value: 0 })</code> 형태로 호출하기만 하면 된다.<br>\n(변경된 props를 넘기지 않았더니 처음 renderHook을 호출한 props가 그대로 유지되었다)</p>\n<pre><code class=\"language-tsx\">expect(result.current.value).toBe(2);\n\nrerender(); // 이렇게만 호출하면 초기 상태 그대로 props가 업데이트 되지 않았다 \nexpect(result.current.value).toBe(2);\n\nrerender({ value: 99 });\nexpect(result.current.value).toBe(99);\n</code></pre>\n<p>그 외에 <code>renderHook</code>의 옵션으로 <code>wrapper</code>가 있는데, 이는 훅을 래핑할 수 있는 옵션이다.\n예시에서는 <code>Context.Provider</code>가 나왔는데, 다른 컴포넌트로 래핑할 수 있을 듯 하다. (그럴거면 그냥 컴포넌트를 테스트하는게 좋지 않을까)</p>\n<hr>\n<h3>모든 훅을 테스트할 수 있을 것 같다</h3>\n<p>그러나 모든 커스텀 훅을 <code>@testing-library/react-hooks</code>으로 테스트 해야하는 것은 아니다.\n<a href=\"https://react-hooks-testing-library.com/#the-solution\">여기</a> 에 쓰여있는 것처럼 <code>단순하거나 단 하나의 컴포넌트에서만 쓰이는 훅</code>이라면 컴포넌트 자체를 테스트하는 것이 더 좋다고 생각한다.</p>\n<p>복잡한 비즈니스 로직이 포함된 경우나 컴포넌트와 연결되지 않는 커스텀 훅이라면 훅만 따로 테스트하는 것이 좀 더 명확하게 확인 할 수 있을 것이다.</p>\n<p>(이것저것 다 테스트 해보기 전에 정리할 수 있어서 다행이다)</p>\n<hr>\n<h3>아름답게 시작한 컴포넌트 테스트</h3>\n<p>하다보니 <code>컴포넌트 렌더링 테스트도 할 수 있겠는데?</code> 하는 알 수 없는 자신감이 부풀어 <code>TDD를 한번 해봐야지!</code> 라는 마음에 도달하였다.</p>\n<p>그동안 컴포넌트 테스트하는 척 사용했던 <a href=\"https://github.com/callstack/react-native-testing-library\">@testing-library/react-native</a> (콜스택 👍) 를 이용해서\n<code>안되면 빼면 되지!</code> 하는 마음으로 최대한 부담없이 시작은 해보려고 하였다. (여기까지가 아름다웠던 것 같다)</p>\n<p>컴포넌트 스냅샷 말고는 별다른 테스트를 하고 있지 않았고, 그나마 해봤다고 하기에는 지금 돌아보면 별다른 의미가 없었던 (커스텀 훅이나 비즈니스 로직으로 테스트했다면 필요하지 않았을) 텍스트가 잘 렌더링 되는지 정도였다.</p>\n<p>그렇기 때문에 컴포넌트 테스트를 시작하기 위해서 <code>컴포넌트를 어떻게 테스트할 수 있는거지?</code>를 알아보아야했다.\n콜스택의 <a href=\"https://callstack.github.io/react-native-testing-library/\">문서</a> 잘되어있었고 안되는거 뺴고 쓸 줄 모르는거 빼고 다 되는 것 같았다!</p>\n<p>막연하게 시작하려고 하니 <code>testId</code>를 사용해서 해야하는 것 같은데, 그걸 찾으려면 <code>getByTestId</code>나 <code>queryByTestId</code>로 하면 될 것 같은 느낌이다.\n(❌문서를 읽는 것보다) 먼저 <code>getByTestId</code>로 찾은 컴포넌트 엘리먼트를 가져온다는 것을 시험해봤는데, 당연하게도 에러가 발생했다.</p>\n<pre><code class=\"language-tsx\">import { render } from '@testing-library/react-native';\n\nconst Component = ({ isVisible = false }) => {\n  return isVisible ? (\n    &#x3C;View testId=\"component\">\n      &#x3C;Text>test&#x3C;/Text>\n    &#x3C;/View>\n  ) : null;\n};\n\nit('컴포넌트 테스트', () => {\n  const {\n    getByTestId,\n  } = render(&#x3C;Component />);\n\n  expect(getByTestId('component')).toBeFalsy();\n});\n</code></pre>\n<p>전달된 props가 없었으니 <code>Component</code>는 null을 반환하고 <code>testId='component'</code>의 엘리먼트를 찾지 못했기 때문에 <code>falsy</code>하다고 테스트를 작성하면 될 것 같았다.\n그러나 이 테스트는 <code>Error: Unable to find an element with testID: component</code> 에러를 내뿜으며 실패했다.</p>\n<p>왜? 찾지 못한게 맞는데 에러가 나는거지?</p>\n<hr>\n<h3>@testing-library/react-native</h3>\n<p>우선 실패하는 케이스에서 사용했던 것들 먼저 확인해본다.</p>\n<p><code>render</code>는 예상했던대로 컴포넌트를 렌더링 시켜주고 있었다.</p>\n<pre><code class=\"language-tsx\">import { render } from '@testing-library/react-native';\n\nit('컴포넌트 테스트', () => {\n  const { toJSON, queryByTestId } = render(&#x3C;Component />, {\n    wrapper: ({ children }) => &#x3C;Wrapper>{children}&#x3C;/Wrapper>,\n    createNodeMock: (element) => {\n      // 테스트하는 컴포넌트의 ref를 제어한다\n      return null;\n    },\n  });\n\n  expect(toJSON()).toMatchSnapshot();\n  expect(queryByTestId('component')).not.toBe(null);\n  expect(queryByTestId('fake_component')).toBe(null);\n});\n</code></pre>\n<p><code>@testing-library/react-native</code>의 <code>render</code> 옵션에는 <code>wrapper</code>와 <code>createNodeMock</code> 두가지가 있는데,\n<code>wrapper</code>는 <code>renderHook</code>의 <code>wrapper</code>와 동일하고 <code>createNodeMock</code>는 <a href=\"https://ko.reactjs.org/docs/test-renderer.html#ideas\">예시</a> 처럼 <code>DOM ref</code>를 커스텀하는 역할을 하고 있다.</p>\n<p>그렇다면 렌더링된 컴포넌트 안에서 확인하고자하는 <code>testId</code>의 엘리먼트 인스턴스를 가져와야하는데, <a href=\"https://testing-library.com/docs/queries/about#types-of-queries\">여기</a> 에 써있듯 다양한 형태의 쿼리(<code>get, query, find</code>)가 존재하고 각각의 쿼리가 반환하는 형태에 따라 <code>어떤 목적으로, 어떤 결과를 테스트할 것인지</code> 적절하게 사용해야한다.</p>\n<p>쿼리마다 반환하는 형태를 확인하고나니 왜 에러를 내뿜으며 실패했는지 알 수 있었다...</p>\n<p><code>getBy*</code>는 엘리먼트를 찾지 못하면 에러를 던지고, <code>queryBy*</code>는 null을 반환하게 된다.\n<code>getBy*</code>와 <code>findBy*</code>는 반환하는 형태는 동일한데, <code>retry</code> 여부가 차이가 있었다. (get하느냐 find하느냐의 의미와 통한다고 생각한다)</p>\n<hr>\n<h3>여러가지 옵션이 있는데</h3>\n<p>컴포넌트 렌더링을 테스트하다보니 이벤트가 발생했을때 변경되는 컴포넌트도 추가로 확인하고 싶어졌다.\n<code>이미지 로드되는 순간을 어떻게 트래킹할 수 있지?</code> 생각하고 있었는데, <code>fireEvent</code>를 이용해 해결할 수 있었다.</p>\n<pre><code class=\"language-tsx\">import { fireEvent, render } from '@testing-library/react-native';\n\nit('컴포넌트 테스트', () => {\n  const { queryByTestId } = render(&#x3C;RenderImage />);\n  \n  expect(queryByTestId('image_label')).toBe('loading...');\n  fireEvent(queryByTestId('image') as ReactTestInstance, 'onLoad');\n  expect(queryByTestId('image_label')).toBe('loaded');\n});\n</code></pre>\n<p>쓰다보니 <code>ByText, ByLabel, ByRole...</code> 여러가지가 있는데 계속 <code>ByTestId</code>만 사용하고 있다!\n내가 확인하고 싶은 엘리먼트를 가장 명확하게 접근할 수 있어서 인 것 같은데, 텍스트만 가져와서 테스트하고 싶을때 써봐야지!</p>\n<p><a href=\"https://github.com/callstack/react-native-testing-library/blob/main/src/__tests__/render.test.js\">testing-library render 테스트 코드 예시</a> 를 보는 것도 재미있었다!\n(그럼에도 <code>debug</code>는 어떤 용도로 쓸 수 있을지 생각이 이어지지 않고 있다...)</p>\n<hr>\n<h3>어김없이 눈이 가는</h3>\n<p>혹시나 설마하며 <a href=\"https://callstack.github.io/react-native-testing-library/docs/eslint-plugin-testing-library\">eslint-plugin-testing-library</a>... <code>lint</code>는 없는 것이 없다!</p>\n<p>필요하다고 생각이 드는 시점을 단순하게 생각해보면, 예시로 나와있듯 <code>testID</code> 컨벤션을 유지하기 위한 것 아닐까</p>\n<hr>\n<h3>내 친구 시나리오</h3>\n<p>이런 테스트 과정을 통해 컴포넌트 스냅샷, 초기 상태와 사용자의 동작에 따라 업데이트된 상태를 확인할 수 있었다.</p>\n<p>또한 중간에 변경되는 로직을 확인하기 위해 <code>테스트 시나리오는 내 친구</code>를 경험해봤기 때문에 믿고 시작했고 역시나 이번에도 도움을 주었다.</p>\n<p>그러나 여기서 놓치고 지나갔던 부분을 리뷰를 통해 다시 돌아볼 수 있었는데, 비즈니스 로직을 모두 훅으로 분리한 상태에서 <code>컴포넌트를 테스트해야지</code> 하는 욕심으로 <code>불필요한 테스트 코드</code>를 작성하고 있었다.\n컴포넌트가 갖고 있는 상태가 모두 커스텀 훅에 의존하고 있었기 때문에, 훅을 테스트하는 것만으로도 검증할 수 있었던 것이였다.</p>\n<p>위에 <code>단순하거나 단 하나의 컴포넌트에서만 쓰이는 훅이라면 컴포넌트 자체를 테스트하는 것이 좋겠다</code>와 같은 맥락으로 복잡한 컴포넌트이지만 비즈니스 로직을 담고 있는 커스텀 훅을 테스트를 통해 검증했다면 그에 따르는 컴포넌트를 중복해서 테스트할 필요가 없지 않을까?</p>\n<p><a href=\"https://testing-library.com/docs/#the-problem\">참고: @testing-library의 솔루션</a></p>\n<hr>\n<h3>그래서 갑자기 마무리</h3>\n<p><code>함께 자라기</code>에 <code>의도적 수련</code>이라는 내용이 있다.\n지루함과 불안함 그 사이, 몰입이라는 단계의 전략을 가져가는 것이다.\n(수련이 되었는지는 모르겠지만) 이 의도를 가지고 시작하였는데, 생각만큼 아름답게 되지는 않았던 것 같고 마음의 수련을 더 많이 한 것 같다.</p>\n<p>테스트 코드를 추가한 것 만으로도 이미 적절한 난이도를 추가했다고 스스로 생각해보며 시작은 <code>TDD 도전기</code>였는데,\nTDD를 했다고 하기 보다는 <code>테스트 알아보기</code> 라고 느껴진다.</p>\n<p>시작은 TDD였는데, 어느 순간 T가 있는듯 없는듯 있긴 하지만 DD는 하고 있지 않는 그런 사이?</p>\n<p>도전한다고 아름답게 되지는 않았다.\n그냥 DD 빼고 T만이라도 함께 하는 것이 아름다운 도전이였다고 소박하게 생각해본다 🙈</p>\n<p>(+ 한참 정리를 하고 있던 중간에 <a href=\"https://devowen.com/431\">테스팅 라이브러리란?</a> 번역 글이 올라왔는데, 너무 타이밍 적절하여 좋았다!)</p>","frontmatter":{"slug":"/blog/beautiful-tdd","date":"2022년 1월 9일","title":"TDD 아름다운 도전이였다"}}},"pageContext":{"id":"3b35be34-8be4-51c5-bc01-74517036ee64","frontmatter__slug":"/blog/beautiful-tdd","__params":{"frontmatter__slug":"blog"}}},
    "staticQueryHashes": ["3000541721","3293771174"]}