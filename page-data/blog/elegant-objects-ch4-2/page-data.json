{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/elegant-objects-ch4-2/","result":{"data":{"markdownRemark":{"html":"<h2 id=\"final이거나-abstract이거나\" style=\"position:relative;\"><a href=\"#final%EC%9D%B4%EA%B1%B0%EB%82%98-abstract%EC%9D%B4%EA%B1%B0%EB%82%98\" aria-label=\"final이거나 abstract이거나 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>final이거나 abstract이거나</code></h2>\n<hr>\n<h3 id=\"상속으로-발생하는-문제\" style=\"position:relative;\"><a href=\"#%EC%83%81%EC%86%8D%EC%9C%BC%EB%A1%9C-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%EB%AC%B8%EC%A0%9C\" aria-label=\"상속으로 발생하는 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>상속으로 발생하는 문제</code></h3>\n<p><code>상속</code>으로 객체를 <code>확장</code>해서 이용하게 되면 점점 객체들의 관계가 복잡해진다.</p>\n<p><code>A -> A' -> A'' -> A'''</code>\n계속 확장해나가면 편한 것은 분명한데 왜 관계가 복잡해지는 것일까?</p>\n<pre><code class=\"language-ts\">class Documents {\n\tcontents(): number[] {\n\t\treturn [1,2,3];\n\t}\n\n\tlength(): number {\n\t\treturn this.contents().length;\n\t}\n}\n\nclass EncryptedDocument extends Documents {\n\tcontents(): number[] {\n\t\treturn super.contents().concat(super.contents());\n\t}\n}\nconst documents = new Documents();\nconsole.log(documents.length());\t// 3\n\nconst encrypted = new EncryptedDocument();\nconsole.log(encrypted.length());\t// 6\n</code></pre>\n<p><code>Documents</code>를 확장해서 <code>EncryptedDocument</code>에서 <code>contents</code> 메서드를 오버라이드하였다.\n<code>length</code> 메서드는 <code>contents</code> 메서드에 의존적이기 때문에 오버라이드된 <code>contents</code>에 의해 기존의 동작과 전혀 다른 값을 반환하게 되었다.</p>\n<p><code>length</code>를 변경한적이 없는데 값이 이상해져버린 것이다.</p>\n<p>상속은 부모 클래스를 자식 클래스에서 이어받는 단방향 프로세스이다.\n그러나 위의 예시처럼 부모 클래스에서 <code>length</code>가 <code>contents</code>에 의존하는 형태로 (이렇게 자신의 메서드끼리 의존하는 것 자체가 문제를 만드는 원인이다)\n선언되어있던 것이 메서드 오버라이딩을 통해 자식 클래스의 메서드를 올바르지 않은 형태가 되어버리게 하였다.</p>\n<hr>\n<h3 id=\"final이나-abstract\" style=\"position:relative;\"><a href=\"#final%EC%9D%B4%EB%82%98-abstract\" aria-label=\"final이나 abstract permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>final이나 abstract</code></h3>\n<p>클래스를 <code>final</code>이나 <code>abstract</code>로 상속을 제한한다면 위의 문제를 해결할 수 있다.</p>\n<p><code>final</code> 클래스는 상속 자체가 불가능하다.\n따라서 부모-자식 클래스를 만들 수 없고 독립적으로 동작하기 떄문에 컨텍스트가 한정된 범위에서 이뤄진다.\n상속이 불가능하기 때문에 final 인터페이스를 구현하도록하고 생성자로 받아오는 캡슐화를 이용해야한다.</p>\n<p>약간의 자유도를 추가한 <code>abstract</code> 클래스는 완전하게 닫혀있는 형태가 아니다.\n일부는 <code>final</code>로 변경할 수 없는 형태이지만 <code>abstract</code>의 특징은 일부는 직접 구현할 수 있는 형태이다.</p>\n<hr>\n<h3 id=\"그럼-상속을-언제-써야할까\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9F%BC-%EC%83%81%EC%86%8D%EC%9D%84-%EC%96%B8%EC%A0%9C-%EC%8D%A8%EC%95%BC%ED%95%A0%EA%B9%8C\" aria-label=\"그럼 상속을 언제 써야할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>그럼 상속을 언제 써야할까</code></h3>\n<p>상속을 통해 클래스의 역할을 확장하는 것이 아니라 정제하는 경우에 사용하는 것이다.</p>\n<p>확장이 새로운 동작을 하도록 하는 것이라면 정제는 불완전한 것을 완전하게 다듬는 것이다.</p>\n<p>추상 클래스를 통해 불완전한 상태를 만들고 사용하려는 곳에서 정제를 통해 하고자하는 것을 명확하게 할 수 있도록 하는 것이다.</p>\n<pre><code class=\"language-ts\">abstract class Documents {\n\tabstract contents(): number[];\n\n\tlength(): number {\n\t\treturn this.contents().length;\n\t}\n}\n\nclass DefaultDocument extends Documents {\n\tcontents(): number[] {\n\t\treturn [1,2,3];\n\t}\n}\n\nclass EncryptedDocument extends Documents {\n\tcontents(): number[] {\n\t\treturn [11,22,33];\n\t}\n}\nconst documents = new DefaultDocument();\nconsole.log(documents.length());\t// 3\n\nconst encrypted = new EncryptedDocument();\nconsole.log(encrypted.length());\t// 3\n</code></pre>\n<p>위의 문제를 해결하고자 <code>abstract</code>클래스로 변경하였다.\n결론적으로는 <code>length</code> 메서드에서 <code>contents</code> 메서드를 의존하는 것은 동일하다.</p>\n<p>그렇다면 어떻게 문제를 해결한 것일까?</p>\n<p><code>contents</code> 메서드를 각각 클래스에서 직접 구현하도록 하므로써 이 메서드의 의도를 명확하게 하였다.\n상속과 오버라이드를 통해 의도를 모른채 변경되는 일을 해결하였다.</p>\n<p><code>의도를 명확하게 표현하자</code></p>\n<hr>\n<h3 id=\"raii\" style=\"position:relative;\"><a href=\"#raii\" aria-label=\"raii permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>RAII???</code></h3>\n<p><code>객체가 살아있는 동안에만 리소스를 확보하는 것</code>으로 객체를 초기화할 때 리소스를 확보하고 더 이상 객체를 사용하지 않게 된다면 리소스를 해제하는 것이다.</p>\n<p>리소스를 갖고 있을 필요가 없는데 계속 들고 다니는 것은 불필요하다.\n객체의 삶과 같이 리소스를 주고 뺴고 하자는 것인데, 여기서 또 다시 봉착하였다.</p>\n<p><code>그정도로 리소스가 부담이 되는 것일까?</code></p>\n<hr>\n<h3 id=\"인터페이스\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\"인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>인터페이스</code></h3>\n<p><code>final, abstract</code> 클래스로 오버라이드를 제한하는 것을 생각하다보니 인터페이스로 <code>구현을 해야만 하도록</code> 강제하는 것과 같은 목적이지 않을까?</p>\n<p><code>abstract</code>가 그 사이 어디쯤에서 오버라이드 제한하기도 하면서 구현을 강제하는 것인데, 인터페이스로도 동일하게 할 수 있지 않을까?</p>","frontmatter":{"slug":"/blog/elegant-objects-ch4-2","date":"2021년 10월 18일","title":"final이거나 abstract이거나"}}},"pageContext":{"id":"9502e3ae-e9df-571c-8559-23879a82bb6f","frontmatter__slug":"/blog/elegant-objects-ch4-2","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["3000541721","3293771174"]}