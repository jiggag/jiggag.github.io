{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/blog/kotlin-study-ch10/",
    "result": {"data":{"markdownRemark":{"html":"<pre><code class=\"language-markdown\">[참고 도서]\n- 다재다능 코틀린 프로그래밍\n</code></pre>\n<h1>람다로 함수형 프로그래밍 하기</h1>\n<ul>\n<li>선언적인 함수형 프로그래밍으로 코드의 복잡성을 낮춰서 읽기 쉽고 유지보수가 쉽게 한다</li>\n<li>처리할 일과 해결방법을 모두 고려해서 명령하는 것과 다르게 선언형에서는 처리할 일만 알려주고 세부적인 것은 함수 자체가 구현한다</li>\n</ul>\n<h2>함수형</h2>\n<ul>\n<li>\n<p>명령형 => <code>i는 0에서 9까지 증가하면서 for문을 돌면서 조건에 만족하는 값이 있는지 찾아줘</code></p>\n</li>\n<li>\n<p>선언형 => <code>contains() 메소드 호출</code></p>\n</li>\n<li>\n<p>명령형에서 풀어 썼던 내용들이 선언형에서는 내부적으로 <code>캡슐화</code> 되어 있다</p>\n</li>\n<li>\n<p>읽기 쉽게 깔끔해지는 코드는 당연하다</p>\n</li>\n<li>\n<p>세부적인 내용이 알고 싶다면 캡슐화된 메소드를 타고 들어가서 확인하면 된다</p>\n</li>\n<li>\n<p><code>함수형 = 선언형 + 고차함수</code></p>\n</li>\n<li>\n<p><code>함수에 함수를 전달하고 함수를 리턴한다</code> => <code>f(g(h()))()</code> 이런것!? => <code>함수호출 체인 (함수형 컴포지션)</code></p>\n<pre><code class=\"language-kotlin\">// 명령형\nval doubleOfEven = mutableListOf&#x3C;Int>()\nfor (i in (1..10)) {\n    if (i % 2 == 0) {\n    doubleOfEven.add(i * 2)\n    }\n}\nprintln(doubleOfEven) // [4, 8, 12, 16, 20]\n\n// 함수형\nval doubleOfEvenFP = (1..10).filter { it % 2 == 0 }.map { it * 2 }\nprintln(doubleOfEvenFP) // [4, 8, 12, 16, 20]\n</code></pre>\n<ul>\n<li>명령형에서는 mutable한 변수를 사용하였지만 함수형에서는 로직의 흐름 자체로 값을 immutable하게 만들었다</li>\n</ul>\n</li>\n</ul>\n<h2>왜 사용하지? 언제 사용하지?</h2>\n<ul>\n<li>프레임워크와 라이브러리로 점차 명령형에서 선언형으로 흐르고 있다</li>\n<li>스틱 기어 자동차로 기어 변경 와다다 보다 자율 주행 자동차로 흐르듯</li>\n<li>명령형보다 함수형이 덜 복잡하고 연산에 집중할 수 있다\n<ul>\n<li>연산에 집중하기 위해 순수 함수로 동작해야하며 immutable 해야 부작용이 없다</li>\n<li>mutable 해야만 한다면 명령형이 더 나은 선택이 될 수 있다</li>\n</ul>\n</li>\n</ul>\n<h1>람다 표현식</h1>\n<ul>\n<li><code>람다</code> => 고차함수에 인자로 사용되는 짧은 함수\n<ul>\n<li>함수에 계산된 데이터를 전달하기 보다 람다를 이용해 실행 가능한 코드를 전달한다</li>\n<li>람다가 직접 계산하고 결정한다</li>\n<li>고기를 구워서 주는게 아니라 굽는 법을 알려줄테니 너가 직접 해!</li>\n</ul>\n</li>\n</ul>\n<h2>람다의 구조</h2>\n<ul>\n<li>람다는 이름이 없고 타입추론을 이용한 리턴 타입을 가지는 함수이다</li>\n<li><code>{ parameter -> body }</code>\n<ul>\n<li>파라미터와 바디로 구성되어 있다</li>\n<li>멀티라인으로 작성 할 수 있다</li>\n<li>람다의 장점인 읽기 쉬운 코드를 살리기 위해 <code>함수 인자로 전달 될 때 마지막 인자로 위치</code>하도록 한다</li>\n</ul>\n</li>\n</ul>\n<h2>람다 전달과 암시적 파라미터 it</h2>\n<ol>\n<li><code>fun isPrime(n: Int) = n > 1 &#x26;&#x26; (2 until n).none({ i: Int -> n % i == 0})</code>\n<ul>\n<li>함수 파라미터 타입은 추론이 안되서 직접 명시하였다</li>\n</ul>\n</li>\n<li><code>fun isPrime(n: Int) = n > 1 &#x26;&#x26; (2 until n).none({ i -> n % i == 0})</code>\n<ul>\n<li>람다의 파라미터는 타입이 필요하지 않는다</li>\n<li>람다로 전달된 함수의 파라미터로부터 타입을 추론한다</li>\n</ul>\n</li>\n<li><code>fun isPrime(n: Int) = n > 1 &#x26;&#x26; (2 until n).none { i -> n % i == 0 }</code>\n<ul>\n<li>람다에 파라미터가 1개만 존재하는 경우 괄호를 생략할 수 있다</li>\n</ul>\n</li>\n<li><code>fun isPrime(n: Int) = n > 1 &#x26;&#x26; (2 until n).none { n % it == 0 }</code>\n<ul>\n<li>람다의 파라미터가 1개라면 it라는 이름의 암시적 파라미터를 사용할 수 있다</li>\n<li>파라미터를 하나만 받는 짧은 람다에서는 암시적 파라미터로 더 간결하게 작성할 수 있다</li>\n<li>단, 파라미터 이름이 it인 경우와 헷갈릴 수 있다 (파라미터 이름 규칙이 있으면 괜찮지 않을까)</li>\n</ul>\n</li>\n</ol>\n<h2>람다 받기</h2>\n<pre><code class=\"language-kotlin\">fun walkTo(action: (Int) -> Unit, n: Int) = (1..n).forEach { action(it) }\nwalkTo({ i -> print(i) }, 3) // 123\n</code></pre>\n<ul>\n<li>람다를 첫번째 인자로 전달하였다</li>\n<li>람다 장점을 활용하기 위해 마지막 인자로 위치를 변경하고 <code>{}</code>로만 표현할 수 있다</li>\n</ul>\n<pre><code class=\"language-kotlin\">fun walkTo(n: Int, action: (Int) -> Unit) = (1..n).forEach { action(it) }\nwalkTo(3) { i -> print(i) }\nwalkTo(1) { i ->\n    println(\">>> 멀티라인 람다\")\n    println(i)\n}\nwalkTo(3) { print(it) }\n</code></pre>\n<ul>\n<li>마지막 인자로 위치를 변경하고 괄호를 빼고 멀티라인트로 전달해보았다</li>\n</ul>\n<h2>함수 참조 사용</h2>\n<ul>\n<li>\n<p><code>패스스루(::)</code>를 사용해 람다를 더 읽기 쉽게 만들 수 있다</p>\n<ul>\n<li><code>({ x -> method(x) })</code> => <code>(::method)</code></li>\n<li>마치 스크립트에서 <code>list.map(item => fn(item))</code>를 <code>list.map(fn)</code> 같다</li>\n</ul>\n</li>\n<li>\n<p><code>(1..n).forEach { action(it) }</code> => <code>(1..n).forEach(action)</code></p>\n<ul>\n<li>단순히 파라미터를 <code>action</code>으로 보내기 위해 사용되던 <code>{ action(it) }</code> 람다 구조를 제거했다</li>\n</ul>\n</li>\n<li>\n<p><strong><code>패스스루 람다를 사용할 수 있는 함수는 람다이여야 한다!</code></strong></p>\n<ul>\n<li>람다가 아닌 것은 패스스루로 할 수 없다</li>\n<li><code>action</code>은 일반 람다라서 <code>(1..n).forEach(action)</code>로 대체하였다</li>\n<li>만약 일반 함수라면 <code>(1..n).forEach(::action)</code> 형태가 되어야한다</li>\n<li><code>walkTo(3, { i -> print(i) })</code> => <code>walkTo(3, ::print)</code></li>\n</ul>\n</li>\n<li>\n<p><strong><code>암시적 리시버 this ?!!?!</code></strong></p>\n<pre><code class=\"language-kotlin\">fun print(s: Int) = println(\">>> $s\")\nwalkTo(3, ::print) // 1번\nwalkTo(3, this::print) // 2번\n</code></pre>\n<ol>\n<li>1번 print에는 암시적으로 this가 참조되어있다</li>\n<li>2번 print에는 this를 앞에 명시하였다</li>\n<li>만약 this.print 함수가 없었다면 글로벌로 print 함수를 찾아간난다</li>\n</ol>\n</li>\n<li>\n<p><code>walkTo(3, System.out::print)</code></p>\n<ul>\n<li><code>System.out</code> 인스턴스의 print를 호출한다</li>\n</ul>\n</li>\n</ul>\n<h2>함수를 리턴하는 함수</h2>\n<ul>\n<li>함수가 함수를 리턴한다\n<ul>\n<li>함수를 재사용해서 중복되는 코드를 줄일 수 있다</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-kotlin\">fun predicateOfLength(length: Int): (String) -> Boolean {\n    return { input: String -> input.length == length }\n}\nval list = listOf(\"다섯글자야\", \"네글자다\", \"세글자\")\nprintln(list.filter(predicateOfLength(5))) // [다섯글자야]\nprintln(list.filter(predicateOfLength(3))) // [세글자]\n\n>>> filter에서 인자로 predicateOfLength가 리턴하는 함수를 전달하였다\n</code></pre>\n<pre><code class=\"language-kotlin\">fun predicateOfLength(length: Int) = { input: String -> input.length == length }\n\n>>> predicateOfLength를 블록 없이 타입추론이 가능하도록 하였다\n</code></pre>\n<h1>람다와 익명 함수</h1>\n<ul>\n<li>람다를 함수의 인자로 전달하는데 동일한 람다를 여러 곳에서 필요하면 코드가 중복된다\n<ul>\n<li>이런 코드 중복을 피하기 위해 <code>람다를 변수</code>에 담거나 <code>익명 함수</code>로 대체할 수 있다</li>\n</ul>\n</li>\n<li>람다를 변수에 담아서 재사용 하는 경우 코틀린은 파라미터의 타입을 추론할 수 없어 타입을 명시해주어야 한다\n<ol>\n<li><strong><code>val fn = { input: String -> input.length == 2 }</code></strong>\n<ul>\n<li><code>fun predicateOfLength(length: Int) = { input: String -> input.length == length }</code> ⇒ 여기서 input 타입을 명시한 이유와 같다</li>\n<li>파라미터 타입을 전달하였기 때문에 람다의 리턴타입은 코틀린이 추론할 수 있게 되었다</li>\n</ul>\n</li>\n<li><strong><code>val fn: (String) -> Boolean = { input -> input.length == 2 }</code></strong>\n<ul>\n<li>다른 방법으로 리턴 타입을 명시(변수의 타입 명시)하고 파라미터 타입을 뺄 수 있다</li>\n<li>그러나 람다의 리턴 타입이 명시한 타입과 다른 경우 컴파일 에러가 발생한다</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>람다가 할당된 변수의 타입을 정의하면 반드시 리턴 타입을 지정해야한다</li>\n<li>람다의 파라미터 타입을 지정한다면 리턴 타입은 추론된다</li>\n</ul>\n</li>\n<li>변수의 타입은 추론을 사용하고 리턴 타입만 지정하는 <code>익명 함수</code>가 있다\n<ul>\n<li>일반 함수와 동일하게 작성하지만 함수 이름 없이 함수의 리턴 타입을 지정하는 규칙이 있다</li>\n<li><code>list.filter(fun(name: String): Boolean { return name.length == 2 })</code></li>\n<li>람다보다 지저분해져서... 특수한 상황 말고는 <code>람다 >>> 익명</code></li>\n<li><code>return</code> 키워드로 익명 함수에서 리턴된다</li>\n</ul>\n</li>\n</ul>\n<h1>클로저와 렉시컬 스코핑</h1>\n<ul>\n<li>\n<p><code>클로저</code> => 외부 상태에 의존하는 경우</p>\n<pre><code class=\"language-kotlin\">var factor = 2\nval doubleFn = { e: Int -> e * factor }\n</code></pre>\n<ol>\n<li>외부 변수인 factor를 의존한다</li>\n<li>doubleFn 로컬 변수에서 찾지 못했기 때문에 클로저가 정의된 곳으로 스코프를 확장해서 factor를 찾는다</li>\n</ol>\n<p>⇒ <code>렉시컬 스코핑</code></p>\n</li>\n<li>\n<p><strong><code>함수형에서 mutable은 금기사항이다</code></strong></p>\n<ul>\n<li>\n<p>mutable인 factor가 클로저 안에서 변경될 수 있다</p>\n</li>\n<li>\n<p>이것은 결과를 예상할 수 없게 한다</p>\n<pre><code class=\"language-kotlin\">var factor = 2\nval doubled = listOf(1, 2).map { it * factor }\nval doubledAlso = sequenceOf(1, 2).map { it * factor }\nfactor = 0\ndoubled.forEach { print(it) } // 24\ndoubledAlso.forEach { print(it) } // 00\n</code></pre>\n<ul>\n<li>sequenceOf만 변경되었다..... 이게 뭐가 다른걸까?</li>\n</ul>\n</li>\n<li>\n<p>클로저에서 mutable 변수를 사용하는 것이 에러와 혼란의 원인이 된다</p>\n</li>\n<li>\n<p>순수함수를 사용하자</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2>비지역성(non-local)과 라벨(labeled)리턴</h2>\n<ul>\n<li>람다에서는 return 키워드를 사용하지 않는다\n<ul>\n<li>익명함수에서만 사용한다</li>\n<li>외부 함수를 리턴하는게 아니라 익명함수 자체가 값을 리턴한다</li>\n</ul>\n</li>\n<li>람다에는 왜 return이 없을까</li>\n<li>return 같은 처리를 위한 라벨리턴과 비지역성 return이 있다</li>\n</ul>\n<h2>리턴이 허용되지 않는다</h2>\n<ul>\n<li>\n<p>람다에서는 기본적으로 return이 허용되지 않는다</p>\n<pre><code class=\"language-kotlin\">fun invokeWith(n: Int, action: (Int) -> Unit) {\n    println(\">>> 실행 $n\")\n    action(n)\n    println(\">>> 종료 $n\")\n}\nfun caller() {\n    (1..3).forEach { i ->\n        invokeWith(i) {\n            println(\"> invoke 람다 시작 $it\")\n            if (it == 2) { return } // Kotlin: 'return' is not allowed here\n            println(\"> invoke 람다 종료 $it\")\n        }\n    }\n}\ncaller()\n</code></pre>\n<ul>\n<li><code>invokeWith</code>에 인자로 전달하는 람다 함수 안에서 return을 사용했더니 에러가 발생했다</li>\n<li>이 return이 <code>invokeWith</code>에 인자로 전달한 람다를 return하려는 것인지 <code>forEach</code>를 리턴하는 것인지, <code>caller</code>를 리턴하는 것인지 알 수 없기 때문이다</li>\n</ul>\n</li>\n</ul>\n<h2>라벨 리턴</h2>\n<ul>\n<li>\n<p>어느 상황을 return하려는 것인지 알 수 없는 상황에서 라벨 리턴을 사용해 리턴하려는 지점을 명시한다</p>\n</li>\n<li>\n<p><code>return@label</code>을 하게 되면 <code>label@</code>이 달려있는 함수가 return 된다</p>\n<pre><code class=\"language-kotlin\">fun caller() {\n    (1..3).forEach { i ->\n        invokeWith(i) here@ {\n            println(\"> invoke 람다 시작 $it\")\n            if (it == 2) {\n                return@here\n            }\n            println(\"> invoke 람다 종료 $it\")\n        }\n    }\n}\n/*\n>>> 실행 1\n> invoke 람다 시작 1\n> invoke 람다 종료 1\n>>> 종료 1\n>>> 실행 2\n> invoke 람다 시작 2\n>>> 종료 2\n>>> 실행 3\n> invoke 람다 시작 3\n> invoke 람다 종료 3\n>>> 종료 3\n*/\n</code></pre>\n<ul>\n<li>람다의 흐름을 제어해서 라벨이 달려있는 블록으로 점프한다</li>\n</ul>\n<pre><code class=\"language-kotlin\">fun caller() {\n    (1..3).forEach { i ->\n        invokeWith(i) {\n            println(\"> invoke 람다 시작 $it\")\n            if (it == 2) {\n                return@invokeWith\n            }\n            println(\"> invoke 람다 종료 $it\")\n        }\n    }\n}\n</code></pre>\n<ul>\n<li>함수 이름으로 암시적인 라벨로 사용할 수도 있다</li>\n</ul>\n</li>\n<li>\n<p>라벨 리턴으로는 현재 스코프의 람다만 벗어날 수 있다</p>\n</li>\n</ul>\n<h2>논로컬 리턴</h2>\n<ul>\n<li>\n<p>논로컬 리턴으로 현재 함수에서 나갈 수 있다</p>\n<ul>\n<li>라벨 리턴은 현재 함수의 람다만 벗어날 수 있었다</li>\n</ul>\n<pre><code class=\"language-kotlin\">fun caller() {\n    (1..3).forEach { i ->\n        if (i == 2) {\n            return // forEach를 빠져나간다\n        }\n        invokeWith(i) {\n            println(\"> invoke 람다 시작 $it\")\n            println(\"> invoke 람다 종료 $it\")\n        }\n    }\n}\n/*\n>>> 실행 1\n> invoke 람다 시작 1\n> invoke 람다 종료 1\n>>> 종료 1\n*/\n</code></pre>\n<ul>\n<li>일반적인 라벨리턴이 아닌 return으로 forEach에 전달된 람다를 빠져나간다</li>\n</ul>\n</li>\n<li>\n<p>왜 forEach의 람다에서는 return으로 빠져나갈 수 있을까?</p>\n<ul>\n<li>코틀린 스탠다드 라이브러리 forEach는 <code>inline</code> 키워드로 정의되어있다</li>\n</ul>\n</li>\n<li>\n<p>논로컬 리턴은 inline으로 선언된 람다에서만 사용할 수 있는 것이다</p>\n</li>\n</ul>\n<h1>람다를 이용한 인라인 함수</h1>\n<ul>\n<li>람다 사용 시 퍼포먼스를 위해 inline 키워드를 사용한다\n<ul>\n<li>inline 람다는 forEach에서 리턴을 사용하는 것처럼 논로컬 흐름을 제어하기 위해 사용된다</li>\n<li>구체화된 타입 파라미터를 전달하기 위해 inline 키워드를 사용했었다 (ch6)</li>\n</ul>\n</li>\n</ul>\n<h2>인라인 최적화</h2>\n<ol>\n<li>\n<p><strong>인라인 최적화 적용전</strong></p>\n<pre><code class=\"language-kotlin\">fun invokeTwo(n: Int, action1: (Int) -> Unit, action2: (Int) -> Unit): (Int) -> Unit {\n  println(\">>>> invoke $n\")\n  action1(n)\n  action2(n)\n  println(\">>>> invoke exit\")\n  return { _: Int -> println(\">>>> invoke lambda\") }\n}\nfun report(n: Int) {\n  println(\">>>> start report $n\")\n  val stackTrace = RuntimeException().stackTrace\n  println(\"stackTrace.size ${stackTrace.size}\")\n  stackTrace.take(3).forEach(::println)\n}\nfun caller() {\n  invokeTwo(2, { n -> report(n) }, { n -> report(n) })\n}\ncaller()\n\n>>>> invoke 2\n>>>> start report\nstackTrace.size 36\nLamda.report(lamda.kts:121)\nLamda$caller$1.invoke(lamda.kts:126)\nLamda$caller$1.invoke(lamda.kts:1)\n>>>> start report\nstackTrace.size 36\nLamda.report(lamda.kts:121)\nLamda$caller$2.invoke(lamda.kts:126)\nLamda$caller$2.invoke(lamda.kts:1)\n>>>> invoke exit\n</code></pre>\n<ul>\n<li>기본적으로 인라인 최적화를 하지 않은 상태이다\n<ul>\n<li>람다 함수 안에서 호출된 report의 뎁스는 36이다</li>\n</ul>\n</li>\n<li>inline 키워드를 이용해 람다를 받는 함수(invokeTwo)의 성능을 향상시킬 수 있다\n<ul>\n<li><code>**함수를 호출하는 대신 함수의 바이트코드가 함수를 호출하는 위치에 들어가게된다**</code></li>\n<li>이는 함수 호출의 오버헤드는 제거하지만 함수가 호출되는 모든 부분에 바이트코드가 들어가야해서 바이트코드 자체가 커지게 된다</li>\n<li>최적화 이득이 없는 경우 inline 키워드에 경고 문구를 띄워준다\n<ul>\n<li><code>Expected performance impact from inlining is insignificant. Inlining works best for functions with parameters of functional types</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>인라인 최적화 적용</p>\n<pre><code class=\"language-kotlin\">inline fun invokeTwo...\n\n>>>> invoke 2\n>>>> start report 2\nstackTrace.size 33\nLamda.report(lamda.kts:121)\nLamda.caller(lamda.kts:126)\nLamda.&#x3C;init>(lamda.kts:128)\n>>>> start report 2\nstackTrace.size 33\nLamda.report(lamda.kts:121)\nLamda.caller(lamda.kts:126)\nLamda.&#x3C;init>(lamda.kts:128)\n>>>> invoke exit\n</code></pre>\n<ul>\n<li>inline 키워드를 붙여서 정의하여 <code>컴파일러에게 호출을 최적화</code>하라고 알려주었다\n<ul>\n<li>뎁스가 33으로 줄었다</li>\n<li>report 함수에서 <code>Lamda$caller$1.invoke</code> 호출하던 것이 <code>Lamda.caller</code> 로 변경되었다</li>\n</ul>\n</li>\n<li>inline 함수가 엄청 긴 경우 이걸 다 바이트코드로 변환해서 들고 있어야 하기 때문에 최적화를 하는 것이  오히려 파일 크기를 키우는 영향이 생겨버린다\n<ul>\n<li>측정하고 최적화하도록한다</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2>선택적 노인라인 파라미터로 최적화 제거하기</h2>\n<ul>\n<li>\n<p>inline에서 최적화를 요청했다면 <code>noinline</code> 으로 해당 함수 최적화를 제거할 수 있다</p>\n<ul>\n<li>inline 키워드를 사용한 함수에 noinline 키워드를 람다 파라미터에 붙여서 전달한다</li>\n</ul>\n<pre><code class=\"language-kotlin\">inline fun invokeTwo(\n\tn: Int,\n\taction1: (Int) -> Unit,\n\tnoinline action2: (Int) -> Unit\n): (Int) -> Unit {\n\t...\n}\n\n>>>> invoke 2\n>>>> start report 2\nstackTrace.size 33\nLamda.report(lamda.kts:121)\nLamda.caller(lamda.kts:126)\nLamda.&#x3C;init>(lamda.kts:128)\n>>>> start report 2\nstackTrace.size 35\nLamda.report(lamda.kts:121)\nLamda$caller$2.invoke(lamda.kts:126)\nLamda$caller$2.invoke(lamda.kts:1)\n>>>> invoke exit\n</code></pre>\n<ul>\n<li>inline으로 정의된 invokeTwo의 람다 함수 파라미터는 최적화 되어있다</li>\n<li>그러나 noinline으로 붙여주면서 action2 람다에 대해서는 최적화를 제거하였다\n<ul>\n<li>action1보다 action2의 뎁스가 더 깊다</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>인라인 람다에서는 논로컬 리턴 가능하다</h2>\n<ul>\n<li>inline 람다에서는 return 키워드로 함수에서 빠져나가는 것이 가능하다 (논로컬 리턴)\n<ul>\n<li>최적화 되어있어서 함수 뎁스에서 바로 빠져나갈 수 있다</li>\n<li>그러나 noinline으로 최적화를 제거한 action2에서는 더 많은 뎁스(콜스택)이 있기 때문에 return을 사용해도 현재 람다 함수를 빠져나갈 수 없다</li>\n</ul>\n</li>\n<li>inline, noinline 둘 다 라벨리턴은 가능하다\n<ul>\n<li>직접 빠져나갈 곳을 라벨로 기입해줬기 때문에!</li>\n</ul>\n</li>\n</ul>\n<h2>크로스인라인 파라미터</h2>\n<pre><code class=\"language-kotlin\">inline fun invokeTwo(n: Int, action1: (Int) -> Unit, action2: (Int) -> Unit): (Int) -> Unit {\n  println(\">>>> invoke $n\")\n  action1(n)\n  println(\">>>> invoke exit\")\n  return { x: Int -> action2(x) }\n}\n\n// Can't inline 'action2' here: it may contain non-local returns. Add 'crossinline' modifier to parameter declaration 'action2\n</code></pre>\n<ul>\n<li>inline으로 최적화된 함수에서 파라미터로 전달 받은 람다를 실행하는 것이 아니라 새로 리턴하는 경우 컴파일 오류가 발생한다\n<ul>\n<li>언제 실행될지 모르는 리턴 함수로 최적화된 내용을 넣을 수 없다</li>\n</ul>\n</li>\n<li>해결법으로 noinline이나 crossinline 키워드를 붙여준다\n<ul>\n<li>\n<p>noinline은 action2에서 논로컬 리턴을 사용할 수 없음을 명시한다</p>\n</li>\n<li>\n<p>crossinline은 invokeTwo 리턴 함수를 <code>호출하는 부분에서 인라인 최적화를 시킨도록 한다</code></p>\n<pre><code class=\"language-kotlin\">inline fun invokeTwo(\n\tn: Int,\n\taction1: (Int) -> Unit,\n\tcrossinline action2: (Int) -> Unit\n): (Int) -> Unit {\n\t...\n}\n</code></pre>\n<ul>\n<li>호출하는 부분을 인라인으로 어떻게!?</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1>마무리</h1>\n<ul>\n<li>함수형 프로그래밍 짱이다\n<ul>\n<li>고차함수 + 함수형 = 유동적인 코드 + 쉬운 유지보수</li>\n</ul>\n</li>\n<li>람다는 이름이 없는 함수이다\n<ul>\n<li>다른 함수의 인자로 전달이 쉽다</li>\n</ul>\n</li>\n<li>mutable 상태를 많이 사용하면 잠재적인 에러를 유발한다\n<ul>\n<li>코드를 혼란스럽게 한다</li>\n</ul>\n</li>\n<li>코틀린 람다에서는 return 규칙이 많다... 🚨\n<ul>\n<li>라벨리턴</li>\n<li>논로컬리턴</li>\n<li>inline으로 최적화하는 방법\n<ul>\n<li>inline은 성능 향상이 눈에 띄는 경우에 사용...</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1>🚨?!?!?</h1>\n<ul>\n<li><strong>인라인???</strong>\n<ul>\n<li>\n<p>뭐지?</p>\n</li>\n<li>\n<p>최적화를 하는데?</p>\n</li>\n<li>\n<p>왜 외부로 나가는 함수에서는 쓸 수 없을까?</p>\n</li>\n<li>\n<p>인라인을 붙이면 그 인라인 함수를 호출한 자리에 인라인 함수 내부가 그대로 들어가게 된다</p>\n<pre><code class=\"language-kotlin\">inline fun ex() {\n\tprintln(\"1\")\n}\nfun call() {\n\tex()\n}\n\n===>\nfun call() {\n\tprintln(\"1\") // 이런 형태로 인라인된 함수가 들어간다\n}\n</code></pre>\n</li>\n<li>\n<p>그런데 인자로 받은 람다를 다시 리턴하는 경우에는 인라인이 아니라 크로스인라인을 사용해야한다</p>\n<pre><code class=\"language-kotlin\">inline fun ex(crossinline action: (Int) -> Unit): (Int) -> Unit {\n  return { _ -> action(1) }\n}\nfun call(): (Int) -> Unit {\n  return ex { println(it) }\n}\nfun final() {\n  call()(2)\n}\n\n===>\nfun final() {\n  action(1) // 최종적으로 리턴된 람다를 실행하는 곳에 인라인ㄷ\n}\n\n/*\n크로스인라인을 사용하지 않으면\nfun call() {\n\t{ _ -> action(1) }\n}\n이런 형태가 되는건데 말이 안된다!\n*/\n</code></pre>\n</li>\n<li>\n<p><a href=\"%5Bhttps://medium.com/harrythegreat/kotlin-inline-noinline-%ED%95%9C%EB%B2%88%EC%97%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1d54ff34151c%5D(https://medium.com/harrythegreat/kotlin-inline-noinline-%ED%95%9C%EB%B2%88%EC%97%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1d54ff34151c)\">참고: inline, noinline 이해하기</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1>🙈 더 알아보기</h1>\n<ul>\n<li>\n<p>선언형 vs 명령형</p>\n</li>\n<li>\n<p>클로저</p>\n</li>\n<li>\n<p>함수형</p>\n<ul>\n<li><code>f(g(h(x)))</code></li>\n<li><a href=\"https://velog.io/@nakta/FP-in-JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A1%9C-%EC%A0%91%ED%95%B4%EB%B3%B4%EB%8A%94-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%95%A8%EC%88%98-%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98-%EC%BB%A4%EB%A7%81-s7k2z039vb\">참고: 함수형 컴포지션</a></li>\n<li>전에 함수형 프로그래밍 스터디(물론 소리 없이 사라졌다) 기억이 새록새록</li>\n<li>커링</li>\n</ul>\n</li>\n<li>\n<p>암시적 리시버 this</p>\n<ul>\n<li>apply, bind, call 처럼 바인딩해주는 개념과 유사하다고 생각했는데...</li>\n</ul>\n</li>\n<li>\n<p>리스트와 시퀀스</p>\n<pre><code class=\"language-kotlin\">var factor = 2\nval doubled = listOf(1, 2).map { it * factor }\nval doubledAlso = sequenceOf(1, 2).map { it * factor }\nfactor = 0\ndoubled.forEach { print(it) } // 24\ndoubledAlso.forEach { print(it) } // 00\n</code></pre>\n<ul>\n<li>위 예시에서 mutable한 factor가 변경되자 <code>listOf</code>와 <code>sequenceOf</code>의 결과값이 다르게 나왔다</li>\n<li>코틀린 Sequence는 모든 단계가 처리되고 마지막에 결과를 요청한 순간 연산이 발생한다\n<ul>\n<li>factor가 변경되고 나서 연산이 일어나므로 00을 리턴하였다</li>\n</ul>\n</li>\n<li>Collection인 경우에는 각 단계가 끝나는 즉시 결과를 처리한다\n<ul>\n<li>listOf가 처리된 순간의 factor의 값 2를 따라서 결과를 24로 반환하였다</li>\n</ul>\n</li>\n<li><a href=\"%5Bhttps://iosroid.tistory.com/79%5D(https://iosroid.tistory.com/79)\">참고: 코틀린의 시퀀스</a></li>\n</ul>\n</li>\n<li>\n<p>return</p>\n<ul>\n<li>람다에서 빠져나가기 위해 <code>라벨 리턴</code>\n<ul>\n<li>람다를 호출한 곳이 아니라 람다가 정의된 곳에서 빠져나간다</li>\n</ul>\n</li>\n<li>inline으로 정의된 경우 <code>논로컬 리턴</code>\n<ul>\n<li>현재 동작중인 람다를 선언한 곳 바깥으로 나간다</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"slug":"/blog/kotlin-study-ch10","date":"2021년 5월 19일","title":"람다로 함수형 프로그래밍"}}},"pageContext":{"id":"89f85043-b3ee-513c-8c82-6bb900e02244","frontmatter__slug":"/blog/kotlin-study-ch10","__params":{"frontmatter__slug":"blog"}}},
    "staticQueryHashes": ["3000541721","3293771174"]}