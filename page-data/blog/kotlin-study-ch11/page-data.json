{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/kotlin-study-ch11/","result":{"data":{"markdownRemark":{"html":"<pre><code class=\"language-markdown\">[참고 도서]\n- 다재다능 코틀린 프로그래밍\n</code></pre>\n<h1 id=\"코틀린의-내부-반복자\" style=\"position:relative;\"><a href=\"#%EC%BD%94%ED%8B%80%EB%A6%B0%EC%9D%98-%EB%82%B4%EB%B6%80-%EB%B0%98%EB%B3%B5%EC%9E%90\" aria-label=\"코틀린의 내부 반복자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코틀린의 내부 반복자</h1>\n<ul>\n<li>함수형 프로그래밍에서는 내부 반복자를 사용한다</li>\n<li>내부 반복자는 <code>반복을 자동으로 실행한다</code>\n<ul>\n<li>개발자가 반복에 집중하는 것이 아니라 콜렉션이나 범위에 있는 <code>각 요소</code>에 집중하도록 해준다</li>\n</ul>\n</li>\n<li>내부 반복자는 <code>명시적 뮤터빌리티를 피하게 해준다</code></li>\n<li>내부 반복자는 람다를 전달해 반복과 관련된 여러 작업들을 수행하는 고차함수이다\n<ul>\n<li>고차함수는 반복을 위한 공통 코드를 제공한다</li>\n<li>고차함수 filter()에 람다가 실제 선택될 요소를 전달한다</li>\n</ul>\n</li>\n<li>코틀린의 내부 반복자로 편리하고 표현이 간단하지만 외부 반복자에 비해 <code>퍼포먼스</code>가 안 좋을 수 있다\n<ul>\n<li>전체 데이터 콜렉션을 다루는 경우 오버헤드 이슈가 존재하는데 이를 <code>시퀀스</code> 를 이용해 실행을 지연시켜서 처리한다</li>\n<li>(이전 챕터에서 알아본 listOf와 sequenceOf의 mutable한 변수에 대한 결과값 차이가 이러한 이유이다)</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"외부-반복자-vs-내부-반복자\" style=\"position:relative;\"><a href=\"#%EC%99%B8%EB%B6%80-%EB%B0%98%EB%B3%B5%EC%9E%90-vs-%EB%82%B4%EB%B6%80-%EB%B0%98%EB%B3%B5%EC%9E%90\" aria-label=\"외부 반복자 vs 내부 반복자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>외부 반복자 vs 내부 반복자</h1>\n<pre><code class=\"language-kotlin\">val numbers = listOf(1, 2, 3)\n\n// 외부 반복자 for..in\nfor (i in numbers) {\n  if (i > 2) {\n    println(\">>> $i\")\n  }\n}\n\n// 내부 반복자 filter + forEach\nnumbers.filter { it > 2 }\n\t.forEach { println(it) }\n</code></pre>\n<ul>\n<li>\n<p>외부 반복자보다 내부 반복자를 이용해 좀 더 흐름이 아름다워졌다</p>\n</li>\n<li>\n<p>filter, forEach 고차함수를 이용해 람다를 전달하였다</p>\n</li>\n<li>\n<p>만약 새로운 값을 반환하는 것이 필요한 경우에도 내부 반복자를 사용하여 <code>함수형 파이프라인</code> 을 구현할 수 있다</p>\n<pre><code class=\"language-kotlin\">// 외부 반복자\nval mutableResult = mutableListOf&#x3C;Int>()\nfor (i in numbers) {\n  if (i > 1) {\n    mutableResult.add(i)\n  }\n}\nprintln(mutableResult)\n\n// 내부 반복자\nval immutableResult = numbers.filter { it > 1 }\n  .map { it }\nprintln(immutableResult)\n</code></pre>\n</li>\n</ul>\n<h1 id=\"내부-반복자\" style=\"position:relative;\"><a href=\"#%EB%82%B4%EB%B6%80-%EB%B0%98%EB%B3%B5%EC%9E%90\" aria-label=\"내부 반복자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>내부 반복자</h1>\n<h2 id=\"filter-map-reduce\" style=\"position:relative;\"><a href=\"#filter-map-reduce\" aria-label=\"filter map reduce permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>filter, map, reduce</h2>\n<ul>\n<li>코틀린 스탠다드 라이브러리에서 내부 반복을 위해 제공하는 고차함수</li>\n<li>일반적으로 js에서 사용하던 방식과 동일하나 reduce에 초기값 인자가 없는 것이 다르네?</li>\n<li>전달되는 콜렉션을 변경하지 않고 연산을 수행하며 복사된 값을 리턴한다 ⇒ Immutable</li>\n</ul>\n<h2 id=\"first\" style=\"position:relative;\"><a href=\"#first\" aria-label=\"first permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>first</h2>\n<ul>\n<li><code>first()</code> 함수를 사용하여 콜렉션의 첫번째 요소를 가져온다</li>\n<li><code>list[0]</code>로 가져와도 되는데 왜 이 함수를 사용하는걸까?\n<ul>\n<li><code>함수형 파이프라인!!!</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"flatmap\" style=\"position:relative;\"><a href=\"#flatmap\" aria-label=\"flatmap permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>flatMap</h2>\n<pre><code class=\"language-kotlin\">val obj = listOf(listOf(\"1\", \"2\", \"3\"), listOf(\"4\", \"5\", \"6\")) // List&#x3C;List&#x3C;String>>\nval flat = obj.map { listOf(\"value $it\") }.flatten() // List&#x3C;String>\nval flatMap = obj.flatMap { value -> listOf(\"new value $value\") } // List&#x3C;Sting>\nprintln(flat) // [value [1, 2, 3], value [4, 5, 6]]\nprintln(flatMap) // [new value [1, 2, 3], new value [4, 5, 6]]\n</code></pre>\n<ul>\n<li><code>flatten()</code> 함수를 이용해 중첩된 콜렉션을 플랫하게 펼쳐진 데이터로 만들어준다</li>\n<li><code>flatMap()</code> 함수는 map + flatten과 동일하게 동작한다</li>\n</ul>\n<h2 id=\"sortedby\" style=\"position:relative;\"><a href=\"#sortedby\" aria-label=\"sortedby permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>sortedBy</h2>\n<pre><code class=\"language-kotlin\">data class People(val name: String, val age: Int)\nval people = listOf(\n  People(\"가하파\", 10),\n  People(\"가나다\", 5)\n)\nval sortedName = people.sortedBy { it.name }\nprint(sortedName) // [People(name=가나다, age=5), People(name=가하파, age=10)]\n</code></pre>\n<ul>\n<li>함수형 파이프라인 안에서 정렬한다</li>\n<li><code>sortedBy, sortedByDescending</code></li>\n</ul>\n<h2 id=\"groupby\" style=\"position:relative;\"><a href=\"#groupby\" aria-label=\"groupby permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>groupBy</h2>\n<pre><code class=\"language-kotlin\">val groupedName = people.groupBy { it.name.first() }\nprint(groupedName) // {가=[People(name=가하파, age=10), People(name=가나다, age=5)]}\n</code></pre>\n<ul>\n<li>groupBy로 전달한 값이 키가 되어 그룹화한다</li>\n</ul>\n<h1 id=\"지연-연산을-위한-시퀀스\" style=\"position:relative;\"><a href=\"#%EC%A7%80%EC%97%B0-%EC%97%B0%EC%82%B0%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%8B%9C%ED%80%80%EC%8A%A4\" aria-label=\"지연 연산을 위한 시퀀스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>지연 연산을 위한 시퀀스</h1>\n<ul>\n<li>시퀀스는 콜렉션의 성능 향상을 위해 최적화된 랩퍼이다</li>\n<li>콜렉션의 연산이 계속 실행되는 것과 다르게 시퀀스에서 호출되는 함수는 지연되어 실행된다\n<ul>\n<li>실행이 불필요한 경우 실행을 지연시킨다</li>\n<li>최적화를 하지 않으면 필요하지 않은 연산도 계속 하기 때문에 성능이 떨어진다</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"시퀀스로-성능-향상하기\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%ED%80%80%EC%8A%A4%EB%A1%9C-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81%ED%95%98%EA%B8%B0\" aria-label=\"시퀀스로 성능 향상하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시퀀스로 성능 향상하기</h2>\n<ul>\n<li>\n<p>시퀀스를 사용하지 않은 일반적인 경우</p>\n<pre><code class=\"language-kotlin\">data class Person(val name: String, val age: Int)\nval people = listOf(\n  Person(\"가하파\", 10),\n  Person(\"가나다\", 5),\n  Person(\"어머나\", 15)\n)\nfun isAdult(person: Person): Boolean {\n  println(\"person ${person.name}: ${person.age}\")\n  return person.age > 5\n}\nfun fetchName(person: Person): String {\n  println(\"fetch name ${person.name}\")\n  return person.name\n}\nval firstAdultName = people.filter(::isAdult).map(::fetchName).first()\nprintln(firstAdultName)\n\n>>>\nperson 가하파: 10\nperson 가나다: 5\nperson 어머나: 15\nfetch name 가하파\nfetch name 어머나\n가하파\n</code></pre>\n<ol>\n<li>filter와 map에 람다 대신 함수 레퍼런스를 전달하였다</li>\n<li>filter에서 실행한 isAdult로 adult 리스트를 만들었다</li>\n<li>map으로 adultName 리스트를 만들었다</li>\n<li>그리고 adultName 리스트의 첫번째 요소를 가져와서 반환하였다</li>\n</ol>\n<p>⇒ 하나의 값 (adultName 리스트의 첫번째 요소)를 얻기 위해 모든 연산(person 로그가 계속 찍혔다)이 실행되어야한다</p>\n</li>\n<li>\n<p>사용하지 않을 연산은 하지 않도록 <code>시퀀스</code>로 연산을 지연시킨다</p>\n<pre><code class=\"language-kotlin\">val firstAdultName = people.asSequence().filter(::isAdult).map(::fetchName).first()\n\n>>>\nperson 가하파: 10\nfetch name 가하파\n가하파\n</code></pre>\n<ol>\n<li><code>asSequence()</code> 로 people 콜렉션을 한번 감싸서 사용하였다</li>\n</ol>\n<p>⇒ 필요한 연산만 실행되었다(people 로그가 하나만 찍혔다)</p>\n</li>\n<li>\n<p>시퀀스로 감싸서 사용하면 시퀀스가 시퀀스를 리턴하고 시퀀스는 다시 시퀀스를 리턴한다</p>\n<ul>\n<li>최종적으로 filter나 map에 전달된 람다는 실행되지 않고 지연된다</li>\n<li>그리고 first 함수로 연산이 시작되는 순간 파이프라인을 타고 실행된 결과를 반환한다</li>\n</ul>\n</li>\n<li>\n<p><strong><code>시퀀스는 마지막 메소드가 호출될 때까지 실행을 연기하고 결과를 얻기 위해 최소한의 연산만을 수행한다</code></strong></p>\n<ul>\n<li>그럼 모든 콜렉션을 시퀀스로 지연 연산 시키면 성능이 좋을까?</li>\n<li>지연 연산을 사용하지 않는 것이 디버깅이나 코드 추론이 용이하다</li>\n<li>코드가 커질수록 시퀀스를 사용해서 중간에 연산 과정에서 생기는 오버헤드를 줄일 수 있다</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"무한-시퀀스\" style=\"position:relative;\"><a href=\"#%EB%AC%B4%ED%95%9C-%EC%8B%9C%ED%80%80%EC%8A%A4\" aria-label=\"무한 시퀀스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>무한 시퀀스</h2>\n<ul>\n<li>지연 연산을 통해 퍼포먼스만 얻는 것이 아니라 <code>온디맨드 연산</code>에도 장점이 있다\n<ul>\n<li>\n<p>온디맨드 연산은 요소의 무한 시퀀스를 만드는데 도움을 준다</p>\n</li>\n<li>\n<p>무한 시퀀스는 값으로 시작되어 발생 패턴에 따라 시퀀스가 따라온다</p>\n<p>⇒ 피보나치 수열 (앞의 두 값을 더한 결과값이 새로운 값이 되므로 무한 시퀀스)</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-kotlin\">fun isPrime(value: Long) = value > 1 &#x26;&#x26; (2 until value).none { i -> value % i == 0L }\ntailrec fun nextPrime(value: Long): Long = if (isPrime(value + 1)) value + 1 else nextPrime(value + 1)\n\nprintln(nextPrime(2)) // 3\nprintln(nextPrime(5)) // 7\n</code></pre>\n<ul>\n<li>\n<p>해당 값이 소수인지 검증하는 isPrime</p>\n</li>\n<li>\n<p>다음 소수 값을 반환하는 nextPrime</p>\n</li>\n<li>\n<p><code>generateSequence()</code> 를 이용해 무한 시퀀스를 만들 수 있다</p>\n<pre><code class=\"language-kotlin\">val primes = generateSequence(5, ::nextPrime)\nprintln(primes.take(4).toList()) // [5, 7, 11, 13]\n</code></pre>\n<ul>\n<li>5부터 nextPrime을 호출하는 무한시퀀스 primes를 만들었다</li>\n<li>그리고 take로 4개의 값을 가져오도록하였다\n<ul>\n<li>이때까지 primes의 nextPrime은 호출이 지연되어있다</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>seqeunce</code> 람다로 온디맨드 무한 시퀀스를 만들 수 있다</p>\n<pre><code class=\"language-kotlin\">val primes = sequence {\n  var i: Long = 0\n  while (true) {\n    i++\n    if (isPrime(i)) {\n      yield(i)\n    }\n  }\n}\nprintln(primes.take(4).toList()) // [2, 3, 5, 7]\n</code></pre>\n</li>\n</ul>\n<h1 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h1>\n<ul>\n<li>함수형 프로그래밍에서 많이 사용하는 내부 반복자를 이용해 유연하고 표현력 있는 코드를 작성한다</li>\n<li>코틀린 콜렉션에서 직접 사용할 수 있는 내부 반복자를 제공하지만 <code>콜렉션의 모든 요소에 대하여 무조건 반복 실행 되기 때문에 오버헤드가 발생한다</code>\n<ul>\n<li>필요하지 않는 실행까지도 모두 연산을 실행하기 때문인데</li>\n<li>이를 위해 코틀린은 시퀀스를 랩퍼로 제공하여 실행을 지연시킨다</li>\n</ul>\n</li>\n<li>지연 연산 실행으로 필요하지 않은 연산을 제거하여 성능을 끌어올린다</li>\n</ul>\n<h1 id=\"\" style=\"position:relative;\"><a href=\"#\" aria-label=\" permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🚨?!?!?</h1>\n<hr>\n<h1 id=\"-더-알아보기\" style=\"position:relative;\"><a href=\"#-%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0\" aria-label=\" 더 알아보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🙈 더 알아보기</h1>\n<ul>\n<li>\n<p>무한 시퀀스</p>\n<pre><code class=\"language-kotlin\">val primes = sequence {\n  var i: Long = 0\n  while (true) {\n    i++\n    if (isPrime(i)) {\n      yield(i)\n      yield(i)\n    }\n  }\n}\nprintln(primes.take(4).toList()) // [2, 2, 3, 3]\n</code></pre>\n<ul>\n<li>yield???\n<ul>\n<li>generator 같네?!</li>\n</ul>\n</li>\n<li>take로 4개의 값을 가져오겠다라고 했는데</li>\n<li>yield가 2번 있으니 하나씩 값을 반환 → [2, 2, 3, 3]</li>\n</ul>\n</li>\n</ul>","frontmatter":{"slug":"/blog/kotlin-study-ch11","date":"2021년 5월 26일","title":"filter, map, reduce, sequence"}}},"pageContext":{"id":"86fe3ea1-5968-5c30-9f6a-c5648406a3b0","frontmatter__slug":"/blog/kotlin-study-ch11","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["3000541721","3293771174"]}