{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/kotlin-study-ch12/","result":{"data":{"markdownRemark":{"html":"<pre><code class=\"language-markdown\">[참고 도서]\n- 다재다능 코틀린 프로그래밍\n</code></pre>\n<h1 id=\"연산자-오버로딩\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%82%B0%EC%9E%90-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9\" aria-label=\"연산자 오버로딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연산자 오버로딩</h1>\n<ul>\n<li>\n<p>같은 연산 결과를 얻지만 + 연산자를 사용해 더 유연하고 유창하게 한다</p>\n<pre><code class=\"language-kotlin\">num1.sum(num2)\nnum1 + num2\n</code></pre>\n</li>\n<li>\n<p>코틀린에서는 +, -, *와 같은 연산자를 숫자 타입 뿐만아니라 직접 만든 객체에 대해서도 사용할 수 있다</p>\n<pre><code class=\"language-kotlin\">withList + appleWatch\n</code></pre>\n<ul>\n<li>그러나 명확하게 코드를 전달하지 못한다면 오히려 어뷰징이 되어버린다</li>\n<li>연산자의 동작 의도를 정확하게 전달해야한다</li>\n</ul>\n</li>\n<li>\n<p>코틀린이 Java 바이트 코드로 컴파일되는데, JVM은 연산자 오버로딩을 지원하지 않는다</p>\n<ul>\n<li>\n<p>그래서 내부적으로 연산자를 또 다른 명명된 메소드로 매핑하여 사용한다</p>\n<pre><code class=\"language-kotlin\">operator fun Pair&#x3C;Int, Int>.plus(other: Pair&#x3C;Int, Int>) = Pair(first + other.first, second + other.second)\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><code>직접 만든 클래스에 연산자를 오버로딩 하기 위해서 특화된 메소드를 클래스의 멤버함수로 작성해야한다</code></p>\n<ul>\n<li>\n<p>oparator로 마크된 연산자 대응 메소드로 오버로딩 한다</p>\n<pre><code class=\"language-kotlin\">data class Complex(val real: Int, val imaginary: Int) {\n  operator fun times(other: Complex) = Complex(real * other.real, imaginary * other.imaginary)\n}\nprintln(Complex(2, 4) * Complex(3, 4)) // Complex(real=6, imaginary=16)\n</code></pre>\n</li>\n<li>\n<p>오버로딩한 연산자로 객체를 변경하면 안된다</p>\n<ul>\n<li>immutable 해야한다</li>\n<li>연산 후 새로운 결과값을 반환하는 것이다</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"확장-함수와-속성을-이용한-인젝팅\" style=\"position:relative;\"><a href=\"#%ED%99%95%EC%9E%A5-%ED%95%A8%EC%88%98%EC%99%80-%EC%86%8D%EC%84%B1%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B8%EC%A0%9D%ED%8C%85\" aria-label=\"확장 함수와 속성을 이용한 인젝팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>확장 함수와 속성을 이용한 인젝팅</h1>\n<ul>\n<li>이미 존재하는 클래스에 메소드와 속성을 인젝팅할 수 있다\n<ul>\n<li>바이트코드 변경 없이 추가할 수 있다</li>\n<li>상속이 아니라 확장</li>\n</ul>\n</li>\n<li>멤버 함수 >>> 확장 함수\n<ul>\n<li>이름이 같아서 충돌하는 경우 멤버 함수가 이긴다</li>\n<li>인스턴스에서 메소드를 찾고 없으면 확장 함수를 찾기 때문</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"확장-함수를-이용한-메소드-인젝팅\" style=\"position:relative;\"><a href=\"#%ED%99%95%EC%9E%A5-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%9D%B8%EC%A0%9D%ED%8C%85\" aria-label=\"확장 함수를 이용한 메소드 인젝팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>확장 함수를 이용한 메소드 인젝팅</h3>\n<pre><code class=\"language-kotlin\">data class Point(val x: Int, val y: Int)\ndata class Circle(val cx: Int, val cy: Int, val radius: Int)\nfun Circle.contains(point: Point) = (point.x - cx) * (point.x - cx) + (point.y - cy) * (point.y - cy) &#x3C; radius * radius\n\n/*\ndata class Circle(val cx: Int, val cy: Int, val radius: Int) {\n  fun contains(point: Point) = (point.x - cx) * (point.x - cx) + (point.y - cy) * (point.y - cy) &#x3C; radius * radius\n}\n*/\n\nval circle = Circle(100, 100, 20)\nval point = Point(20, 40)\nprintln(circle.contains(point))\n</code></pre>\n<ul>\n<li>클래스 내부에 작성한 것과 동일하게 동작한다\n<ul>\n<li>확장 함수에서 암시적으로 클래스 인스턴스에 접근한다</li>\n<li>단, private 속성에는 접근할 수 없다</li>\n</ul>\n</li>\n<li>확장 함수는 패키지의 static 메소드로 만들어진다</li>\n</ul>\n<h3 id=\"확장-함수를-이용한-연산자-인젝팅\" style=\"position:relative;\"><a href=\"#%ED%99%95%EC%9E%A5-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%9D%B8%EC%A0%9D%ED%8C%85\" aria-label=\"확장 함수를 이용한 연산자 인젝팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>확장 함수를 이용한 연산자 인젝팅</h3>\n<pre><code class=\"language-kotlin\">operator fun Circle.contains(point: Point) = (point.x - cx) * (point.x - cx) + (point.y - cy) * (point.y - cy) &#x3C; radius * radius\n</code></pre>\n<ul>\n<li>연산자 오버로딩과 동일하게 operator 키워드를 붙여준다</li>\n</ul>\n<h3 id=\"확장-속성을-이용한-속성-인젝팅\" style=\"position:relative;\"><a href=\"#%ED%99%95%EC%9E%A5-%EC%86%8D%EC%84%B1%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%86%8D%EC%84%B1-%EC%9D%B8%EC%A0%9D%ED%8C%85\" aria-label=\"확장 속성을 이용한 속성 인젝팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>확장 속성을 이용한 속성 인젝팅</h3>\n<pre><code class=\"language-kotlin\">val Circle.area: Double\n  get() = kotlin.math.PI * radius * radius\n\nprintln(Circle(100, 100, 10).area)\n</code></pre>\n<ul>\n<li>확장 속성은 클래스 내부에 존재하는 것이 아니라서 <code>백킹 필드</code>를 가질 수 없다</li>\n</ul>\n<h3 id=\"서드파티-클래스-인젝팅\" style=\"position:relative;\"><a href=\"#%EC%84%9C%EB%93%9C%ED%8C%8C%ED%8B%B0-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%9D%B8%EC%A0%9D%ED%8C%85\" aria-label=\"서드파티 클래스 인젝팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서드파티 클래스 인젝팅</h3>\n<pre><code class=\"language-kotlin\">fun String.isPalindrome(): Boolean {\n  return reversed() == this\n}\nprintln(\"wow\".isPalindrome())\n</code></pre>\n<ul>\n<li>코틀린 내부 함수 또는 서드파티 클래스를 확장할 수 있다</li>\n<li>이미 존재하는 메소드의 동작을 바꾸면 안된다</li>\n</ul>\n<h3 id=\"static-메소드-인젝팅\" style=\"position:relative;\"><a href=\"#static-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%9D%B8%EC%A0%9D%ED%8C%85\" aria-label=\"static 메소드 인젝팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>static 메소드 인젝팅</h3>\n<ul>\n<li>\n<p>클래스의 컴패니언 객체를 확장할 수 있다</p>\n<ul>\n<li>클래스가 컴패니언 객체를 가지고 있다면 static 메소드를 인젝팅할 수 있다</li>\n</ul>\n<pre><code class=\"language-kotlin\">fun String.Companion.toURL(link: String) = java.net.URL(link)\nval url = String.toURL(\"https://www.naver.com\")\nprint(url)\n</code></pre>\n</li>\n</ul>\n<h3 id=\"클래스-내부에서-인젝팅\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-%EC%9D%B8%EC%A0%9D%ED%8C%85\" aria-label=\"클래스 내부에서 인젝팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스 내부에서 인젝팅</h3>\n<ul>\n<li>\n<p>클래스 내부에서 인젝팅하는 경우</p>\n<ul>\n<li>외부에서 확장함수를 사용하려고 하면 에러가 발생한다</li>\n</ul>\n<pre><code class=\"language-kotlin\">class Point() {\n  private val value = \"wow\"\n  fun String.isPalindrome() = \"${value}, ${this@Point.value}, ${this.toString()}\"\n  \n  override fun toString(): String {\n    return \"pop\".isPalindrome()\n  }\n}\nval point = Point()\nprint(point.toString()) // wow, wow, pop\n</code></pre>\n<ul>\n<li>확장 함수가 클래스 내부에서 생성되었기 때문에 <code>this와 this@Point</code> 두개의 리시버를 갖고 있다\n<ul>\n<li>익스텐션 리시버: 해당 확장 함수를 실행하는 객체 <code>this</code></li>\n<li>디스패치 리시버: 확장 함수를 추가한 대상 클래스 인스턴스 <code>this@Point</code></li>\n<li>버블링으로 익스텐션에서 먼저 찾고 없으면 디스패치로 찾으로 간다</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>특정 확장 함수를 클래스 내부에서만 사용하도록 스코프를 좁히는데 유용하다</p>\n</li>\n</ul>\n<h1 id=\"함수-확장\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98-%ED%99%95%EC%9E%A5\" aria-label=\"함수 확장 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수 확장</h1>\n<ul>\n<li>\n<p>클래스에 메소드를 인젝트한 것 처럼 함수에도 메소드를 인젝트할 수 있다</p>\n<ul>\n<li><code>코틀린에서 함수는 객체이다</code></li>\n</ul>\n<pre><code class=\"language-kotlin\">fun &#x3C;T, R, U> ((T) -> R).andThen(next: (R) -> U): (T) -> U = { input: T -> next(this(input)) }\n\nfun increment(number: Int): Double = number + 1.toDouble()\nfun double(number: Double) = number * 2\nval incrementAndDouble = ::increment.andThen(::double)\nprintln(incrementAndDouble(5)) // 12.0\n</code></pre>\n<ul>\n<li>T → R 함수를 R → U를 인자로 받는 <code>andThen</code> 메소드를 호출해서 T → U를 리턴한다</li>\n<li><code>fun String.isPalindrome() = ...</code> 처럼 <code>((T) → R)</code> 형태의 함수를 확장한 것이다</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"infix를-이용한-중위표기법\" style=\"position:relative;\"><a href=\"#infix%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%A4%91%EC%9C%84%ED%91%9C%EA%B8%B0%EB%B2%95\" aria-label=\"infix를 이용한 중위표기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>infix를 이용한 중위표기법</h1>\n<ul>\n<li>\n<p>중위표기법 ⇒ 연산자가 중간에 있거나 피연산자 사이에 있는 것</p>\n<ul>\n<li><code>if (obj.instanceOf(String)) { ... }</code> 를 중위표기법을 사용해 <code>if (obj instanceOf String) { ... }</code> 형태로 변경하였다</li>\n</ul>\n</li>\n<li>\n<p>코틀린에서 연산자는 항상 자동으로 중위표기법을 사용한다</p>\n<ul>\n<li>그러나 메소드는 기본적으로 중위표기법을 사용하지 않는다</li>\n</ul>\n</li>\n<li>\n<p><code>infix</code> 어노테이션을 사용해 메소드를 중위표기법으로 나타낼 수 있다</p>\n<pre><code class=\"language-kotlin\">operator fun Circle.contains(point: Point) = (point.x - cx) * (point.x - cx) + (point.y - cy) * (point.y - cy) &#x3C; radius * radius\nprintln(circle.contains(point))\n\n>>>\n\ninfix operator fun Circle.contains(point: Point) = (point.x - cx) * (point.x - cx) + (point.y - cy) * (point.y - cy) &#x3C; radius * radius\nprintln(circle contains point)\n</code></pre>\n</li>\n<li>\n<p>infix를 이용해 함수에 유연성을 제공한다</p>\n<ul>\n<li>그러나 <code>infix 메소드는 하나의 파라미터</code>만 받아야하는 제한이 있다</li>\n<li>vararg나 기본 파라미터는 사용 불가능하다</li>\n</ul>\n<p>⇒ 파라미터가 여러개면 <code>circle contains param1 param2</code> 이렇게 써야하는데 이상하니깐!?</p>\n</li>\n</ul>\n<h1 id=\"any-객체를-이용한-자연스러운-코드\" style=\"position:relative;\"><a href=\"#any-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9E%90%EC%97%B0%EC%8A%A4%EB%9F%AC%EC%9A%B4-%EC%BD%94%EB%93%9C\" aria-label=\"any 객체를 이용한 자연스러운 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Any 객체를 이용한 자연스러운 코드</h1>\n<ul>\n<li><code>also(), apply(), let(), run()</code>\n<ul>\n<li>람다 표현식을 파라미터로 받고 전달받은 람다를 실행하고 객체를 리턴한다</li>\n<li><code>각 메소드의 리시버(this)와 리턴 결과의 차이</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"let\" style=\"position:relative;\"><a href=\"#let\" aria-label=\"let permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>let()</h3>\n<pre><code class=\"language-kotlin\">val context = \"context\"\nval result = context.let { arg -> \n\tprintln(arg) // context\n\t\"$arg 업데이트\"\n}\nprintln(result) // context 업데이트\n</code></pre>\n<ul>\n<li>컨택스트 객체를 아규먼트로 람다에게 전달한다</li>\n<li>람다의 this는 렉시컬 스코프이고 람다의 리턴값이 let의 호출 결과로 리턴된다</li>\n</ul>\n<h3 id=\"also\" style=\"position:relative;\"><a href=\"#also\" aria-label=\"also permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>also()</h3>\n<pre><code class=\"language-kotlin\">data class Context(val value: String)\nval context = Context(\"context\")\nval result = context.also { arg ->\n  println(arg) // Context(value=context)\n  \"이값이아니라\"\n}\nprintln(result) // Context(value=context)\n</code></pre>\n<ul>\n<li>컨택스트 객체를 아규먼트로 람다에게 전달한다</li>\n<li>this도 let()과 동일하다</li>\n<li>also()는 let()과는 다르게 람다의 리턴값이 아니라 컨텍스트 객체를 also() 리턴값으로 가진다\n<ul>\n<li>also()가 전달받은 람다의 리턴타입은 Unit이다</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"run\" style=\"position:relative;\"><a href=\"#run\" aria-label=\"run permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>run()</h3>\n<ul>\n<li>\n<p>람다에 아규먼트를 전달하지 않는다</p>\n<pre><code class=\"language-kotlin\">data class Context(val value: String)\nval context = Context(\"context\")\nval result = context.run {\n  println(value) // context\n  \"title\"\n}\nprintln(result) // title\n</code></pre>\n</li>\n<li>\n<p>컨텍스트 자체가 람다의 this로 바인딩한다</p>\n</li>\n<li>\n<p>람다가 리턴하는 값이 run()의 리턴값이다</p>\n</li>\n</ul>\n<h3 id=\"apply\" style=\"position:relative;\"><a href=\"#apply\" aria-label=\"apply permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>apply()</h3>\n<pre><code class=\"language-kotlin\">data class Context(val value: String)\nval context = Context(\"context\")\nval result = context.apply {\n  println(value) // context\n  \"이값을리턴하지않는다\"\n}\nprintln(result) // Context(value=context)\n</code></pre>\n<ul>\n<li>람다에 아규먼트를 전달하지 않는다</li>\n<li>run()과 동일하게 컨텍스트 자체가 람다의 this로 바인딩된다</li>\n<li>그러나 run()과 다르게 람다의 리턴값을 무시하고 컨텍스트 객체를 apply() 메소드의 리턴값으로 가진다\n<ul>\n<li>람다의 리턴타입은 Unit이다</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4개의-메소드로-코드-정리하기\" style=\"position:relative;\"><a href=\"#4%EA%B0%9C%EC%9D%98-%EB%A9%94%EC%86%8C%EB%93%9C%EB%A1%9C-%EC%BD%94%EB%93%9C-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0\" aria-label=\"4개의 메소드로 코드 정리하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4개의 메소드로 코드 정리하기</h3>\n<ul>\n<li>타깃 객체를 유지하고 싶다면 apply()</li>\n<li>람다 표현식의 결과를 유지하고 싶다면 run()</li>\n<li>아규먼트로 전달한 람다의 결과를 사용하기를 원한다면 let()</li>\n<li>타깃 객체에 람다를 파라미터로 전달하고 람다의 결과값과 무관하게 타깃으로 다시 돌아가서 동작하도록 also()</li>\n</ul>\n<h1 id=\"암묵적-리시버\" style=\"position:relative;\"><a href=\"#%EC%95%94%EB%AC%B5%EC%A0%81-%EB%A6%AC%EC%8B%9C%EB%B2%84\" aria-label=\"암묵적 리시버 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>암묵적 리시버</h1>\n<h3 id=\"리시버-전달\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%8B%9C%EB%B2%84-%EC%A0%84%EB%8B%AC\" aria-label=\"리시버 전달 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리시버 전달</h3>\n<ul>\n<li><code>run(), apply()로 리시버(this)를 전달힌다</code>\n<ul>\n<li>js의 call, apply</li>\n<li><code>String.(Int) -> Unit</code>  String을 리시버로 명시하였다</li>\n<li>리시버 자체에서 변수를 찾을 수 없다면 컴파일러는 렉시컬스코프로 찾으러간다</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"멀티플-스코프\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0%ED%94%8C-%EC%8A%A4%EC%BD%94%ED%94%84\" aria-label=\"멀티플 스코프 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티플 스코프</h3>\n<ul>\n<li>람다 표현식이 다른 람다 표현식에 의해 중첩되는 경우\n<ul>\n<li>내부의 람다 표현식에는 멀티플 리시버를 가진 것처럼 보인다</li>\n<li><code>다이렉트 리시버와 부모의 리시버</code></li>\n<li>그러나 람다는 하나의 리시버만 가진다</li>\n<li>중첩되는 경우 멀티플 스코프를 가질 수 있으나 가장 가까운 리스너에서부터 찾아간다</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h1>\n<ul>\n<li>연산자 오버로딩</li>\n<li>함수, 프로퍼티, 연산자 확장</li>\n<li>중위표기법</li>\n<li>람다 암시적 리시버</li>\n<li>이 모든 것이 DSL을 위한 것이였다...</li>\n</ul>\n<h1 id=\"\" style=\"position:relative;\"><a href=\"#\" aria-label=\" permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🚨?!?!?</h1>\n<ul>\n<li></li>\n</ul>\n<hr>\n<h1 id=\"-더-알아보기\" style=\"position:relative;\"><a href=\"#-%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0\" aria-label=\" 더 알아보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🙈 더 알아보기</h1>\n<ul>\n<li><code>also(), apply(), let(), run()</code></li>\n</ul>","frontmatter":{"slug":"/blog/kotlin-study-ch12","date":"2021년 6월 2일","title":"연산자 오버로딩부터 함수 확장까지","subtitle":"Chapter 12 코틀린에서 구현하는 유창성","tags":["코틀린","스터디","kotlin"]}}},"pageContext":{"id":"b31b9705-ecc8-5c08-8f23-fe6e2448af91","frontmatter__slug":"/blog/kotlin-study-ch12","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["3000541721","3293771174"]}