{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/blog/kotlin-study-ch13/",
    "result": {"data":{"markdownRemark":{"html":"<pre><code class=\"language-markdown\">[참고 도서]\n- 다재다능 코틀린 프로그래밍\n</code></pre>\n<h1>DSL이란?</h1>\n<ul>\n<li>도메인 특화 언어</li>\n<li>CSS, 정규표현식, XML, Gradle, React JSX 모두 DSL...</li>\n<li>DSL로 생산성을 높이고 어플리케이션 구현 시간과 에러를 줄여준다\n<ul>\n<li>해당 도메인에 특화된거니깐!</li>\n</ul>\n</li>\n</ul>\n<h1>DSL의 타입과 특징</h1>\n<h3>외부 DSL vs 내부 DSL</h3>\n<ul>\n<li>외부 DSL\n<ul>\n<li>해당 DSL만의 세상에서 펼쳐지는 엄청난 자유도</li>\n<li>그러나 그들만의 세상을 내부적으로 가져오기 위한 <code>파싱 작업</code> 이 필요하다</li>\n<li>CSS, ANT 빌드파일...</li>\n</ul>\n</li>\n<li>내부 DSL\n<ul>\n<li>호스트 언어 컴파일러가 파싱해준다</li>\n<li>그러나 좀 더 다양한 기능을 위해 호스트 언어의 역할을 뛰어넘는 노력이 필요?!</li>\n<li>Gradle 빌드파일</li>\n</ul>\n</li>\n</ul>\n<h3>컨텍스트 주도와 유창성</h3>\n<ul>\n<li>DSL은 <code>context driven</code> 이고 <code>fluent</code> 이 높다\n<ul>\n<li>공통된 컨텍스트를 공유하고 있기 때문에 커뮤니케이션이 간결하고 명확하다</li>\n<li>그리고 같은 컨텍스트에 있기 때문에 암시적으로 범위가 적용되며 에러 가능성을 줄여준다</li>\n</ul>\n</li>\n<li><code>파라미터와 리시버</code>에 의해 컨텍스트를 관리한다</li>\n</ul>\n<h1>내부 DSL을 위한 코틀린</h1>\n<ul>\n<li>정적 타입인 코틀린이 DSL에서 한계를 뛰어넘기 위해 도와준 기능?!</li>\n</ul>\n<h3><strong>생략 가능한 세미콜론</strong></h3>\n<pre><code class=\"language-tsx\">starts.at(14);\n>>>\nstarts.at(14)\n</code></pre>\n<h3><strong>infix를 이용한 점과 괄호 제거</strong></h3>\n<pre><code class=\"language-tsx\">starts.at(14)\n>>>\nstarts at 14\n</code></pre>\n<h3><strong>확장함수를 이용한 도메인 특화</strong></h3>\n<pre><code class=\"language-tsx\">2.days(ago)\n>>>\n2 days ago\n</code></pre>\n<ul>\n<li>코틀린은 컴파일타임 함수 인젝션이 가능하다</li>\n<li><code>Int</code>에 <code>days</code> 함수를 확장해서 사용할 수 있다</li>\n</ul>\n<h3><strong>람다를 전달할 때 괄호는 필요없다</strong></h3>\n<pre><code class=\"language-tsx\">\"test\".meeting({\n\tstarts.at(14)\n})\n>>>\n\"test\" meeting {\n\tstarts at 14\n}\n</code></pre>\n<h3><strong>DSL 생성을 도와주는 암시적 리시버</strong></h3>\n<ul>\n<li>람다 표현식에 <code>암시적 리시버</code> 를 전달한다\n<ul>\n<li><code>리시버</code>는 코드의 <code>DSL 레이어 간에 컨텍스트 객체를 전달</code> 할 수 있는 방법이다</li>\n</ul>\n</li>\n<li>람다 표현식을 실행할 때, 컨텍스트를 옮겨주는 암시적 리시버가 숨어있다!\n<ul>\n<li>암시적 리시버가 파라미터를 전달하거나 전역상태를 사용할 필요 없이</li>\n<li>코드의 레이어 간에 프로세스를 진행 하기 위해 상태를 전달하는 것을 쉽게 만들어 준다</li>\n</ul>\n</li>\n</ul>\n<h3>DSL을 돕기 위한 추가 특징</h3>\n<ul>\n<li><code>Any 클래스의 메소드(apply, let, run, also)</code>로 DSL의 표현력과 기능성을 올려준다\n<ul>\n<li>람다를 실행시켜주고 암시적 리시버를 세팅해준다</li>\n</ul>\n</li>\n<li><code>this와 it</code>\n<ul>\n<li>현재 객체를 참조하기 위해서 <code>this</code> 를 이용한다</li>\n<li>람다 표현식의 단일 파라미터를 참조하기 위해 <code>it</code> 를 사용한다</li>\n</ul>\n</li>\n</ul>\n<h1>타입 세이프 빌더</h1>\n<ul>\n<li>정적타입언어를 사용하면 컴파일시점에 코드를 검증할 수 있다\n<ul>\n<li>런타임에 발생하게 될 에러를 미리 방지할 수 있다</li>\n<li>그러나 DSL로 허용되는 문법을 작성했는지 컴파일러가 확인할 수가 없다</li>\n</ul>\n</li>\n<li>DSL <code>검증을 위해 타입 세이프 빌더</code>가 필요하다\n<ul>\n<li>어노테이션을 사용해 컴파일러에게 속성이나 메소드의 스코프를 주시하도록 한다</li>\n</ul>\n</li>\n</ul>\n<h1>스코프 제어를 통한 접근 제한</h1>\n<ul>\n<li>내부 DSL은 호스트 언어에 탑승하는 이득이 있다\n<ul>\n<li>파서를 따로 구현하지 않아도 된다</li>\n<li>호스트 언어에서 할 수 있는 <code>스코프 속성 접근이나 임의의 함수와 메소드 호출</code> 은 DSL에서도 할 수 있다</li>\n</ul>\n</li>\n<li>오히려 이런 접근이 자유로운 것을 제한하고자 <code>스코프 컨트롤 어노테이션</code> 을 사용한다\n<ul>\n<li>DSL을 만들 때 현재 실행중인 암시적 리시버에만 접근이 가능하도록 제한하고 부모 리시버의 멤버에 접근하는 것을 제한해야 할 수 있다</li>\n<li><code>@DSLMarker</code> 라는 어노테이션을 사용해서 컴파일러가 중첩된 람다의 부모 리시버의 멤버에 암시적 접근을 거부하라고 요청 할 수 있다\n<ul>\n<li>js로 바꿔서 해보면 현재 객체에 없으면 부모로 올라가서 찾는 프로토타입 체인을 제한한다는 뜻?!</li>\n</ul>\n</li>\n<li><code>어노테이션으로 암시적 접근을 제한한 것이지 명시적으로 호출하는 것은 가능하다</code></li>\n</ul>\n</li>\n</ul>\n<h1>결론</h1>\n<ul>\n<li>코틀린은 람다를 실행할 때 컨텍스트 객체를 할당할 수 있다는 점이 다른 정적 타입 언어로 DSL을 만들었을때 한계를 해소시켜준다</li>\n<li>정적타입 언어이기 때문에 DSL을 사용할 때도 타입 안정성을 제공한다</li>\n<li>DSL 마커 어노테이션을 사용해서 자동으로 부모 리시버로 라우팅 되지 않고 현재 객체의 리시버로만 호출을 제한할 수 있다</li>\n</ul>\n<h1>🚨?!?!?</h1>\n<ul>\n<li>\n<p><strong>암시적 리시버</strong></p>\n<pre><code class=\"language-tsx\">placeOrder {\n\tan item \"연필\"\n\tan item \"지우개\"\n\tcomplete {\n\t\tthis with creditcard number \"1234\"\n\t}\n}\n</code></pre>\n<ul>\n<li>여기에 <code>결제</code>와 <code>주문</code> 컨텍스트가 존재한다는데... 어떻게 보는걸까?</li>\n</ul>\n</li>\n<li>\n<p><strong>infix + this + it</strong></p>\n<ul>\n<li><code>please add it to this cart now</code></li>\n<li>please.add(it to this.cart.now) 이건가..?</li>\n<li>please.add(it to this).cart(now) 이건가..?</li>\n<li>please.add(it to this).cart.now 이건가..?</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1>🙈 더 알아보기</h1>\n<ul>\n<li>DSL\n<ul>\n<li>DSL을 어떻게 어느 시점에 사용하게 될까?</li>\n<li>타입 세이프 빌더</li>\n</ul>\n</li>\n</ul>","frontmatter":{"slug":"/blog/kotlin-study-ch13","date":"2021년 6월 10일","title":"DSL이 대체 뭘까?"}}},"pageContext":{"id":"2e443f6a-2b9b-5609-b175-2d197b4ba74f","frontmatter__slug":"/blog/kotlin-study-ch13","__params":{"frontmatter__slug":"blog"}}},
    "staticQueryHashes": ["3000541721","3293771174"]}