{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/blog/kotlin-study-ch15/",
    "result": {"data":{"markdownRemark":{"html":"<pre><code class=\"language-markdown\">[참고 도서]\n- 다재다능 코틀린 프로그래밍\n</code></pre>\n<h1 id=\"코루틴\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%A3%A8%ED%8B%B4\" aria-label=\"코루틴 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코루틴?</h1>\n<ul>\n<li>논블로킹(실행하는데 시간이 걸리는 작업)을 위해서 코루틴을 사용한다\n<ul>\n<li>일시중단이 가능한 함수와 함께 사용한다</li>\n<li>중간에 실행/중단될 수 있다</li>\n<li>컨티뉴에이션은 추후 함수 호출을 이어하기 위해 함수의 내부 상태를 보호하는 데이터 구조이다</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"코루틴과-동시-실행\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%A3%A8%ED%8B%B4%EA%B3%BC-%EB%8F%99%EC%8B%9C-%EC%8B%A4%ED%96%89\" aria-label=\"코루틴과 동시 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코루틴과 동시 실행</h1>\n<h3 id=\"병렬-vs-동시성\" style=\"position:relative;\"><a href=\"#%EB%B3%91%EB%A0%AC-vs-%EB%8F%99%EC%8B%9C%EC%84%B1\" aria-label=\"병렬 vs 동시성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>병렬 vs 동시성</h3>\n<ul>\n<li>먹으면서 듣는 것 ⇒ 병렬</li>\n<li>먹으면서 말하는 것 ⇒ 동시성</li>\n<li>동시라는 말이 들어가 있어서 동시에 할 수 있는거 아니야? 하고 있는데...</li>\n</ul>\n<h3 id=\"코루틴-1\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%A3%A8%ED%8B%B4-1\" aria-label=\"코루틴 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코루틴</h3>\n<ul>\n<li>일반적으로 실행이 완료된 이후 반환되는 함수는 서브루틴이다\n<ul>\n<li>엔트리포인트가 1개이다</li>\n<li>서브루틴 호출 사이에서는 아무런 상태 관리를 하지 않는다</li>\n</ul>\n</li>\n<li><code>**코루틴**</code> 은 여러개의 엔트리포인트가 있다\n<ul>\n<li>호출 사이에 상태를 기억할 수 있다\n<ul>\n<li>호출 간 협력이 가능하다</li>\n<li>이전에 멈춘 지점부터 다시 시작한다</li>\n</ul>\n</li>\n<li>실행 플로우를 스위칭하며 동시에 실행한다 (A → B → A → B)</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"코루틴을-이용한-동시-실행\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%A3%A8%ED%8B%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8F%99%EC%8B%9C-%EC%8B%A4%ED%96%89\" aria-label=\"코루틴을 이용한 동시 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코루틴을 이용한 동시 실행</h1>\n<ul>\n<li>코루틴은 일급객체이다</li>\n<li>무한 시퀀스, 이벤트 루프, 협력함수에서 동시 실행을 위해 사용된다\n<ul>\n<li>순차실행/동시실행 + 같은 컨텍스트/다른 컨텍스트 조합</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-순차적으로-실행하기\" style=\"position:relative;\"><a href=\"#1-%EC%88%9C%EC%B0%A8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0\" aria-label=\"1 순차적으로 실행하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 순차적으로 실행하기</h3>\n<pre><code class=\"language-kotlin\">fun task1() { ... }\nfun task2() { ... }\n\nrun {\n\ttask1()\n\ttask2()\n\tprint(\"finish\")\n}\n</code></pre>\n<ul>\n<li>일반적인 함수 호출로 순차적으로 실행된다</li>\n</ul>\n<h3 id=\"2-코루틴으로-변경\" style=\"position:relative;\"><a href=\"#2-%EC%BD%94%EB%A3%A8%ED%8B%B4%EC%9C%BC%EB%A1%9C-%EB%B3%80%EA%B2%BD\" aria-label=\"2 코루틴으로 변경 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 코루틴으로 변경</h3>\n<pre><code class=\"language-kotlin\">import kotlinx.coroutines.*\n\nfun task1() { ... }\nfun task2() { ... }\n\nrunBlocking {\n\ttask1()\n\ttask2()\n\tprint(\"finish\")\n}\n</code></pre>\n<ul>\n<li>코루틴을 사용해 동시에 실행되도록 변경하였다\n<ul>\n<li><code>runBlocking</code> 함수가 전달받은 람다를 코루틴에서 실행해준다</li>\n<li>현재 코루틴이 1개만 동작하므로 순차적으로 실행하는 것과 동일하게 동작한다...</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-여러개의-코루틴으로-동시-실행\" style=\"position:relative;\"><a href=\"#3-%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EC%BD%94%EB%A3%A8%ED%8B%B4%EC%9C%BC%EB%A1%9C-%EB%8F%99%EC%8B%9C-%EC%8B%A4%ED%96%89\" aria-label=\"3 여러개의 코루틴으로 동시 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 여러개의 코루틴으로 동시 실행</h3>\n<pre><code class=\"language-kotlin\">runBlocking {\n\tlaunch { task1() }\n\tlaunch { task2() }\n\tprint(\"finish\")\n}\n</code></pre>\n<ul>\n<li><code>launch</code> 함수가 전달된 람다를 실행시키는 새로운 코루틴을 시작한다\n<ul>\n<li><code>setInterval</code> 이 반환하는 것처럼 <code>launch</code> 함수도 job을 반환해서 이후에 작업 취소를 요청할 수 있다</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-서스펜션-포인트와-인터리빙-호출\" style=\"position:relative;\"><a href=\"#4-%EC%84%9C%EC%8A%A4%ED%8E%9C%EC%85%98-%ED%8F%AC%EC%9D%B8%ED%8A%B8%EC%99%80-%EC%9D%B8%ED%84%B0%EB%A6%AC%EB%B9%99-%ED%98%B8%EC%B6%9C\" aria-label=\"4 서스펜션 포인트와 인터리빙 호출 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 서스펜션 포인트와 인터리빙 호출</h3>\n<ul>\n<li>서스펜션 포인트: 현재 실행중인 작업을 중지(suspend)하고 다른 작업을 실행시키는 함수 ⇒ <code>delay(), yield()</code>\n<ul>\n<li>delay와 yield로 대기중인 다른 작업을 실행할 기회를 준다</li>\n</ul>\n</li>\n<li><code>suspend</code> 키워드로 어노테이션된 함수에서 서스펜션 포인트를 사용할 수 있는데 <code>async-await</code> 처럼 <code>suspend-delay, suspend-yield</code> 로 사용해야한다</li>\n</ul>\n<pre><code class=\"language-kotlin\">suspend fun task1() {\n\tprint(1)\n\tyield()\n\tprint(3)\n}\nsuspend fun task2() {\n\tprint(2)\n\tyield()\n\tprint(4)\n}\n\nrunBlocking {\n\tlaunch { task1() }\n\tlaunch { task2() }\n\tprint(\"finish\")\n}\n</code></pre>\n<ul>\n<li><code>suspend-yield</code> 로 실행 흐름을 <code>task1 → task2 → task1 → task2</code> 넘겨주면서 실행하게 된다</li>\n<li>이런 코루틴을 언제 쓰게 될까?\n<ul>\n<li>공유자원을 경쟁하는 경우</li>\n<li>순차실행 보다 코루틴을 사용해 미리 호출해두고 작업이 완료되기 기다리는 동안 다른 작업을 실행할 수 있다</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"코루틴의-컨텍스트와-스레드\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%A3%A8%ED%8B%B4%EC%9D%98-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C\" aria-label=\"코루틴의 컨텍스트와 스레드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코루틴의 컨텍스트와 스레드</h1>\n<ul>\n<li>동일 스레드에서 코루틴을 호출해서 작업 흐름을 넘겨주더라도 결국 하나의 스레드에서 작업하는 것은 한계가...</li>\n<li>그렇다면 코루틴을 통해 실행 컨텍스트와 스레드를 원하는 곳을 이동하게 된다면?\n<ul>\n<li>좀 더 빠른 병렬적인 작업이 이뤄질 수 있겠다</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"컨텍스트-명시적-세팅\" style=\"position:relative;\"><a href=\"#%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EB%AA%85%EC%8B%9C%EC%A0%81-%EC%84%B8%ED%8C%85\" aria-label=\"컨텍스트 명시적 세팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컨텍스트 명시적 세팅</h3>\n<ul>\n<li>\n<p>코루틴이 실행될 컨텍스트를 <code>launch</code>와  <code>runBlocking</code> 함수에 전달해서 설정한다</p>\n<pre><code class=\"language-kotlin\">runBlocking {\n\tlaunch(Dispatchers.Default) { task1() }\n\tlaunch { task2() }\n\tprint(\"finish\")\n}\n\n// task1 => Thread[DefaultDispatchers-worker]\n// task2 => Thread[main]\n</code></pre>\n<ul>\n<li>명시적으로 코루틴이 실행될 컨텍스트를 전달해서 병렬/동시 실행을 할 수 있다</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"커스텀-풀에서-실행\" style=\"position:relative;\"><a href=\"#%EC%BB%A4%EC%8A%A4%ED%85%80-%ED%92%80%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89\" aria-label=\"커스텀 풀에서 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>커스텀 풀에서 실행</h3>\n<ul>\n<li>\n<p><code>싱글 스레드 풀</code> 에서 코루틴을 실행시키면 병렬이 아닌 동시 실행된다</p>\n<ul>\n<li>풀 안에 싱글 스레드가 있기 때문에</li>\n</ul>\n</li>\n<li>\n<p>싱글 스레드 실행자를 만들고 컨텍스트를 가져온다</p>\n<pre><code class=\"language-kotlin\">Executors.newSingleThreadExecutor().asCoroutineDispatcher().use { context ->\n  runBlocking {\n\t\tlaunch(context) { task1() }\n\t\tlaunch { task2() }\n\t\tprint(\"finish\")\n\t}\t\n}\n</code></pre>\n<ul>\n<li>싱글 스레드의 컨텍스트를 가져와서 실행</li>\n<li><code>use</code> 함수로 실행자를 자동 관리해줘서 닫히지 않아서 스레드 관리가 안되는 오류를 방지한다</li>\n<li><code>Executors.newSingleThreadExecutor</code> - 싱글 스레드 풀</li>\n<li><code>Executors.newFixedThreadPool</code> - 멀티 스레드 풀</li>\n</ul>\n</li>\n<li>\n<p>서스펜션 포인트 이후 스레드 스위칭이 필요한 경우</p>\n<ul>\n<li><code>launch</code> 파라미터로 전달</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"코루틴-디버깅\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%A3%A8%ED%8B%B4-%EB%94%94%EB%B2%84%EA%B9%85\" aria-label=\"코루틴 디버깅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코루틴 디버깅</h1>\n<ul>\n<li>\n<p><code>runBlocking</code> 와 <code>launch</code> 에 <code>CoroutineName()</code> 인스턴스를 전달하면 코루틴 이름을 할당할 수 있다</p>\n<pre><code class=\"language-kotlin\">runBlocking(CoroutineName(\"top\")) {\n\twithContext(Dispatchers.Default) { task1() }\n\tlaunch(Dispatchers.Default + CoroutineName(\"task\")) { task2() }\n\tprint(\"finish\")\n}\n</code></pre>\n<ul>\n<li><code>withContext</code> 로 현재 실행중인 코루틴 컨텍스트를 변경하였다</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"async-await\" style=\"position:relative;\"><a href=\"#async-await\" aria-label=\"async await permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>async-await</h1>\n<ul>\n<li>launch 가 setInterval처럼 job을 반환하기에 다른 결과값을 구할 수 없다\n<ul>\n<li>비동기 처리를 하고 결과를 받기 위해서는 async-await을 사용한다</li>\n</ul>\n</li>\n<li>async는 Deffered<T> 객체를 반환한다\n<ul>\n<li>코루틴 상태체크, 취소 등 작업을 할 수 있는 await를 반환한다</li>\n</ul>\n</li>\n<li>await은 스레드의 실행은 차단하지 않고 실행의 흐름 자체를 차단한다\n<ul>\n<li>코루틴의 결과를 리턴한다</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-kotlin\">runBlocking {\n\tval log: Deffered&#x3C;String> = async(Dispatchers.Default) {\n\t\t\"async\"\n\t}\n\n\tprint(\"finish\")\n\tprint(log.await())\n}\n</code></pre>\n<ul>\n<li>await 메소드를 호출하면 async에 의해서 실행된 코루틴이 완료되기를 기다리고 출력한다</li>\n</ul>\n<h1 id=\"연속성\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%86%8D%EC%84%B1\" aria-label=\"연속성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연속성</h1>\n<ul>\n<li>코루틴은 작업을 중단시키거나 스레드 변경을 할 수 있다\n<ul>\n<li>그렇다면 코루틴에서 사용되는 스레드 사이에 작업 상태를 전달해서 유지할 수 있을까? ⇒ <code>연속성</code></li>\n</ul>\n</li>\n<li>연속성을 사용해 한 스레드에서 실행 상태를 capture하고 preserve할 수 있다\n<ul>\n<li>상태가 필요한 다른 스레드에서 이를 불러올 수 있다</li>\n</ul>\n</li>\n<li>컴파일러가 코루틴 작업을 위해 Continuation을 사용한다\n<ul>\n<li>Continuation을 잘 사용하는 것이 핵심!</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"무한-시퀀스\" style=\"position:relative;\"><a href=\"#%EB%AC%B4%ED%95%9C-%EC%8B%9C%ED%80%80%EC%8A%A4\" aria-label=\"무한 시퀀스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>무한 시퀀스</h1>\n<h3 id=\"시퀀스\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%ED%80%80%EC%8A%A4\" aria-label=\"시퀀스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시퀀스?</h3>\n<ul>\n<li>listOf와 sequenceOf의 차이점으로 생겨난 반복 연산 퍼포먼스(Chapter 11 내부 반복과 지연연산)\n<ul>\n<li>콜렉션을 미리 만들 필요가 없기 때문에</li>\n<li>이미 생성된 값을 사용하면 되고</li>\n<li>lazy연산으로 값이 필요한 시점에 생성하기 때문에</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"시퀀스와-이터레이터\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%ED%80%80%EC%8A%A4%EC%99%80-%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%ED%84%B0\" aria-label=\"시퀀스와 이터레이터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시퀀스와 이터레이터</h3>\n<ul>\n<li>sequence와 iterator 함수를 사용해서 무한한 값을 생성하는 코루틴을 만들때 명확하게 해준다</li>\n</ul>\n<h1 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h1>\n<ul>\n<li>코루틴은 컨티뉴에이션의 개념을 기반으로 한다</li>\n<li>concurrency(동시성)과 다중 엔트리포인트를 가지고 있는 함수이다</li>\n<li>코루틴으로 호출된 함수들 사이에서 상태를 전달할 수 있다\n<ul>\n<li>상태를 전달하기 때문에 언제든 중단하고 그 중단된 포인트에서 다시 시작할 수 있다</li>\n</ul>\n</li>\n<li>스레드나 자원이 필요한 다른 지연되는 작업에 대해 제어의 흐름을 넘길 수 있다\n<ul>\n<li>코루틴이 실행되고 있는 스레드를 변경하거나</li>\n<li>async-await을 사용해 병렬로 실행하고 나중에 결과를 얻을 수 있다</li>\n</ul>\n</li>\n<li>무한 시퀀스와 바운드가 없는 콜렉션을 반복하는 이터레이터를 만들 수 있다</li>\n<li><code>코루틴 ⇒ 비동기 + 동시성</code></li>\n</ul>\n<h1 id=\"\" style=\"position:relative;\"><a href=\"#\" aria-label=\" permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🚨?!?!?</h1>\n<ul>\n<li>동시성\n<ul>\n<li>동시에 된다고?</li>\n<li>그럼 병렬과 다른게 뭘까</li>\n<li>순차, 동시, 병렬을 구분해보자</li>\n<li>순차는 말그대로 순서대로 하나씩 처리하는 것</li>\n<li>병렬은 각각 다른 스레드에서 각각 실행되는 병렬적인 상황으로 서로 공유되지 않고 평행한 상태\n<ul>\n<li>입과 귀로 먹으면서 듣는다</li>\n</ul>\n</li>\n<li>동시는 각각 다른 스레드에서 각각 실행되는 것은 병렬과 같지만 동시라는 같은 시점을 바라본다는 의미를 깊이 생각해본다\n<ul>\n<li>입으로 말하면서 먹는다</li>\n<li>먹는게 끝나고 나서 말하는 것은 순차 실행이다</li>\n<li>그러나 먹으면서 말하려면 먹는 중간에 말해야하는데 그럼 하려는 무언가를 왔다갔다 상태를 바꿔가면서 실행되어야하는 것</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"-더-알아보기\" style=\"position:relative;\"><a href=\"#-%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0\" aria-label=\" 더 알아보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🙈 더 알아보기</h1>\n<ul>\n<li><code>코루틴?</code>\n<ul>\n<li>코루틴을 사용해 다른 작업을 병렬적으로 처리하려고 한다고 해도 전체적인 소요시간은 동일한게 아닐까?</li>\n<li>A + B + C + D와 A + C + B + D는 같다</li>\n<li>만약 A와 C가 엄청난 연산을 필요로해서 작업시간이 오래걸린다면?</li>\n<li>코루틴을 사용해 A를 호출하고 연산하는 동안 C로 넘어가서 호출하고 연산하는 동안 B를 그리고 D를 호출하는 이런 방식이라면?</li>\n<li>A + B + C + D와 A + C + B + D는 다르다!?</li>\n<li><a href=\"https://aaronryu.github.io/2019/05/27/coroutine-and-thread/\">참고: 코루틴과 스레드 더 모르겠다...</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"slug":"/blog/kotlin-study-ch15","date":"2021년 6월 24일","title":"드디어 코틀린의 핵... 코루틴"}}},"pageContext":{"id":"a679c69e-e29c-5cdc-bb49-6923c980b72c","frontmatter__slug":"/blog/kotlin-study-ch15","__params":{"frontmatter__slug":"blog"}}},
    "staticQueryHashes": ["3000541721","3293771174"]}