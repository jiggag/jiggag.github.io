{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/blog/kotlin-study-ch2/",
    "result": {"data":{"markdownRemark":{"html":"<pre><code class=\"language-markdown\">[참고 도서]\n- 다재다능 코틀린 프로그래밍\n- 코틀린 인 액션\n</code></pre>\n<h1 id=\"간결한-코틀린\" style=\"position:relative;\"><a href=\"#%EA%B0%84%EA%B2%B0%ED%95%9C-%EC%BD%94%ED%8B%80%EB%A6%B0\" aria-label=\"간결한 코틀린 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>간결한 코틀린</h1>\n<h2 id=\"세미콜론-생략\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EB%AF%B8%EC%BD%9C%EB%A1%A0-%EC%83%9D%EB%9E%B5\" aria-label=\"세미콜론 생략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>세미콜론 생략</strong></h2>\n<ul>\n<li>간결함 극대화</li>\n<li>한 줄에 여러식을 작성하는 경우에는 세미콜론이 필요하다</li>\n</ul>\n<h2 id=\"변수-타입-생략\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EC%88%98-%ED%83%80%EC%9E%85-%EC%83%9D%EB%9E%B5\" aria-label=\"변수 타입 생략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>변수 타입 생략</strong></h2>\n<ul>\n<li>타입 추론을 이용해 변수의 타입 선언을 생략할 수 있다\n<ul>\n<li>함수나 메소드의 리턴 타입은 생략할 수 있다</li>\n<li>하지만 파라미터의 타입은 명시되어야한다</li>\n<li>만약 외부로 전달되는 목적의 함수인 경우 리턴 타입을 명시하여 전달한다</li>\n<li>추론이 가능한 것은 생략하고 적절한 네이밍을 통해 간결함을 높인다</li>\n</ul>\n</li>\n<li>컴파일 시점에 타입이 검증되어야 한다</li>\n<li>타입 추론으로 생략된 변수를 이후에 다른 타입으로 재할당 하려는 경우 컴파일 오류가 발생한다</li>\n</ul>\n<h2 id=\"클래스와-메소드-생략\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%83%9D%EB%9E%B5\" aria-label=\"클래스와 메소드 생략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>클래스와 메소드 생략</strong></h2>\n<ul>\n<li>\n<p>모든 코드가 클래스의 메소드로 작성하지 않아도 된다</p>\n<ul>\n<li>함수 단독으로도 동작한다</li>\n<li>코틀린 컴파일러에서 스크립트로 작성된 코드를 필요에 따라 클래스로 래핑한다</li>\n</ul>\n</li>\n<li>\n<p><strong><code>standalone.kts</code></strong></p>\n<pre><code class=\"language-kotlin\">fun alone() {\n\tprintln(\"단독 호출되는 함수\")\n\tthrow RuntimeException(\"에러\")\n}\nprintln(\"클래스 없는 스크립트\")\ntry {\n\talone()\n} catch (ex: Exception) {\n\tval stackTrace = ex.getStackTrace()\n\tprintln(stackTrace[0])\n\tprintln(stackTrace[1])\n}\n\n>>> 클래스 없는 스크립트\n>>> 단독 호출되는 함수\n>>> Standalone.alone(standalone.kts:3)\n>>> Standalone.&#x3C;init>(standalone.kts:7)\n</code></pre>\n<ol>\n<li>클래스 없이 단독 함수로만 구성된 스크립트를 실행</li>\n<li>가장 외부에 단독으로 호출된 <code>클래스 없는 스크립트</code> 출력</li>\n<li>try-catch 안에서 <strong><code>alone</code></strong> 함수 호출 <code>단독 호출되는 함수</code> 출력</li>\n<li>단독 호출된 함수에서 에러 발생하였으나 해당 함수에서 에러 처리가 되어있지 않아 해당 함수를 호출한 상위로 올라가 try-catch에서 스택 프레임 출력</li>\n<li>출력된 스택에는 <strong><code>Standalone</code></strong> 라는 클래스로 감싸져 있는 것을 확인</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"try-catch는-선택사항\" style=\"position:relative;\"><a href=\"#try-catch%EB%8A%94-%EC%84%A0%ED%83%9D%EC%82%AC%ED%95%AD\" aria-label=\"try catch는 선택사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>try-catch는 선택사항</strong></h2>\n<ul>\n<li>위의 예시에서 보았듯 <strong><code>try-catch</code></strong> 로 감싸져있지 않은 곳에서 에러가 발생한 경우 해당 함수를 호출한 상위 코드로 전달되어 에러 처리를 하게 된다</li>\n<li>어느 곳에서도 에러를 처리하고 있지 않으면 프로그램이 종료된다</li>\n</ul>\n<h1 id=\"잠재적-오류-예방\" style=\"position:relative;\"><a href=\"#%EC%9E%A0%EC%9E%AC%EC%A0%81-%EC%98%A4%EB%A5%98-%EC%98%88%EB%B0%A9\" aria-label=\"잠재적 오류 예방 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>잠재적 오류 예방</h1>\n<ul>\n<li>경고를 오류처럼 설정하여 잠재적으로 발생할 수 있는 오류를 예방한다\n<ul>\n<li><code>경고를 오류처럼 다루는 것이 올바른 소프트웨어 개발 습관이다</code> - 애자일 프랙티스</li>\n</ul>\n</li>\n<li>ex. 코틀린 컴파일러는 사용하지 않는 파라미터에 대해 경고를 발생시킨다\n<ul>\n<li>\n<p><strong><code>unused.kts</code></strong></p>\n<pre><code class=\"language-kotlin\">fun compute(n: Int) = 0\nprintln(compute(4))\n\n>>> 0\n>>> unused.kts:1:13: warning: parameter 'n' is never used\n>>> fun compute(n: Int) = 0\n>>>             ^\n</code></pre>\n</li>\n<li>\n<p>컴파일 옵션으로 <strong><code>-Werror</code></strong> 를 전달하여 이런 경고를 오류처럼 처리할 수 있다</p>\n<ul>\n<li>\n<p>빌드와 실행을 실패시키고 오류 메세지를 전달한다</p>\n</li>\n<li>\n<p><strong><code>kotlinc-jvm -Werror -script unused.kts</code></strong></p>\n<pre><code class=\"language-kotlin\">>>> warning: parameter 'n' is never used (unused.kts:1:13)\n>>> error: warnings found and -Werror specified\n>>> unused.kts:1:13: warning: parameter 'n' is never used\n>>> fun compute(n: Int) = 0\n>>>             ^\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>단, <code>main()</code> 함수에 대헤서는 파라미터 미사용 경고를 출력하지 않는다</p>\n</li>\n</ul>\n</li>\n<li>사용하지 않는 파라미터에 대한 경고를 예시로 들었지만 경고를 오류 메세지로 바꾸는 옵션을 이용해 컴파일러가 알려주는 경고를 사전에 수정하여 잠재적으로 오류가 될 수 있는 것들을 수정하도록 한다</li>\n</ul>\n<h1 id=\"불변성\" style=\"position:relative;\"><a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1\" aria-label=\"불변성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>불변성</strong></h1>\n<h2 id=\"var보다는-val\" style=\"position:relative;\"><a href=\"#var%EB%B3%B4%EB%8B%A4%EB%8A%94-val\" aria-label=\"var보다는 val permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>var보다는 val</strong></h2>\n<ul>\n<li><strong>var</strong>\n<ul>\n<li>javascript → let</li>\n<li>변수의 값을 변경할 수 있지만 한번 고정된 타입은 변경할 수 없다</li>\n<li>컴파일 단계에서 초기화된 값으로 타입을 추론하는데 변경된 값의 타입이 다르면 컴파일 오류가 발생한다</li>\n<li>변환 함수를 써서 값을 변수의 타입으로 변환하거나 값을 변수에 대입할 수 있는 타입으로 강제 형 변환이 필요하다</li>\n</ul>\n</li>\n<li><strong>val</strong>\n<ul>\n<li>javascript → const</li>\n<li>재할당 불가능</li>\n<li>변수나 참조를 상수화한 것으로 객체의 참조만 불변성을 보장\n<ul>\n<li>객체 내부를 변경하게 되면 val의 값도 변경된다</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>의도와 다르게 코드가 변경되는 것으로부터 방지할 수 있고 추론을 쉽게 하고 오류 발생을 낮추고자 Immutable을 사용한다</li>\n</ul>\n<h1 id=\"동일성-체크\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%9D%BC%EC%84%B1-%EC%B2%B4%ED%81%AC\" aria-label=\"동일성 체크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동일성 체크</h1>\n<ul>\n<li>\n<p><strong>값 비교 <code>==</code></strong></p>\n<ul>\n<li>구조상의 동일성 체크 (structural equality)</li>\n<li>java → <code>equals()</code></li>\n<li>javascript → <code>==</code></li>\n</ul>\n</li>\n<li>\n<p><strong>참조 비교 <code>===</code></strong></p>\n<ul>\n<li>참조상의 동일성 체크 (referential equality)</li>\n<li>java → <code>==</code></li>\n<li>javascript → <code>===</code></li>\n</ul>\n</li>\n<li>\n<p>값을 비교한다는 것은 java의 <code>equals</code>과 kotlin의 <code>==</code>이 동일하지만 코틀린의 철학 중 하나인 <code>안정성</code> 으로 <code>NullPointerException</code>을 미리 잡아내기 위해 값을 비교하는 순간에도 null을 비교하여 안정적으로 반환한다</p>\n<pre><code class=\"language-kotlin\">// java\n\"hi\".equals(\"hi\") >>> true\n\"hi\".equals(\"Hi\") >>> false\n\"hi\".equals(null) >>> false\nnull.equals(null) >>> error: &#x3C;null> cannot be dereferenced\n\n// kotlin\n\"hi\" == \"hi\" >>> true\n\"hi\" == \"Hi\" >>> false\n\"hi\" == null >>> false\nnull == null >>> true\n</code></pre>\n<ol>\n<li>java equals로 값을 비교하면 null에는 문자열 비교하는 equals를 갖고 있지 않으므로 <code>NullPointerException</code> 이 발생한다</li>\n<li>코틀린에서는 null 자체를 값으로 비교하여 에러를 반환하기보다 안정적으로 값을 비교하여 반환한다\n<ul>\n<li>코틀린 내부적으로 == 값 비교를 하면 null을 먼저 체크하고 equals를 실행한다</li>\n</ul>\n</li>\n<li>또한 null이라는 값을 비교하면 항상 동일한 결과값을 반환할 것이라 예상되기에 경고로 해당 내용을 알려주며 코드의 간결함을 유지할 수 있도록 제안한다</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"문자열-표현\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%91%9C%ED%98%84\" aria-label=\"문자열 표현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문자열 표현</h1>\n<h2 id=\"문자열-템플릿\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%85%9C%ED%94%8C%EB%A6%BF\" aria-label=\"문자열 템플릿 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문자열 템플릿</h2>\n<ul>\n<li>\n<p><strong><code>$</code></strong> 을 사용해 문자열을 만들때 간결하게 표현할 수 있도록 한다</p>\n<pre><code class=\"language-kotlin\">// java\nString name = \"코틀린\";\nint age = 10;\nString message = \"저의 이름은 \" + name + \"이고 나이는 \" + age + \"입니다.\";\n\n>>> 저의 이름은 코틀린이고 나이는 10입니다.\n\n// kotlin\nval name = \"코틀린\"\nval age = 10\nval price = 99\nval message = \"저의 이름은 $name 이고 나이는 ${age}입니다. 환율이 $${price}이고 \\$은 그냥 써봅니다\"\n\n>>> 저의 이름은 코틀린 이고 나이는 10입니다. 환율이 $99이고 $은 그냥 써봅니다\n</code></pre>\n<ul>\n<li>java에서는 문자열을 나열하기 위해 <code>+</code> 를 사용한다</li>\n<li>코틀린에서는 <code>${변수}</code> 형태로 문자열 안에 작성해서 표현한다\n<ul>\n<li><code>$변수</code> 로 사용할 수 있으나 변수 바로 뒤에 다른 문자가 붙는 경우 구분이 되지 않는다</li>\n<li><code>\\$</code> 로 표현하면 <code>$</code> 자체를 문자로 표현해준다</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>문자열이 만들어지는 시점의 변수를 바인딩한다</p>\n<pre><code class=\"language-kotlin\">var factor = 2\nfun doubleIt(n: Int) = n * factor\nvar message = \"factor = $factor\"\nfactor = 0\nprintln(doubleIt(2))\nprintln(message)\n\n>>> 0\n>>> factor = 2\n</code></pre>\n<ol>\n<li>factor에 처음에는 2로 할당되어 있었으나 이후에 0으로 재할당 되어버렸다</li>\n<li>doubleIt 함수를 실행하는 시점은 println에서 호출하는 시점으로 이 순간에 factor가 바인딩되어 0이 출력되었다</li>\n<li>message는 println에서 호출하는 시점이 아니라 message라는 변수가 만들어진 순간이므로 factor가 2가 출력된다</li>\n</ol>\n<ul>\n<li>이처럼 문자열이 만들어지는 순간의 값을 다 알고 있어야 한다면 코틀린의 간결함이 복잡해지기에 var보다는 val를 사용하길 권한다</li>\n<li>컴파일 시점에 각 식을 정적으로 검사하기 때문에 존재하지 않는 변수를 문자열 템플릿 안에서 사용하면 컴파일 오류가 발생한다</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"raw-문자열\" style=\"position:relative;\"><a href=\"#raw-%EB%AC%B8%EC%9E%90%EC%97%B4\" aria-label=\"raw 문자열 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RAW 문자열</h2>\n<ul>\n<li>\n<p><code>$</code>를 쓰고 <code>$</code>를 표현하기 위해 <code>\\$</code>, <code>\"</code> 로 작성된 문자열 안에 <code>\"</code> 를 표현하기 위해 <code>\\\"</code> ...</p>\n</li>\n<li>\n<p>점점 복잡해지는 문자열을 간결하게 표현하기 위해 <code>\"\"\"</code> raw 문자열을 사용한다</p>\n<pre><code class=\"language-kotlin\">val name = \"코틀린\"\nval memo = \"\"\"[여러줄을 한번에 표현]\n저의 이름은 \"$name\"입니다\n\"\"\"\n\n>>>\n[여러줄을 한번에 표현]\n저의 이름은 \"코틀린\"입니다\n\nfun createMemo(): String {\n\tval name = \"코틀린\"\n\tval memo = \"\"\"[여러줄을 한번에 표현]\n\t저의 이름은 \"$name\"입니다\n\t\"\"\"\n\t\n\treturn memo\n}\nprintln(createMemo())\n\n>>>\n[여러줄을 한번에 표현]\n\t저의 이름은 \"코틀린\"입니다\n\nfun createMemoTrim(): String {\n\tval name = \"코틀린\"\n\tval memo = \"\"\"[여러줄을 한번에 표현]\n\t|저의 이름은 \"$name\"입니다\n\t\"\"\"\n\t\n\treturn memo.trimMargin()\n}\nprintln(createMemoTrim())\n\n>>>\n[여러줄을 한번에 표현]\n저의 이름은 \"코틀린\"입니다\n</code></pre>\n<ul>\n<li>함수 안에 존재하는 raw 문자열을 출력하면 함수의 탭 만큼 출력된 문자 앞에 들여쓰기가 포함되어있다\n<ul>\n<li>문자열 앞에 들여쓰기를 잘라내기 위해 raw 문자열 라인 앞에 <code>|</code> 를 추가해주고 반환하는 문자열에 <code>trimMargin()</code> 을 사용한다</li>\n<li>문자열 라인 앞에 들여쓰기를 잘라내는 구분자로 <code>trimMargin</code> 의 파라미터로 주게 된다\n<ul>\n<li><code>trimMargin(\":\")</code> 하게 되면 raw문자열 앞에 <code>:</code> 로 시작하는 라인의 들여쓰기를 잘라낸다</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"명령문-보다는-표현식\" style=\"position:relative;\"><a href=\"#%EB%AA%85%EB%A0%B9%EB%AC%B8-%EB%B3%B4%EB%8B%A4%EB%8A%94-%ED%91%9C%ED%98%84%EC%8B%9D\" aria-label=\"명령문 보다는 표현식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>명령문 보다는 표현식</h1>\n<ul>\n<li><strong>명령문 statement</strong>\n<ul>\n<li>java, javascript, c#</li>\n<li>try-catch, if, for문</li>\n<li>아무것도 리턴하지 않으며 상태, 변수를 업데이트하는 등 side-effect이 존재한다</li>\n<li>자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하여 값을 만들어내지 않는다</li>\n</ul>\n</li>\n<li><strong>표현식 expression</strong>\n<ul>\n<li>ruby, groovy</li>\n<li>결과를 리턴하고 어떠한 상태도 업데이트 하지 않는다</li>\n<li>값을 만들어 내며 다른 식의 하위 요소로 계산되어 참여할 수 있다</li>\n</ul>\n</li>\n<li>코틀린에서는 루프를 제외한 대부분의 제어 구조가 표현식으로 구성되어 있다</li>\n</ul>\n<h2 id=\"if\" style=\"position:relative;\"><a href=\"#if\" aria-label=\"if permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>if</strong></h2>\n<ul>\n<li>if를 코틀린에서는 표현식으로 나타날 수 있다 (if문이라고 하면 안되려나...)\n<pre><code class=\"language-kotlin\">// 자바 명령문 형태로 작성된 함수\nfun statementFunc(name: String, price: Int): String {\n    var status: String\n    if (price >= 500) {\n        status = \"500원 이상이에요\"\n    } else {\n        status = \"500원 미만이에요\"\n    }\n    return \"$name, $status\"\n}\nprintln(statementFunc(\"바나나\", 400))\n\n>>> 바나나, 500원 미만이에요\n\n// 코틀린 표현식 형태로 작성된 함수\nfun expressionFunc(name: String, price: Int): String {\n    val status = if (price >= 500) \"500원 이상이에요\" else \"500원 미만이에요\"\n    return \"$name, $status\"\n}\n</code></pre>\n<ol>\n<li><code>명령문</code>으로 작성된 statementFunc에서 새로운 결과를 반환하기 위해 <code>mutable 변수 var status</code>를 만들어서 수정하였다</li>\n<li>코틀린의 if는 <code>표현식</code>으로 나타낼 수 있기에 var를 사용하지 않고 <code>val를 사용하여 immutable</code> 하게 status 값을 반환하였고 <code>타입 추론</code>이 가능하게 되었다</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"try-catch\" style=\"position:relative;\"><a href=\"#try-catch\" aria-label=\"try catch permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>try-catch</strong></h2>\n<ul>\n<li>\n<p>코틀린의 try-catch는 표현식으로 취급된다</p>\n</li>\n<li>\n<p>예외가 발생하지 않으면 try의 마지막 코드가 결과로 반환된다</p>\n</li>\n<li>\n<p>예외가 발생한다면 catch의 마지막 코드가 결과로 반환된다</p>\n<pre><code class=\"language-kotlin\">fun expressionTry(blowup: Boolean): Int {\n\treturn try {\n\t\tif (blowup) {\n\t\t\tthrow RuntimeException(\"fail\")\n\t\t}\n\t\t2\n\t} catch (ex: Exception) {\n\t\t4\n\t} finally {\n\t\tprintln(\"finally $blowup\")\n\t}\n}\nprintln(expressionTry(true))\n>>>\nfinally true\n4\n\nprintln(expressionTry(false))\n>>>\nfinally false\n2\n</code></pre>\n<ol>\n<li>blowup 값에 따라 오류를 던졌고 try문의 결과값이 아니라 catch문의 결과값 4가 반환되었다</li>\n<li>finally가 try-catch가 완료되고 난 뒤 마지막에 실행될 것이라 기대했는데 먼저 출력되었다</li>\n<li>이것은 expressionTry 함수 자체의 반환값이 4인 것이고 그 안에서 동작한 try-catch-finally에서 출력된 finally가 먼저 나온것이다</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h1>\n<ul>\n<li>코틀린은 정말 간결함을 추구한다</li>\n<li>코드 작성을 최소화하기 위해 생략 가능한 것들을 모두 생략해도 되도록 지원한다\n<ul>\n<li>세미콜론, 타입, 클래스, 예외 처리</li>\n</ul>\n</li>\n<li>문자열을 표현하는 방법을 최선으로 간결하게 만들었다</li>\n<li>명령문보다는 표현식을 사용하여 불변성을 유지하며 안정성을 높인다</li>\n</ul>\n<h1 id=\"\" style=\"position:relative;\"><a href=\"#\" aria-label=\" permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🚨?!?!?</h1>\n<ul>\n<li>\n<p><strong>모든 곳에서 에러 처리를 하지 않아도 상위로 전파된다면?</strong></p>\n<ul>\n<li>리액트의 ErrorBoundary처럼 가장 상위 코드에서 한번 에러 처리를 해두면 모든 에러를 일괄적으로 처리 가능한 것일까?</li>\n</ul>\n</li>\n<li>\n<p><strong>문자열 템플릿으로 작성한 변수 뒤에 바로 붙어있는 문자는 어디까지 인식할까?</strong></p>\n<pre><code class=\"language-kotlin\">val name = \"이름\"\nprintln(\"$name, 이런 형태\") >>> 이름, 이런 형태\nprintln(\"$name. 이런 형태\") >>> 이름. 이런 형태\nprintln(\"$name; 이런 형태\") >>> 이름; 이런 형태\n\nprintln(\"$name은 이런 형태\") >>> error: unresolved reference: name은\n</code></pre>\n<ul>\n<li><code>,.;</code> 는 잘 나오지만 한글, 영어, 숫자가 붙어있는 경우에는 템플릿 변수명으로 인식하여 오류가 발생한다</li>\n<li>글자로 분류할 수 있는 유니코드 문자를 식별자로 사용하기 때문에 해당 오류가 발생한다</li>\n<li>모든 문자열 템플릿을 <code>${}</code> 로 감싸서 사용하는 것이 검색이나 코드 관리에 효율적이라 권장된다</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"-더-알아보기\" style=\"position:relative;\"><a href=\"#-%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0\" aria-label=\" 더 알아보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🙈 더 알아보기</h1>\n<ul>\n<li>위임 Delegate\n<ul>\n<li>\n<p>변수 할당된 a, b, c를 표현식으로 취급되지 않는 이유?</p>\n<pre><code class=\"language-kotlin\">var a = 1\nvar b = 2\nvar c = 3\n\na = b = c >>> 오류\n</code></pre>\n<ul>\n<li>코틀린은 위임을 통해 변수를 get, set 하고 있다</li>\n<li>대입 연산자인 = 로 표현식을 다룬다면 할당 연산을 예상할 수 없어 오류가 발생한다</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>대입문과 비교문\n<ul>\n<li>대입문이 자바에서는 표현식이였으나 코틀린에서는 명령문이다</li>\n<li>자바에서와 다르게 코틀린에서는 대입문과 비교문을 반대로 작성하게 되는 버그가 없다고 한다 -> 잘 모르겠다...</li>\n</ul>\n</li>\n</ul>","frontmatter":{"slug":"/blog/kotlin-study-ch2","date":"2021년 3월 28일","title":"코틀린은 간결함을 표현한다"}}},"pageContext":{"id":"95adaa69-176c-5081-9641-030609d16d6a","frontmatter__slug":"/blog/kotlin-study-ch2","__params":{"frontmatter__slug":"blog"}}},
    "staticQueryHashes": ["3000541721","3293771174"]}