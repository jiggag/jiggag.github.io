{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/blog/kotlin-study-ch4/",
    "result": {"data":{"markdownRemark":{"html":"<pre><code class=\"language-markdown\">[참고 도서]\n- 다재다능 코틀린 프로그래밍\n</code></pre>\n<h1>범위와 반복</h1>\n<ul>\n<li>명령형 스타일의 외부 반복자과 함수형 스타일의 내부 반복자가 있다\n<ul>\n<li>for i++, i—와 같은 시퀀스를 명시적으로 제어하는 외부 반복자</li>\n<li>람다처럼 내부 로직에만 집중하고 시퀀스는 대신 제어해주는 내부 반복자</li>\n</ul>\n</li>\n</ul>\n<h2>레인지 클래스</h2>\n<pre><code class=\"language-kotlin\">val oneToFive: IntRange = 1..5\nvar aToE: CharRange = 'a'..'e'\nval seekHelp: ClosedRange&#x3C;String> = \"hell\"..\"help\"\n</code></pre>\n<ul>\n<li><code>..</code> 으로 범위를 지정하고 앞뒤 값을 모두 포함한다 (1 ≤ i ≤ 5)</li>\n<li><code>kotlin.ranges</code> 패키지의 타입으로 해당 범위 타입을 명확하게 한다\n<ul>\n<li>타입 추론을 통해 유추 가능</li>\n<li>int, char 원시타입 뿐만 아니라 String으로 범위 설정 가능</li>\n</ul>\n</li>\n</ul>\n<h2>정방향 반복</h2>\n<pre><code class=\"language-kotlin\">for (i in 1..5) { print(i) } // 12345\nfor (c in 'a'..'e') { print(c) } // abcde\n\n// 오류 발생\nfor (word in \"hell\"..\"help\") { print(word) }\n>>> For-loop range must have an 'iterator()' method\n</code></pre>\n<ul>\n<li>증가하는 반복</li>\n<li>i는 val로 선언되며 반복문 안에서 변경이 불가능하다</li>\n<li>스코프는 반복문 안으로 제한되어 있다</li>\n<li><code>IntRange</code> 나 <code>CharRange</code> 에는 <code>iterator()</code> 가 있지만 <code>ClosedRange&#x3C;T></code> 에는 iterator()가 없어서 오류가 발생한다\n<ul>\n<li><code>ch 12-2 서드파티 클래스 인젝팅</code> 에서 <code>ClosedRange&#x3C;T></code> 를 반복하는 확장하는 함수로 만들게 된다...</li>\n</ul>\n</li>\n</ul>\n<h2>후방향 반복</h2>\n<pre><code class=\"language-kotlin\">for (i in 5.downTo(1)) { print(i) } // 54321\nfor (i in 5 downTo 1) { print(i) } // 중위표기법으로 . 생략\n</code></pre>\n<ul>\n<li>정방향과 반대로 감소하는 반복\n<ul>\n<li>\n<p><code>for (i in 5..1)</code> 로는 동작하지 않는다</p>\n</li>\n<li>\n<p>감소하는 반복을 위해 <code>IntProgression</code> 인스턴스를 만들어주는 <code>downTo()</code> 메소드를 호출한다</p>\n<pre><code class=\"language-kotlin\">public infix fun Int.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this, to, -1)\n}\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2>범위 안의 값 건너뛰기</h2>\n<pre><code class=\"language-kotlin\">// 1 &#x3C;= i &#x3C;= 5\nfor (i in 1..5) >>> 12345\n\n// 1 &#x3C;= i &#x3C; 5\nfor (i in 1 until 5) >>> 1234\n\n// 1 &#x3C;= i &#x3C; 5, 2씩 증가\nfor (i in 1 until 5 step 2) >>> 13\n\n// 1 &#x3C;= i &#x3C;= 9, 3이나 5의 배수\nfor (i in (1..9).filter { it % 3 == 0 || it % 5 == 0 })\n</code></pre>\n<ul>\n<li>일반적인 범위로는 앞뒤 값을 모두 포함하는 범위를 갖는다</li>\n<li><code>until()</code> - 마지막 값을 포함하지 않는 범위를 만들어낸다</li>\n<li><code>step()</code> - 특정 값을 건너뛰면서 반복하며 <code>IntProgression</code> 객체이다</li>\n<li><code>filter()</code> - 해당 범위의 값을 람다표현식으로 인자를 전달받아 해당 조건에 맞는 경우에만 반환한다</li>\n</ul>\n<h1>배열과 리스트의 반복</h1>\n<h2>배열</h2>\n<pre><code class=\"language-kotlin\">val array = arrayOf(1, 2, 3) // 반환타입: Array&#x3C;Int>\nval intArray = intArrayOf(1, 2, 3) // 반환타입: IntArray\n</code></pre>\n<ul>\n<li><code>for (i in array) { print(i) }</code> 형태로 배열을 반복한다</li>\n<li><strong>Array<Int></strong>\n<ul>\n<li>arrayOf에서 사용한 값이 <code>Int 타입의 정수 객체로 정수형 배열</code> 이 생성되었다</li>\n</ul>\n</li>\n<li><strong>IntArray</strong>\n<ul>\n<li>정수 객체가 아닌 <code>원시 자료형 Int의 배열</code>을 생성하기 위해서는 intArrayOf()를 사용한다</li>\n</ul>\n</li>\n</ul>\n<h2>리스트</h2>\n<pre><code class=\"language-kotlin\">var list = listOf(1, 2, 3) // 반환타입: List&#x3C;Int>\nprint(list.javaClass) // java.util.Arrays$ArrayList\nfor (i in list) { print(i) } // 123\n\n// 인덱스 추출\nfor (index in list.indices) { print(index) } // 012\nfor ((index, value) in list.withIndex()) { print(\"index: $index, value: $value\") } // 012\n</code></pre>\n<ul>\n<li>array와 유사하게 동작\n<ul>\n<li>List<T> 형태로 intListOf는 없다...</li>\n</ul>\n</li>\n<li>리스트의 <code>indices</code> 속성으로 리스트의 index를 가져올 수 있으며 <code>withIndex()</code> 함수로 구조분해된 형태로 index와 value를 가져올 수 있다</li>\n</ul>\n<h1>코틀린의 when</h1>\n<ul>\n<li>코틀린에서는 switch 대신 when을 사용한다</li>\n<li>표현식과 명령문으로 사용할 수 있다</li>\n<li>if-else로 구성된 내부 로직이나 switch로 조건 분기를 하는 경우 when으로 대체 한다</li>\n</ul>\n<h2>표현식 when</h2>\n<pre><code class=\"language-kotlin\">fun isAlive(alive: Boolean, numberOfLiveNeighbors: Int) = when {\n  numberOfLiveNeighbors &#x3C; 2 -> false\n  numberOfLiveNeighbors &#x3C; 5 -> false\n  numberOfLiveNeighbors == 5 -> true\n  else -> alive &#x26;&#x26; numberOfLiveNeighbors > 10\n}\n\nprint(isAlive(true, 1)) // false\nprint(isAlive(true, 2)) // false\nprint(isAlive(true, 5)) // true\nprint(isAlive(true, 8)) // false\nprint(isAlive(false, 12)) // false\nprint(isAlive(true, 12)) // false\n</code></pre>\n<ul>\n<li>블록으로 작성하여 리턴타입이 추론되게 한다</li>\n<li>단일 표현식으로 when에서 리턴되는 값이 함수의 리턴값이다</li>\n<li>코틀린 컴파일러는 when에서 <code>else가 있는지, 표현식으로 조건을 구분할 수 있는 모든 케이스</code>에 대해 검증한다\n<ul>\n<li>컴파일 시간 체크는 코드의 정확성과 실수 오류를 줄여준다</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-kotlin\">fun whatTodo(dayOfWeek: Any) = when (dayOfWeek) {\n  is Int -> \"int???\"\n  \"월\", \"화\", \"수\" -> \"스터디\"\n  in listOf(\"토\", \"일\") -> \"운동\"\n  in arrayOf(\"목\", \"금\") -> \"휴식\"\n  else -> \"다시\"\n}\nprint(whatTodo(1)) // int???\nprint(whatTodo(\"화\")) // 스터디\nprint(whatTodo(\"일\")) // 운동\nprint(whatTodo(\"금\")) // 휴식\nprint(whatTodo(\"월화\")) // 다시\n</code></pre>\n<ul>\n<li>when에 변수를 전달하는 경우 when 조건 구문이 Boolean이 아니라 각각의 값들에 맞는 조건을 사용한다\n<ul>\n<li>해당 파라미터가 조건에 맞는지 확인 후 반환한다</li>\n</ul>\n</li>\n</ul>\n<h2>명령문 when</h2>\n<pre><code class=\"language-kotlin\">fun whatTodo(dayOfWeek: Any) {\n  when (dayOfWeek) {\n    is Int -> print(\"int???\")\n    \"월\", \"화\", \"수\" -> print(\"스터디\")\n    in listOf(\"토\", \"일\") -> print(\"운동\")\n    in arrayOf(\"목\", \"금\") -> print(\"휴식\")\n  }\n}\nwhatTodo(1) // int???\nwhatTodo(\"화\") // 스터디\nwhatTodo(\"일\") // 운동\nwhatTodo(\"금\") // 휴식\nwhatTodo(\"월화\") //\n</code></pre>\n<ul>\n<li>하나 이상의 값에 기반해서 다른 동작을 원하는 경우 명령문 when을 사용한다\n<ul>\n<li>특정 값을 리턴하는 것이 아니라 조건에 따라 어떤 행동만을 하게 된다</li>\n<li>명령문으로 사용되는 when에서는 else가 존재하지 않아도 된다</li>\n<li>조건에 맞는 내용이 없으면 아무런 행동도 취하지 않게 된다</li>\n</ul>\n</li>\n</ul>\n<h2>when에서의 변수 스코프</h2>\n<pre><code class=\"language-kotlin\">fun systemInfo(): String {\n\t// 해당 라인에서 경고 메세지가 뜬다\n\t// Variable declaration could be moved into `when`\n  val numberOfCores = Runtime.getRuntime().availableProcessors()\n  return when (numberOfCores) {\n    1 -> \"1 core\"\n    in 2..16 -> \"2 ~ 16 cores\"\n    else -> \"$numberOfCores cores???\"\n  }\n}\n\n// when 인자로 변수 스코프를 제한하도록 수정\nfun systemInfo(): String {\n  return when (val numberOfCores = Runtime.getRuntime().availableProcessors()) {\n    1 -> \"1 core\"\n    in 2..16 -> \"2 ~ 16 cores\"\n    else -> \"$numberOfCores cores???\"\n  }\n}\n</code></pre>\n<ul>\n<li>when 내부에서만 사용하는 변수의 스코프를 제한한다\n<ul>\n<li>첫번째 코드처럼 when 외부에서 선언하게 되면 when이 아닌 함수 내부의 다른 곳에서 해당 변수를 사용할 수 있게된다</li>\n<li>when의 인자로 내부 변수를 넣어버리면서 해당 변수의 스코프를 제한하고 when을 단일표현식으로 사용할 수 있게 되었다</li>\n</ul>\n</li>\n</ul>\n<h1>결론</h1>\n<ul>\n<li>range, 배열, 콜렉션으로 반복하는 코드를 작성한다</li>\n<li>when 전달인자 매칭문법으로 기존 조건문보다 간결하고 코드의 노이즈를 제거한다</li>\n</ul>\n<h1>🚨?!?!?</h1>\n<ul>\n<li><strong>arrayOf랑 listOf의 차이?</strong>\n<ul>\n<li>arrayOf는 사이즈가 고정되어있음</li>\n</ul>\n</li>\n</ul>\n<h1>🙈 더 알아보기</h1>\n<ul>\n<li>\n<p>when을 Decomplie하면?</p>\n<ul>\n<li>if이거나 switch</li>\n</ul>\n<pre><code class=\"language-kotlin\">// when 인자가 없는 경우\nprint(when {\n  list.size == 3 -> true\n  list.size > 4 -> 1\n  else -> false\n})\n\n>>> Decompile\nObject var2 = ((Standalone)this).list.size() == 3 ? true : (((Standalone)this).list.size() > 4 ? 1 : false);\n\n// when 인자가 있는 경우\nprint(when (list.size){\n  3 -> true\n  4 -> 1\n  else -> false\n})\n\n>>> Decompile\nObject var10001;\n  switch(((Standalone)this).list.size()) {\n  case 3:\n    var10001 = true;\n    break;\n  case 4:\n    var10001 = 1;\n    break;\n  default:\n    var10001 = false;\n  }\n</code></pre>\n</li>\n<li>\n<p>import kotlin</p>\n<ul>\n<li>kotlin 패키지에 포함된 함수는 kotlin.arrayOf() 형태나 kotlin을 따로 import하지 않아도 arrayOf()로만 사용 가능하다</li>\n</ul>\n</li>\n</ul>","frontmatter":{"slug":"/blog/kotlin-study-ch4","date":"2021년 4월 12일","title":"코틀린의 반복문"}}},"pageContext":{"id":"d6feb856-049c-578d-b9de-bf5cf213dfcc","frontmatter__slug":"/blog/kotlin-study-ch4","__params":{"frontmatter__slug":"blog"}}},
    "staticQueryHashes": ["3000541721","3293771174"]}