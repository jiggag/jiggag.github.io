{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/kotlin-study-ch6/","result":{"data":{"markdownRemark":{"html":"<pre><code class=\"language-markdown\">[참고 도서]\n\n- 다재다능 코틀린 프로그래밍\n</code></pre>\n<h1 id=\"any과-nothing\" style=\"position:relative;\"><a href=\"#any%EA%B3%BC-nothing\" aria-label=\"any과 nothing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Any과 Nothing</h1>\n<h2 id=\"any\" style=\"position:relative;\"><a href=\"#any\" aria-label=\"any permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Any</h2>\n<ul>\n<li>어떤 클래스에서도 사용 가능하도록 모든 클래스가 상속 받는 <code>베이스 클래스</code>\n<ul>\n<li>equal(), toString() 처럼 바로 사용할 수 있는 이유</li>\n<li>자바 Object</li>\n</ul>\n</li>\n<li>타입을 제한하지 않아 <code>유연하게 사용</code>할 수 있다\n<ul>\n<li>코틀린의 타입 안정성 추구에 삐뚤어지는 클래스...</li>\n<li><code>모든 코틀린 타입에 공통 적용되는 메소드를 위해 사용</code>\n<ul>\n<li>equal(), toString(), to(), let(), run(), apply()...</li>\n<li>Any 클래스에 구현된 확장함수</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"nothing\" style=\"position:relative;\"><a href=\"#nothing\" aria-label=\"nothing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Nothing</h2>\n<ul>\n<li>\n<p>모든 클래스가 갖고 있는 클래스</p>\n</li>\n<li>\n<p>아무것도 리턴하지 않을 경우 리턴하는 클래스</p>\n<ul>\n<li>\n<p>void와 닮았지만 다르다</p>\n</li>\n<li>\n<p>코틀린에서 void 대신 Unit 클래스 사용하는데 이는 리턴을 하긴 하는 경우 사용한다</p>\n</li>\n<li>\n<p>Nothing은 리턴 자체를 하지 않을때 사용한다</p>\n</li>\n<li>\n<p><code>오직 예외만을 발생시키고 아무런 인스턴스나 값, 결과가 반환되지 않는다</code></p>\n<ul>\n<li>\n<p>Nothing 타입의 대표가 예외</p>\n<pre><code class=\"language-kotlin\">fun test(n: Int): String {\n\tif (n >= 1) {\n\t\treturn \"1보다 같거나 큼\" // return String\n\t} else {\n\t\tthrow RuntimeException(\"1보다 작음\") // return Nothing\n\t}\n}\n>>>\njava.lang.RuntimeException: 1보다 작음\n\tat Test.test(test.kts:146)\n\tat Test.&#x3C;init>(test.kts:150)\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>Nothing의 목적은 컴파일러의 타입 무결성 검증을 도와주기 위함이다</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"null-가능-참조\" style=\"position:relative;\"><a href=\"#null-%EA%B0%80%EB%8A%A5-%EC%B0%B8%EC%A1%B0\" aria-label=\"null 가능 참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Null 가능 참조</h1>\n<h2 id=\"null이라고요\" style=\"position:relative;\"><a href=\"#null%EC%9D%B4%EB%9D%BC%EA%B3%A0%EC%9A%94\" aria-label=\"null이라고요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>null이라고요?</h2>\n<ul>\n<li>객체를 리턴하는 API에서 갑자기 null이 내려오는 경우\n<ul>\n<li>null 처리를 해두지 않았다면 null에서 구조분해를 하려는 경우 에러가 발생한다</li>\n<li>NullPointerException</li>\n<li>이를 처리하기 위한 Optional\n<ul>\n<li>누군가는 결국 null처리를 해야만 한다!</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>null을 사용하지 않으면 안될까?\n<ul>\n<li>코틀린에서 nullable 타입을 사용해 안정성을 추구한다</li>\n<li>또한 컴파일 시점에 null 체크 검증을 통해 오류도 예방한다</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"null은-에러를-유발한다\" style=\"position:relative;\"><a href=\"#null%EC%9D%80-%EC%97%90%EB%9F%AC%EB%A5%BC-%EC%9C%A0%EB%B0%9C%ED%95%9C%EB%8B%A4\" aria-label=\"null은 에러를 유발한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>null은 에러를 유발한다</h2>\n<ul>\n<li>\n<p><code>콜렉션을 리턴하는 함수가 리턴할 게 없다면 null이 아니라 빈 콜렉션을 리턴해야한다</code> - 이펙티브 자바</p>\n<ul>\n<li>이런 좋은 의견을 강력하게 이야기해주는 책이 있었다니...</li>\n<li>그동안 혼자 고민하느라 힘들었다</li>\n<li>이제 당당하게 null말고 빈거 주세요! 해봐야지!</li>\n<li>콜렉션이 아닌 경우 null보다는 Optional을 권장하고 있다\n<ul>\n<li>하지만 null을 피하려고만 해도 오버헤드가 발생한다</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>null을 리턴하게 되면 사용하는 쪽에서 null에 대한 오류 처리를 해야한다</p>\n</li>\n<li>\n<p>코틀린이 이런 상황들을 안전하고 우아하게 해결해준다</p>\n<ul>\n<li>\n<p>null 참조나 타입이 불가한 곳에 할당하거나 리턴하려고 하면 컴파일 오류를 발생시킨다</p>\n<pre><code class=\"language-kotlin\">fun nonNull(value: String): String {\n  if (value == \"nonnull\") {\n    return \"널이 아닙니다\"\n  }\n  return null // Null can not be a value of a non-null type String\n}\nprintln(nonNull(null)) // Null can not be a value of a non-null type String\n</code></pre>\n</li>\n<li>\n<p>코틀린에서는 null과 nullable을 사용하지 않도록 한다</p>\n<ul>\n<li>꼭 사용해야한다면 NPE가 발생하지 않도록 명확하게 표현해야한다</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"nullable\" style=\"position:relative;\"><a href=\"#nullable\" aria-label=\"nullable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>nullable</h2>\n<ul>\n<li>\n<p>해당 타입과 null을 모두 받을 수 있다</p>\n<ul>\n<li><code>String?, List&#x3C;String>?, CustomClass?</code></li>\n</ul>\n<pre><code class=\"language-kotlin\">fun nonNull(value: String?): String? {\n  if (value == \"nonnull\") {\n    return \"널이 아닙니다\"\n  }\n  return null\n}\nprintln(nonNull(\"nonnull\")) // 널이 아닙니다\nprintln(nonNull(\"null\")) // null\nprintln(nonNull(null)) // null\n</code></pre>\n</li>\n</ul>\n<h2 id=\"세이프-콜-연산자-\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EC%9D%B4%ED%94%84-%EC%BD%9C-%EC%97%B0%EC%82%B0%EC%9E%90-\" aria-label=\"세이프 콜 연산자  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세이프 콜 연산자 (?)</h2>\n<ul>\n<li>null에서 메소드를 호출하려고 할 때 <code>save call operation</code>이나 <code>non-null assertion operator</code> 이 필요하다</li>\n<li><code>? 연산자</code> 로 메소드 호출과 객체 속성에 대한 접근을 nullable하게 할 수 있다\n<ul>\n<li><code>value?.method()</code></li>\n<li>value가 null이면 해당 메소드 호출은 null을 반환한다</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"엘비스-연산자-\" style=\"position:relative;\"><a href=\"#%EC%97%98%EB%B9%84%EC%8A%A4-%EC%97%B0%EC%82%B0%EC%9E%90-\" aria-label=\"엘비스 연산자  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엘비스 연산자 (?:)</h2>\n<ul>\n<li>세이프 콜 연산자에서는 대상이 null이면 null을 반환하지만 엘비스 연산자를 사용하여 특정 값을 반환하도록 할 수 있다\n<ul>\n<li><code>value?.method() ?: \"기본값 반환\"</code>\n<ol>\n<li>value가 null이면 기본값 반환</li>\n<li>value가 null이 아니면 해당 결과값 반환</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"확정-연산자-\" style=\"position:relative;\"><a href=\"#%ED%99%95%EC%A0%95-%EC%97%B0%EC%82%B0%EC%9E%90-\" aria-label=\"확정 연산자  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>확정 연산자 (!!)</h2>\n<ul>\n<li>모든게 <code>null이 절대 아니라고 확정한다</code>\n<ul>\n<li><code>value!!.method()</code></li>\n<li>value가 무조건 null이 아니라고 확정하고 method를 호출하는데 실행하면 NPE...</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"when으로-nullable-처리\" style=\"position:relative;\"><a href=\"#when%EC%9C%BC%EB%A1%9C-nullable-%EC%B2%98%EB%A6%AC\" aria-label=\"when으로 nullable 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>when으로 nullable 처리</h2>\n<ul>\n<li>\n<p>세이프 콜 연산자나 엘비스 연산자로 nullable을 처리하는 것보다 when으로 처리할 수 있다</p>\n<ul>\n<li>해당 값을 추출하고자 한다면 세이프콜이나 엘비스 연산자</li>\n<li>nullable한 참조에 대한 처리를 결정해야 할 때 when</li>\n</ul>\n<pre><code class=\"language-kotlin\">fun nickName(name: String?): String {\n  if (name == \"이름\") {\n    return \"닉네임\"\n  }\n  return name?.reversed()?.toUpperCase() ?: \"없음\"\n}\nprintln(nickName(\"이름\")) // 닉네임\nprintln(nickName(\"etc\")) // CTE\nprintln(nickName(null)) // 없음\n\nfun nickName(name: String?) = when (name) {\n\t\"이름\" -> \"닉네임\"\n\tnull -> \"없음\"\n\telse -> name.reversed().toUpperCase()\n}\n</code></pre>\n<ul>\n<li>두번째 구문에서 null에 대한 처리를 했기때문에 마지막 else에서는 세이프콜 연산자를 사용하지 않아도 에러가 발생하지 않는다</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"타입-체크와-캐스팅\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85-%EC%B2%B4%ED%81%AC%EC%99%80-%EC%BA%90%EC%8A%A4%ED%8C%85\" aria-label=\"타입 체크와 캐스팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입 체크와 캐스팅</h1>\n<h2 id=\"타입-체크\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85-%EC%B2%B4%ED%81%AC\" aria-label=\"타입 체크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입 체크</h2>\n<ul>\n<li>메소드를 호출하고자 한다면 해당 메소드를 가지고 있는 타입인지 확인이 필요하다</li>\n<li>확장성에서는 타입 체크가 필수적이다</li>\n</ul>\n<h2 id=\"is\" style=\"position:relative;\"><a href=\"#is\" aria-label=\"is permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>is</h2>\n<ul>\n<li><code>a is A</code> a가 A타입인지 확인한다</li>\n<li>객체의 타입과 같거나 상속관계에 있다면 true를 반환한다</li>\n<li><code>b !is A</code> 로 사용하면 b는 A가 아님을 확인할 수 있다</li>\n</ul>\n<h2 id=\"스마트-캐스트\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EB%A7%88%ED%8A%B8-%EC%BA%90%EC%8A%A4%ED%8A%B8\" aria-label=\"스마트 캐스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스마트 캐스트</h2>\n<ul>\n<li>해당 참조의 타입이 확인되면 자동으로 스마트 캐스팅 된다\n<ul>\n<li>코틀린이 타입을 확인하는 즉시 스마트 캐스트가 동작한다</li>\n<li><code>is</code> 를 사용하고 나면 해당 값의 타입은 검증되었기에 추가로 타입 캐스팅 없이 해당 타입으로 동작한다</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"명시적-타입-캐스팅\" style=\"position:relative;\"><a href=\"#%EB%AA%85%EC%8B%9C%EC%A0%81-%ED%83%80%EC%9E%85-%EC%BA%90%EC%8A%A4%ED%8C%85\" aria-label=\"명시적 타입 캐스팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>명시적 타입 캐스팅</h2>\n<ul>\n<li><code>as, as?</code></li>\n<li>컴파일러가 타입을 결정할 수 없어 스마트 캐스팅을 할 수 없는 경우 사용한다</li>\n</ul>\n<pre><code class=\"language-kotlin\">fun anyType(): Any {\n  return 1\n}\nprintln((anyType() as String).length)\n\n>>>\njava.lang.ClassCastException: class java.lang.Integer cannot be cast to class java.lang.String (java.lang.Integer and java.lang.String are in module java.base of loader 'bootstrap')\n</code></pre>\n<ul>\n<li><code>(result as String).length</code>\n<ul>\n<li>result의 타입을 String이라고 명시를 해버리고 String처럼 동작하도록 하였다</li>\n<li>강제로 타입을 바꿔버렸기 때문에 실제로 result가 String이 아닌 경우 런타임 에러가 발생한다</li>\n</ul>\n</li>\n<li><code>println((anyType() as? String)?.length)</code>\n<ul>\n<li><code>as?</code> 을 사용해서 실제 String이 아니라 실패하는 경우 null이 반환되도록 방어처리를 할 수 있다</li>\n<li>null.length도 없으니깐 여기도 추가적으로 방어처리가 되어야한다</li>\n<li>as?가 as 보다 안정적으로 보인다</li>\n</ul>\n</li>\n<li>스마트 캐스트 안전한 캐스트 연산자를 사용하기를 권한다</li>\n</ul>\n<h1 id=\"제네릭\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%EB%84%A4%EB%A6%AD\" aria-label=\"제네릭 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제네릭</h1>\n<ul>\n<li>코드 재사용성을 위해 타입을 Any로 사용하여 안정성이 저하되는 것을 방지하고자 제네릭을 사용한다</li>\n<li>자바에서는 제네릭으로 받은 파라미터 타입 T에 대해서만 사용가능하고 T의 부모나 자식 클래스를 사용하는 것이 불가능했다\n<ul>\n<li>그것은 타입이 정확하게 일치해야하기 때문이다</li>\n</ul>\n</li>\n<li>코틀린에서는 이를 <strong>공변성(T의 자식), 반공변성(T의 부모)</strong> 을 사용해 확장했다\n<ul>\n<li>파라미터 타입 T를 확장해 T의 자식클래스(extends)와 부모 클래스(super) 모두 쓸 수 있다</li>\n</ul>\n</li>\n<li>사용처 가변성 - 제네릭을 사용할때</li>\n<li>선언처 가변성 - 제네릭을 선언할때</li>\n</ul>\n<h2 id=\"타입-불변성\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85-%EB%B6%88%EB%B3%80%EC%84%B1\" aria-label=\"타입 불변성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입 불변성</h2>\n<ul>\n<li>\n<p>타입을 변경할 수 없다</p>\n<ul>\n<li>전달 받는 타입은 약속된 타입과 동일해야한다!!!!</li>\n<li>!!이런 불변성을 뛰어넘어 다른 타입을 전달하고자 한다면 공변성, 반공변성을 활용한다...</li>\n</ul>\n</li>\n<li>\n<p>메소드가 클래스 T를 파라미터로 받는다 → T의 자식 클래스로 전달 가능하다</p>\n<ul>\n<li>fun method(Animal animal) → method(dog) 가능</li>\n</ul>\n</li>\n<li>\n<p>메소드가 타입 T의 제네릭을 받는다 → T의 파생 클래스는 전달 불가능하다</p>\n<ul>\n<li>fun method<Animal> → method<Dog> 불가능</li>\n</ul>\n<pre><code class=\"language-kotlin\">open class Fruit // public static class Fruit {}\nclass Banana: Fruit() // public static final class Banana extends Example.Fruit {}\nclass Orange: Fruit()\n\nfun receiveFruites(fruits: Array&#x3C;Fruit>) {\n\tprintln(fruits.size)\n}\nval banana: Array&#x3C;Banana> = arrayOf()\nreceiveFruites(banana)\n>>> Kotlin: Type mismatch: inferred type is Array&#x3C;Banana> but Array&#x3C;Fruit> was expected\n</code></pre>\n<ol>\n<li>Fruit를 제네릭으로 받는 배열을 파라미터로 갖는 <code>receiveFruites</code> 함수에 Banana 배열을 넘겼더니 에러가 발생했다</li>\n<li>코틀린의 <code>제네릭에 대한 타입 불변성</code> 으로 에러가 발생한다\n<ul>\n<li>Banana 배열은 Fruit 배열을 상속받지 않았다?</li>\n<li>상속 받았다면 Fruit의 인스턴스 메소드를 모두 Banana에서 사용 할 수 있다?</li>\n</ul>\n</li>\n<li><code>receiveFruites</code> 에서 Banana를 전달 가능하게 처리하다보면 Orange도 처리해줘야하고 그러면 <code>리스코프 치환 원칙</code> 에 위배된다</li>\n</ol>\n<pre><code class=\"language-kotlin\">val banana: Array&#x3C;Banana> = arrayOf()\nreceiveFruites(banana)\n>>> 이건 타입 오류가 발생하지만\n\nval banana: List&#x3C;Banana> = listOf()\nreceiveFruites(banana)\n>>> 이건 정상 동작한다\n</code></pre>\n<ul>\n<li>arrayOf와 listOf의 차이로 뮤터블인지 이뮤터블인지에 따라 타입 불변성이 유지된다\n<ul>\n<li>뮤터블인 arrayOf에서는 Fruit가 아닌 Array<Banana>에 또 다른 무언가가 추가되어 Fruit와는 다르게 동작할 가능성이 있기에 에러를 발생시킨다</li>\n<li>이뮤터블인 listOf는 추가할 수 없기에 정상 동작한다</li>\n<li>두 타입의 정의를 보면 <code>Array&#x3C;T>는 class Array&#x3C;T></code> 이고 <code>List&#x3C;T>는 interface List&#x3C;out E></code> 이다</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"공변성\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%EB%B3%80%EC%84%B1\" aria-label=\"공변성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공변성</h2>\n<ul>\n<li>부모 클래스 자리에 자식 클래스도 사용할 수 있게 확장한다</li>\n<li><code>타입 T를 확장</code>해서 사용하고자 <code>코틀린 컴파일러가 공변성을 허용</code>하도록 타입 프로젝션을 사용한다\n<ul>\n<li>코틀린은 Array<Banana>를 Array<Fruit>를 받는 곳에 전달하는 것을 방지한다</li>\n<li>Array<Banana>에 이상한 걸 추가해서 Fruit라고 하는 것을 보호해주는 것이다</li>\n<li>제네릭 베이스 타입이 요구되는 곳에 제네릭 파생 타입이 허용되도록 하기 위해 공변성을 허용하도록 하는 타입 프로젝션을 사용한다</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"공변성-사용하기\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%EB%B3%80%EC%84%B1-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"공변성 사용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공변성 사용하기</h3>\n<pre><code class=\"language-kotlin\">val fruitBasket1 = Array&#x3C;Fruit>(3) { _ -> Fruit()  }\nval fruitBasket2 = Array&#x3C;Fruit>(3) { _ -> Fruit()  }\nfun copyFromTo(from: Array&#x3C;Fruit>, to: Array&#x3C;Fruit>) {\n  for (i in 0 until from.size) {\n    to[i] = from[i]\n  }\n}\ncopyFromTo(fruitBasket1, fruitBasket2)\n\n// from과 to 모두 동일하게 Fruit 타입의 배열을 인자로 전달받았기에 정상 동작한다\n</code></pre>\n<pre><code class=\"language-kotlin\">val fruitBasket = Array&#x3C;Fruit>(3) { _ -> Fruit()  }\nval bananaBasket = Array&#x3C;Banana>(3) { _ -> Banana()  }\ncopyFromTo(bananaBasket, fruitBasket) // type mismatch\n\n// Banana 배열을 전달하고자 하면 타입 에러가 발생한다\n</code></pre>\n<ul>\n<li>코틀린에서는 from을 읽어오기만 하기 때문에 Fruit나 Fruit의 하위 클래스가 전달되어도 괜찮다 → <code>파라미터 타입의 공변성</code>\n<ul>\n<li><code>from: Array&#x3C;out Fruit></code> 형태로 from 인자를 내부 로직에서 읽기만 한다는 것을 명시하여 공변성을 이용한다</li>\n<li>만약 <code>Array&#x3C;out Fruit></code> 라고 해놓고 내부 로직에서 from을 수정하려고 하면 컴파일 오류가 발생한다</li>\n</ul>\n</li>\n<li>공변성을 사용하기 위해서는 코틀린 컴파일러에게 어떤 값도 추가, 수정 하지 않겠다는 약속을 해야한다\n<ul>\n<li>Array<T>는 T타입을 읽고 쓰는 메소드를 모두 가지고 있다</li>\n<li>제네릭 클래스를 사용하는 관점에서 공변성을 이용하는 것을 <code>사용처 가변성 (타입 프로젝션)</code> 이라고 한다\n<ul>\n<li><code>Array&#x3C;out T></code> 는 <code>Array&#x3C;out T></code> 의 공변성 파라미터에 추가, 수정이 없다는 것을 보장한다</li>\n</ul>\n</li>\n<li>사용하는 관점이 아니라 선언할 때 공변성을 사용한다고 지정하는 것을 <code>선언처 가변성</code> 이라고 한다\n<ul>\n<li><code>List&#x3C;out T></code> 로 되어있는 인터페이스는 <code>List&#x3C;T></code> 에 추가, 수정이 없다는 것을 보장한다</li>\n<li>선언 가변성을 적용된 파라미터에만 사용 가변성과 같이 동작한다</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"반공변성\" style=\"position:relative;\"><a href=\"#%EB%B0%98%EA%B3%B5%EB%B3%80%EC%84%B1\" aria-label=\"반공변성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>반공변성</h2>\n<ul>\n<li>자식 클래스 자리에 부모 클래스를 사용할 수 있게 한다</li>\n<li>모든 타입의 베이스 타입을 사용할 수 있게 한다</li>\n</ul>\n<pre><code class=\"language-kotlin\">val anyBasket = Array&#x3C;Any>(3) { _ -> Fruit()  }\nval bananaBasket = Array&#x3C;Banana>(3) { _ -> Banana()  }\ncopyFromTo(bananaBasket, anyBasket) // type mismatch\n\n// Fruit가 온다고 고정되어 있는 to 자리에 부모 클래스인 Any 타입이 전달되면 타입 오류가 발생한다\n</code></pre>\n<pre><code class=\"language-kotlin\">fun copyFromTo(from: Array&#x3C;out Fruit>, to: Array&#x3C;in Fruit>) {\n  ...\n}\n</code></pre>\n<ul>\n<li>Array<Fruit>로 고정되어 있던 to의 타입을 <code>Array&#x3C;in Fruit></code>로 변경하였다\n<ul>\n<li><code>in 키워드</code>는 파라미터에 값을 설정할 수 있지만 읽는 건 불가능하다</li>\n<li><code>반공변성 in</code> 을 사용한 사용처 가변성이다</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"파라미터-타입-제한-where\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-%ED%83%80%EC%9E%85-%EC%A0%9C%ED%95%9C-where\" aria-label=\"파라미터 타입 제한 where permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파라미터 타입 제한 (where)</h2>\n<ul>\n<li>\n<p>제네릭으로 파라미터에 여러가지 타입을 쓸 수 있도록 유연함을 제공한다</p>\n<ul>\n<li>\n<p>유연함을 제공하면서도 제약하고자 제약조건을 추가하여 파라미터 타입을 제한한다</p>\n</li>\n<li>\n<p>줬다 뺐기</p>\n<pre><code class=\"language-kotlin\">fun &#x3C;T> useAndClose(input: T) {\n  input.close() // Unresolved reference: close\n}\n</code></pre>\n<ol>\n<li>input의 타입을 제네릭으로 전달하였지만 어떤 타입에서는 close() 메소드가 없을 수 있다</li>\n<li>close가 있는 타입만 들어올 수 있도록 제네릭을 제약조건을 주어서 제약한다</li>\n<li><code>fun &#x3C;T: AutoCloseable> useAndClose(input: T)</code></li>\n<li>T 타입은 <code>AutoCloseable</code> 인터페이스를 구현한 클래스만이 들어올 수 있다</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>제네릭에 하나의 제약조건을 주고 싶을 때는 <code>:</code> 으로 넣으면 되지만 여러개의 제약조건을 주고 싶은 경우에는 <code>where</code> 를 사용한다</p>\n<pre><code class=\"language-kotlin\">fun &#x3C;T> useAndClose(input: T)\n\twhere T: AutoCloseable,\n\t\t\t\tT: Appendable {\n  input.append(\"더하기\")\n  input.close()\n}\n</code></pre>\n<ul>\n<li>close와 append를 모두 갖고 있는 타입만이 전달할 수 있다</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"스타-프로젝션-\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%83%80-%ED%94%84%EB%A1%9C%EC%A0%9D%EC%85%98-\" aria-label=\"스타 프로젝션  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스타 프로젝션 (*)</h2>\n<ul>\n<li>\n<p>타입에 대해 정확하게 알 수 없지만 타입 안정성을 유지하면서 파라미터를 전달하고자 할 때 사용한다</p>\n<ul>\n<li>스타 프로젝션은 읽기만 허용하고 쓰는 것을 허용하지 않는다</li>\n</ul>\n<pre><code class=\"language-kotlin\">fun onlyRead(values: Array&#x3C;*>) {\n\tfor (value in values) {\n\t\tprintln(value)\n\t}\n\tvalues[0] = values[1] // Out-projected type 'Array&#x3C;*>' prohibits the use of 'public final operator fun set(index: Int, value: T): Unit defined in kotlin.Array'\n}\n</code></pre>\n</li>\n</ul>\n<h1 id=\"타입-파라미터-구체화\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-%EA%B5%AC%EC%B2%B4%ED%99%94\" aria-label=\"타입 파라미터 구체화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입 파라미터 구체화</h1>\n<pre><code class=\"language-kotlin\">val books: List&#x3C;Book> = listOf(NonFiction(\"찾는책\"), Fiction(\"책\"))\nfun &#x3C;T> findFirst(books: List&#x3C;Book>, ofClass: Class&#x3C;T>): T {\n  val selected = books.filter { book -> ofClass.isInstance(book) }\n  if (selected.size == 0) {\n    throw RuntimeException(\"not found\")\n  }\n  return ofClass.cast(selected[0])\n}\n\nprintln(findFirst(books, NonFiction::class.java).name)\n</code></pre>\n<ul>\n<li>제네릭으로 전달한 타입 T의 인스턴스를 반환하고자 한다</li>\n<li>타입 체크와 타입 캐스팅을 위해 ofClass를 사용하였다</li>\n<li>ofClass를 전달하기 위해 타입 정보를 런타임에 계속 구해서 전달해야한다</li>\n</ul>\n<h2 id=\"reified-type-parameters\" style=\"position:relative;\"><a href=\"#reified-type-parameters\" aria-label=\"reified type parameters permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reified Type Parameters</h2>\n<pre><code class=\"language-kotlin\">inline fun &#x3C;reified T> findFirst(books: List&#x3C;Book>): T {\n  val selected = books.filter { book -> book is T }\n  if (selected.size == 0) {\n    throw RuntimeException(\"not found\")\n  }\n\treturn selected[0] as T\n}\n</code></pre>\n<ul>\n<li>코틀린의 구체화 타입 파라미터를 이용해 컴파일 시점에 구해서 전달할 수 있다</li>\n<li>함수 내부에서 T를 타입 체크와 캐스팅 하는데 사용할 수 있다</li>\n<li>함수가 inline으로 선언되어있기에 reified를 사용할 수 있고 컴파일 시간에 실제 타입으로 대체 된다</li>\n<li>구체화 타입 파라미터를 이용해 가독성과 타입 캐스팅, 컴파일 안정성을 확보할 수 있다</li>\n</ul>\n<h1 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h1>\n<ul>\n<li>타입 안정성이 먼저다!\n<ul>\n<li>스마트 캐스트</li>\n<li>파라미터 타입 조정</li>\n<li>reified 타입 파라미터</li>\n</ul>\n</li>\n<li>nullable과 non-nullable을 분리하여 컴파일러가 메모리 오버헤드 없이 타입 안정성을 가지게 되었다\n<ul>\n<li>nullable로부터 타입 안정적으로 객체에 접근할 수 있는 연산자를 제공한다</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"\" style=\"position:relative;\"><a href=\"#\" aria-label=\" permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🚨?!?!?</h1>\n<ul>\n<li><strong>갑자기 null이 리턴된다고!?</strong>\n<ul>\n<li>협업을 하게 되면서 그리고 클라이언트 작업을 하게 되면서 개발된 API를 전달받고나서</li>\n<li>더미 데이터로 잘 테스트 하다가 갑자기 에러가 나는 경우가 있다</li>\n<li><code>갑자기 null이 들어왔을때</code></li>\n<li>분명 문서에도 리턴값은 User, Custom, number, string...</li>\n<li>데이터가 없어서 null이라고 한다</li>\n<li>이럴때면 왜 null이지? 그냥 빈 값을 내려주면 되는것 아닐까? 생각해보았다</li>\n<li>[]나 {}나... 0이나 ''나...</li>\n<li>null처리를 어느 곳에서 하느냐의 차이이지 않았을까</li>\n<li>이걸 코틀린이 해결해주려나!</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"-더-알아보기\" style=\"position:relative;\"><a href=\"#-%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0\" aria-label=\" 더 알아보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🙈 더 알아보기</h1>\n<ul>\n<li><strong>공변성, 반공변성</strong>\n<ul>\n<li><a href=\"%5Bhttps://seob.dev/posts/%EA%B3%B5%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/%5D(https://seob.dev/posts/%EA%B3%B5%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/)\">참고 블로그: 공변성이란 무엇인가</a></li>\n<li><a href=\"%5Bhttps://edykim.com/ko/post/what-is-coercion-and-anticommunism/%5D(https://edykim.com/ko/post/what-is-coercion-and-anticommunism/)\">참고 블로그: 공변성과 반공변성은 무엇인가?</a></li>\n<li>공변성은 읽기 전용이라면 반공변성은 쓰기 전용이라고 이해하면 되는걸까</li>\n<li>읽기 전용이니깐 확장된 타입인 자식 클래스를 전달해서 읽어가기만 해도 되는 것이고 쓰기 전용에서는 값을 써야하는데 없는 메소드가 있으면 안되니깐 부모 클래스를 전달해도 되는 이런 느낌?</li>\n</ul>\n</li>\n<li><strong>리스코프 치환 원칙</strong>\n<ul>\n<li><a href=\"%5Bhttps://pizzasheepsdev.tistory.com/9%5D(https://pizzasheepsdev.tistory.com/9)\">참고</a></li>\n<li>공변성, 반공변성과 연관</li>\n<li>부모 클래스의 인스턴스가 실행하는 행위는 자식 클래스의 인스턴스들도 일관성이 있게 실행해야 함</li>\n<li>부모에서 구현한 원칙을 따라야 한다</li>\n</ul>\n</li>\n<li><strong>inline 키워드</strong>\n<ul>\n<li><code>inline fun &#x3C;reified T>  findName(...):T {}</code></li>\n<li><code>reified</code> 를 사용하려면 <code>inline 함수</code> 이여야만 한다</li>\n<li>inline 키워드는 무슨 뜻일까</li>\n</ul>\n</li>\n<li><strong>reified 키워드</strong>\n<ul>\n<li>inline 키워드 안에서만 사용가능하다</li>\n<li>제네릭으로 주어진 타입을 함수 내부 로직에서 마치 클래스 인 것 처럼 사용할 수 있다</li>\n<li><code>name is T</code> 이런 모양으로... ??? 원래 안되나?? 헷갈린다</li>\n</ul>\n</li>\n<li><strong>오버헤드</strong>\n<ul>\n<li>무언가를 처리하기 위해 소요되는 처리 시간이나 메모리</li>\n<li>X만큼 걸리던 처리에 안정성 개선하고자 추가한 작업으로 인해 X+5만큼 걸리게 되었다면 5라는 오버헤드 발생</li>\n</ul>\n</li>\n</ul>","frontmatter":{"slug":"/blog/kotlin-study-ch6","date":"2021년 4월 22일","title":"코틀린 타입 안정성 그리고 공변성과 반공변성...","subtitle":"Chapter 06 오류를 예방하는 타입 안정성","tags":["코틀린","스터디","kotlin"]}}},"pageContext":{"id":"d5553578-a62e-53b2-96e1-9fcc3443ec2f","frontmatter__slug":"/blog/kotlin-study-ch6","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["3000541721","3293771174"],"slicesMap":{}}