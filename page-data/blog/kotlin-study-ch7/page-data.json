{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/kotlin-study-ch7/","result":{"data":{"markdownRemark":{"html":"<pre><code class=\"language-markdown\">[참고 도서]\n\n- 다재다능 코틀린 프로그래밍\n</code></pre>\n<h1 id=\"객체와-싱글톤\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4%EC%99%80-%EC%8B%B1%EA%B8%80%ED%86%A4\" aria-label=\"객체와 싱글톤 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체와 싱글톤</h1>\n<ul>\n<li>코틀린에서는 클래스를 사용하지 않고 탑레벨 함수만으로도 작업할 수 있다</li>\n<li>그러나 객체지향 프로그래밍을 따르기에 보일러플레이트 코드 없이 코틀린을 이용해 쉽고 빠르게 클래스를 만들 수 있다\n<ul>\n<li>클래스의 속성만 정의하면 코틀린이 backing field를 만들어준다</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"싱글톤\" style=\"position:relative;\"><a href=\"#%EC%8B%B1%EA%B8%80%ED%86%A4\" aria-label=\"싱글톤 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>싱글톤</h3>\n<ul>\n<li>인스턴스 수를 제어하기 위해 생성자에 리클렉션 접근을 방지하고</li>\n<li>스레드 안정성과 인스턴스 존재 유무를 확인하면서 오버헤드를 방지해야한다</li>\n<li>이런 여러가지 신경써야하는 것을 코틀린에서 싱글톤을 지원하면서 잘못된 구현이나 위험을 방지한다</li>\n</ul>\n<h2 id=\"객체-표현식으로-익명-객체-사용하기\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%ED%91%9C%ED%98%84%EC%8B%9D%EC%9C%BC%EB%A1%9C-%EC%9D%B5%EB%AA%85-%EA%B0%9D%EC%B2%B4-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"객체 표현식으로 익명 객체 사용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 표현식으로 익명 객체 사용하기</h2>\n<ul>\n<li>\n<p><code>object</code> 키워드로 객체가 가지고 있는 필드를 감싸주기만 하면 된다</p>\n<pre><code class=\"language-kotlin\">fun createObj() {\n  val circle = object { // val circle: &#x3C;anonymous object : Any>\n    val x = 20\n    val y = 20\n    val radius = 10\n  }\n  println(\"circle ${circle.x}, ${circle.y}, ${circle.radius}\")\n}\ncreateObj()\n</code></pre>\n<ul>\n<li>\n<p><code>circle</code> 라는 객체에는 <code>x, y, radius</code> 속성을 갖고 있다</p>\n<ul>\n<li>익명 객체를 circle에 담아주었다</li>\n<li>단순하게 객체를 만들었다! <code>const circle = { ... }</code> 처럼...</li>\n</ul>\n</li>\n<li>\n<p><strong><code>익명 객체의 내부 타입은 함수나 메서드의 리턴타입이나 파라미터가 될 수 없다</code></strong></p>\n</li>\n<li>\n<p><strong><code>클래스 안에 저장된 속성이 있다면 모두 Any로 간주된다</code></strong></p>\n<ul>\n<li><code>circle</code> 객체는 <code>object: Any</code> 로 추론되고 있다</li>\n</ul>\n<pre><code class=\"language-kotlin\">fun createRunnable(): Runnable {\n  val runnable = object: Runnable {\n    override fun run() {\n      println(\"runnable\")\n    }\n  }\n  return runnable\n}\n\nfun createRunnable(): Runnable {\n  val runnable = object: Runnable, AutoCloseable {\n    override fun run() {\n      println(\"runnable\")\n    }\n    override fun close() {\n      println(\"close\")\n    }\n  }\n  return runnable\n}\n</code></pre>\n<ul>\n<li><code>runnable</code> 의 타입을 <code>Runnable</code> 로 리턴하였다\n<ul>\n<li>두번째 runnable에서는 object가 AutoCloseable 타입의 인터페이스도 구현하였지만 <code>리턴타입이 Runnable라서 close메서드에 접근이 안된다</code></li>\n<li>리턴이 필요한 경우 리턴할 인스턴스 타입을 명시해주어야한다</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"객체-선언을-이용한-싱글톤\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%84%A0%EC%96%B8%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%8B%B1%EA%B8%80%ED%86%A4\" aria-label=\"객체 선언을 이용한 싱글톤 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 선언을 이용한 싱글톤</h2>\n<ul>\n<li>\n<p><code>object</code> 키워드 뒤에 이름을 넣어서 객체를 선언한다</p>\n<pre><code class=\"language-kotlin\">object Util {\n\tval name = \"객체\"\n  fun numberOfProcessors() = Runtime.getRuntime().availableProcessors()\n}\nprintln(Util.numberOfProcessors())\nprintln(Util.name)\n</code></pre>\n<ul>\n<li><code>Util</code> 객체의 메서드 <code>numberOfProcessors</code> 를 호출한다</li>\n<li>Util로 선언된 순간 이미 객체가 되었다!\n<ul>\n<li>private 생성자와 static 메서드를 갖고 있다</li>\n<li>메서드와 속성에 접근이 가능하다</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"탑레벨-함수-vs-싱글톤\" style=\"position:relative;\"><a href=\"#%ED%83%91%EB%A0%88%EB%B2%A8-%ED%95%A8%EC%88%98-vs-%EC%8B%B1%EA%B8%80%ED%86%A4\" aria-label=\"탑레벨 함수 vs 싱글톤 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>탑레벨 함수 vs 싱글톤</h2>\n<ul>\n<li>함수의 그룹핑과 모듈화의 목적</li>\n<li>넓게 사용될 유틸리티성 함수들은 탑레벨</li>\n<li>서로 연관되어 있는 함수들은 싱글톤\n<ul>\n<li>멀티스레드에서 싱글톤을 뮤터블하게 만들어서 사용하는 경우 서로 업데이트 해버리는 불상사...</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"클래스\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스</h1>\n<h2 id=\"보일러-플레이트-없는-클래스\" style=\"position:relative;\"><a href=\"#%EB%B3%B4%EC%9D%BC%EB%9F%AC-%ED%94%8C%EB%A0%88%EC%9D%B4%ED%8A%B8-%EC%97%86%EB%8A%94-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"보일러 플레이트 없는 클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>보일러 플레이트 없는 클래스</h2>\n<ul>\n<li>\n<p><code>class Car(val speed: Int)</code></p>\n</li>\n<li>\n<p>백킹 필드를 직접 작성하지 않아도 된다</p>\n</li>\n<li>\n<p>코틀린 컴파일러가 생성자와 setter, getter를 추가해준다</p>\n<pre><code class=\"language-java\">public static final class Car {\n    private final int speed;\n\n    public final int getSpeed() {\n       return this.speed;\n    }\n\n    public Car(int speed) {\n       this.speed = speed;\n    }\n }\n</code></pre>\n<ul>\n<li>코틀린에서 한줄이 자바로 컴파일하니 여러줄이 되었다...</li>\n</ul>\n</li>\n<li>\n<p>클래스 인스턴스를 만들때 <code>new</code> 키워드가 없이 바로 함수처럼 클래스를 이용한다</p>\n<ul>\n<li><code>val car = Car(20)</code></li>\n<li>클래스 속성에 접근도 일반적으로 접근 가능하다\n<ul>\n<li><code>println(car.speed)</code></li>\n<li>코틀린에서는 car.speed에 대한 접근을 하면 <code>car.getSpeed()</code> 를 호출한다</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>클래스 선언 당시 생성자 파라미터를 뮤터블/이뮤터블하게 선언해주면 setter처럼 바로 속성값 변경이 가능하다</p>\n<ul>\n<li><code>class Car(var speed: Int)</code></li>\n<li><code>car.speed = 10000</code> → car.setSpeed()</li>\n</ul>\n</li>\n<li>\n<p>클래스 속성에 직접 접근이 가능하다</p>\n<pre><code class=\"language-kotlin\">class Car(val speed: Int, var name: String)\nfun useCar(): Pair&#x3C;Int, String> {\n  val car = Car(20, \"이름\")\n  val speed = car.speed\n  car.name = \"이름바꾸기\"\n  val name = car.name\n  return speed to name\n}\nprintln(useCar()) // (20, 이름바꾸기)\n</code></pre>\n</li>\n</ul>\n<h2 id=\"속성-제어-변경\" style=\"position:relative;\"><a href=\"#%EC%86%8D%EC%84%B1-%EC%A0%9C%EC%96%B4-%EB%B3%80%EA%B2%BD\" aria-label=\"속성 제어 변경 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>속성 제어 변경</h2>\n<ul>\n<li>\n<p>setter에 대한 제한을 줄 수 있다</p>\n<ul>\n<li>setter를 커스텀하게 정의하였고 getter는 백킹필드로 생성된다</li>\n</ul>\n<pre><code class=\"language-kotlin\">class Car(val speed: Int, theName: String) {\n  var name = theName\n  set(value) {\n    if (value.isEmpty()) {\n      throw RuntimeException(\"빈 문자열 에러\")\n    }\n    field = value\n  }\n}\nval car = Car(20, \"이름\")\ntry {\n  car.name = \"\"\n} catch(ex: Exception) {\n  println(ex.message) // 에러 발생\n}\nprintln(car.name) // 이름\n</code></pre>\n<ul>\n<li>name이라는 속성은 생성자에 의해 변경되는 것이 아니라 추가 설정한 setter에 의해서만 변경된다</li>\n<li>theName은 Car 클래스의 파라미터일뿐! 필드가 아니다</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"접근-제어자\" style=\"position:relative;\"><a href=\"#%EC%A0%91%EA%B7%BC-%EC%A0%9C%EC%96%B4%EC%9E%90\" aria-label=\"접근 제어자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>접근 제어자</h2>\n<ul>\n<li>클래스 속성과 메서드에 접근 할 수 있는 제어자</li>\n<li>public, private, protected, internal</li>\n<li>protected는 파생된 자식클래스들의 메서드가 속성에 접근할 수 있는 권한을 준다</li>\n<li>internal은 같은 모듈에 있는 모든 코드에서 속성이나 메서드에 접근할 수 있다\n<ul>\n<li>컴파일된 모든 소스 코드에서 이뤄지며 코틀린 컴파일러가 직접 이용하므로 런타임 오버헤드가 없다</li>\n</ul>\n</li>\n<li>getter는 속성의 접근 권한과 동일하지만 setter는 직접 권한을 설정할 수 있다\n<ul>\n<li><code>private set</code> 으로 private setter를 만든다</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"초기화-코드\" style=\"position:relative;\"><a href=\"#%EC%B4%88%EA%B8%B0%ED%99%94-%EC%BD%94%EB%93%9C\" aria-label=\"초기화 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>초기화 코드</h2>\n<ul>\n<li>\n<p>주 생성자는 첫번째 줄에 파라미터와 속성이 정의된다</p>\n<ul>\n<li>파라미터로 전달되지 않은 속성은 클래스 내부에서 정의한다</li>\n<li>초기화 하는 코드값을 커스텀하기 위해 생성자용 바디를 만들 수 있다</li>\n</ul>\n</li>\n<li>\n<p><code>init</code> 블록으로 생성자를 top-down 방식으로 실행하면서 생성한다</p>\n<ul>\n<li>init 블록 안에서는 클래스 내부의 속성과 파라미터를 사용할 수 있다</li>\n<li>init 블록을 여러개 작성할 수 있다\n<ul>\n<li>주 생성자, 보조 생성자, 추가 메서드</li>\n<li>가능한 0개를 만들도록...</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-kotlin\">class Car(val name: String) {\n  var fullName = \"\"\n    private set\n\n  init {\n    fullName = \"내부 setter ${name}\"\n  }\n}\nprintln(Car(\"이름\").fullName) // 내부 setter 이름\n</code></pre>\n</li>\n</ul>\n<h2 id=\"보조-생성자\" style=\"position:relative;\"><a href=\"#%EB%B3%B4%EC%A1%B0-%EC%83%9D%EC%84%B1%EC%9E%90\" aria-label=\"보조 생성자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>보조 생성자</h2>\n<ul>\n<li>주 생성자를 작성하지 않았다면 코틀린이 아규먼트가 없는 기본 생성자를 생성한다\n<ul>\n<li>주 생성자가 있다면 아규먼트가 없는 보조 생성자를 생성한다</li>\n</ul>\n</li>\n<li>보조 생성자는 주 생성자를 호출하거나 다른 보조 생성자를 호출해야한다</li>\n<li>보조 생성자에서는 속성을 선언할 수 없다\n<ul>\n<li>주 생성자와 클래스 내부에서만 정의할 수 있다</li>\n</ul>\n</li>\n<li><strong>생성자끼리 순환 호출하면 안된다</strong></li>\n<li>파라미터를 이용해 다양한 생성자 형태로 객체를 생성 할 수 있다</li>\n</ul>\n<h2 id=\"인스턴스-메서드\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EB%A9%94%EC%84%9C%EB%93%9C\" aria-label=\"인스턴스 메서드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인스턴스 메서드</h2>\n<ul>\n<li>클래스 안에 정의하는 메서드</li>\n<li><code>fun</code> 으로 정의하며 public으로 생성된다\n<ul>\n<li>private, protected, internal 권한을 설정할 수 있다</li>\n</ul>\n</li>\n<li>탑레벨 함수와 유사하게 클래스 블록 안에서 선언된다</li>\n</ul>\n<h2 id=\"인라인-클래스\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%9D%BC%EC%9D%B8-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"인라인 클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인라인 클래스</h2>\n<ul>\n<li>\n<p>클래스는 추상화를 나타낸다</p>\n<ul>\n<li>프리미티브 타입과 동일하다</li>\n</ul>\n</li>\n<li>\n<p>프리미티브를 사용할지 클래스를 사용할지</p>\n<ul>\n<li>클래스를 반환한다고 구현할 수 있으나</li>\n<li>결국 클래스라는 인스턴스를 만들어야 하기 때문에 오버헤드가 발생할 수 있다</li>\n</ul>\n</li>\n<li>\n<p><strong><code>inline 클래스</code></strong> 로 <code>컴파일 타임에는 클래스</code>처럼 활용하며 <code>런타임에는 프리미티브 타입</code>으로 취급된다</p>\n<ul>\n<li>컴파일하고 바이트 코드로 변환되었을때 프리미티브 타입으로 변경된다</li>\n</ul>\n<pre><code class=\"language-kotlin\">inline class SSN(val id: String)\nfun receive(ssn: SSN) {\n  println(ssn)\n}\nreceive(SSN(\"ididid\"))\n\n/*\nSSN(id=ididid)\nobject.kts:117:1: warning: the feature \"inline classes\" is experimental\ninline class SSN(val id: String)\n*/\n</code></pre>\n</li>\n<li>\n<p><strong><code>inline 클래스의 주 생성자 파라미터는 1개만 가능하다</code></strong></p>\n<pre><code class=\"language-kotlin\">inline class SSN(val id: String, val name: String)\n\n// Inline class must have exactly one primary constructor parameter\n</code></pre>\n</li>\n</ul>\n<h1 id=\"컴패니언-객체와-클래스-멤버\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8C%A8%EB%8B%88%EC%96%B8-%EA%B0%9D%EC%B2%B4%EC%99%80-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A9%A4%EB%B2%84\" aria-label=\"컴패니언 객체와 클래스 멤버 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴패니언 객체와 클래스 멤버</h1>\n<h2 id=\"클래스-레벨-멤버\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A0%88%EB%B2%A8-%EB%A9%A4%EB%B2%84\" aria-label=\"클래스 레벨 멤버 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스 레벨 멤버</h2>\n<ul>\n<li>\n<p>클래스 레벨에서 필요하지만 클래스 인스턴스와는 관련이 없는 경우 <code>컴패니언 객체</code> 로 만든다</p>\n<ul>\n<li>컴패니언 객체는 클래스 안에서 정의한 싱글톤으로 인터페이스를 구현하거나 다른 클래스를 확장한다</li>\n</ul>\n<pre><code class=\"language-kotlin\">class Machine(val name: String) {\n  fun plus() = time++\n  fun minus() = time--\n\n  companion object {\n    var time = 0\n    fun getTime() = println(time)\n  }\n}\nprintln(Machine.time) // 0\nMachine(\"이름\").plus()\nprintln(Machine.time) // 1\nMachine(\"이름2\").plus()\nprintln(Machine.time) // 2\n</code></pre>\n<ol>\n<li>컴패니언 속성에 접근하여 해당 값을 변경하였다</li>\n<li>분명 다른 이름으로 Machine을 생성해서 plus 메서드를 호출하였다</li>\n<li>그러나 Machine 컴패니언의 time 값이 계속 증가하고 있다</li>\n<li>컴패니언 객체는 싱글톤으로 하나만 생성되었고 Machine 객체 자체를 여러개 생성했어도 컴패니언은 하나이기에 계속 값이 증가한다</li>\n</ol>\n<p>⇒ 이와 같은 이유로 뮤터블 속성값을 사용하면 멀티스레드에서 안정성 문제가 발생할 수 있다</p>\n</li>\n</ul>\n<h2 id=\"컴패니언에-접근하기\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8C%A8%EB%8B%88%EC%96%B8%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0\" aria-label=\"컴패니언에 접근하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴패니언에 접근하기</h2>\n<ul>\n<li>\n<p><code>Class.Companion</code></p>\n<ul>\n<li>컴패니언 객체 자체의 참조가 필요한 경우</li>\n<li>컴패니언 객체가 구현하고 있는 인터페이스의 참조가 필요한 경우</li>\n<li>함수나 메서드에 특정 인터페이스를 구현한 싱글톤 객체가 필요한 경우</li>\n</ul>\n<pre><code class=\"language-kotlin\">val ref = Machine.Companion\nprintln(ref) // Object$Machine$Companion@2286dfcd\n\n...\ncompanion object CompName {...} // 컴패니언에 이름이 있다면 해당 이름으로 대체 한다\nval ref = Machine.CompName\n</code></pre>\n</li>\n</ul>\n<h2 id=\"팩토리로-사용하는-컴패니언\" style=\"position:relative;\"><a href=\"#%ED%8C%A9%ED%86%A0%EB%A6%AC%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%BB%B4%ED%8C%A8%EB%8B%88%EC%96%B8\" aria-label=\"팩토리로 사용하는 컴패니언 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>팩토리로 사용하는 컴패니언</h2>\n<ul>\n<li>\n<p>컴패니언 객체는 클래스의 <code>팩토리</code>로 사용할 수 있다</p>\n</li>\n<li>\n<p>생성자로 객체를 초기화하고 사용하기 위한 상태를 만드는 여러 방법이 있다</p>\n<ul>\n<li>이런 상황에서 팩토리로 동작하는 클래스의 컴패니언 객체를 설계하는 것이 좋다</li>\n</ul>\n</li>\n<li>\n<p>컴패니언을 팩토리로 사용하기</p>\n<ol>\n<li><code>private</code> 생성자를 만들고</li>\n<li>컴패니언 객체에서 생성된 인스턴스를 리턴하기 전에 인스턴스를 사용하는 메서드를 하나 이상 생성한다</li>\n</ol>\n<pre><code class=\"language-kotlin\">class Machine private constructor(val name: String) {\n  fun start() {\n    println(\"시작\")\n  }\n\n  companion object {\n    fun create(name: String): Machine {\n      val instance = Machine(name)\n      instance.start()\n      return instance\n    }\n  }\n}\nval machine = Machine.create(\"컴패니언\")\nprintln(machine.name)\nval direct = Machine(\"오류 발생\") // Cannot access '&#x3C;init>': it is private in 'Machine'\n</code></pre>\n<ul>\n<li><code>private 생성자</code>로 만들었기 때문에 <code>Machine</code> 을 직접적으로 인스턴스를 생성하려고 하면 오류가 발생한다</li>\n<li><strong><code>컴패니언 객체의 메서드를 통해서만 Machine 인스턴스에 접근할 수 있다</code></strong></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"그렇다고-컴패니언이-static은-아니다\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%A0%87%EB%8B%A4%EA%B3%A0-%EC%BB%B4%ED%8C%A8%EB%8B%88%EC%96%B8%EC%9D%B4-static%EC%9D%80-%EC%95%84%EB%8B%88%EB%8B%A4\" aria-label=\"그렇다고 컴패니언이 static은 아니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그렇다고 컴패니언이 static은 아니다</h2>\n<ul>\n<li>컴패니언 객체의 멤버가 static이 되는 것은 아니다</li>\n<li>코틀린 컴파일러가 컴패니언 객체를 싱글톤으로 접근한다</li>\n</ul>\n<h1 id=\"제네릭-클래스\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"제네릭 클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제네릭 클래스</h1>\n<ul>\n<li>\n<p>클래스의 속성을 특정 타입으로만 제한하지 않고 제네릭으로 전달받은 타입을 허용한다</p>\n<ul>\n<li>참고: 파라미터 타입의 가변성과 제약사항</li>\n</ul>\n<pre><code class=\"language-kotlin\">class PriorityPair&#x3C;T: Comparable&#x3C;T>> (param1: T, param2: T) {\n  val first: T\n  val second: T\n  init {\n    if (param1.compareTo(param2) >= 0) { // param1 >= param2\n      first = param1\n      second = param2\n    } else {\n      first = param2\n      second = param1\n    }\n  }\n\n  override fun toString() = \"${first} - ${second}\"\n}\nprintln(PriorityPair(1, 2).toString())\n</code></pre>\n<ol>\n<li><code>PriorityPair&#x3C;T: Comparable&#x3C;T>></code> 라고 파라미터의 타입은 Comparable 인터페이스를 갖고 있도록 제한하였다</li>\n<li><code>Comparable</code> 한 파라미터를 받았기 때문에 <code>compareTo</code> 메서드를 사용할 수 있다</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"데이터-클래스\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"데이터 클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 클래스</h1>\n<ul>\n<li>\n<p>메서드 보다는 데이터 자체에 특화된 클래스</p>\n</li>\n<li>\n<p>주 생성자에 var나 val 속성 정의가 1개 이상 꼭 필요하다</p>\n<ul>\n<li>var, val 이외의 파라미터는 사용할 수 없다</li>\n</ul>\n</li>\n<li>\n<p>클래스 안에 속성이나 메서드를 추가할 수는 있다</p>\n</li>\n<li>\n<p>데이터를 주요하게 여기다보니 <code>equals(), copy(), hashCode(), toString()</code> 를 자동으로 만들어준다</p>\n<ul>\n<li>주 생성자에서 정의된 각각의 속성에 접근할 수 있는 특별한 메서드를 지원한다</li>\n<li><code>componentN()</code> → <code>component1(), component2()...</code>\n<ul>\n<li>순서에 기반해 접근...</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-java\">data class Task(val id: Int, val name: String)\nval task = Task(1, \"첫번째 태스크\")\nvar copyTask = task.copy()\n\nvar (id, _) = task\nprintln(task.component1()) // 1\nprintln(task.component2()) // 첫번째 태스크\n</code></pre>\n<ul>\n<li>copy하면 복사된 인스턴스가 생기지만 얕은 복사로 이뤄진다\n<ul>\n<li>immutable 해야하는 이유!</li>\n</ul>\n</li>\n<li>데이터 클래스는 구조분해를 이용할 수 있다\n<ul>\n<li>주 생성자가 만든 속성과 동일한 순서로 구조분해해야한다</li>\n<li>순서에 기반한 구조분해...</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h1>\n<ul>\n<li>코틀린의 객체지향 프로그래밍 지원</li>\n<li>생성자, getter, setter를 생성해주며 <code>보일러플레이트 코드를 최소화</code>한다</li>\n<li>컴패니언 객체 > 클래스 멤버 > 인스턴스 멤버</li>\n<li>싱글톤 구현 지원</li>\n<li>데이터 자체에 집중해야 하는 경우 데이터 클래스를 구조분해하여 접근</li>\n<li>제네릭 클래스로 타입 안정성 향상</li>\n</ul>\n<h1 id=\"\" style=\"position:relative;\"><a href=\"#\" aria-label=\" permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🚨?!?!?</h1>\n<hr>\n<h1 id=\"-더-알아보기\" style=\"position:relative;\"><a href=\"#-%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0\" aria-label=\" 더 알아보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🙈 더 알아보기</h1>\n<ul>\n<li><strong>static</strong>\n<ul>\n<li>모든 인스턴스에서 공통적으로 사용해야하는 경우 static으로 사용한다</li>\n<li>컴패니언 객체와 다르다고 하는데 컴패니언도 위의 예시에서 확인한 것처럼</li>\n<li>여러 인스턴스를 생성해도 같은 컴패니언 객체를 바라보고 있다</li>\n<li><code>static 아닌가?!</code></li>\n<li><a href=\"https://www.bsidesoft.com/8187\">참고: 컴패니언과 static</a></li>\n<li>컴패니언은 static을 대체하는 용도로 사용할 수 있는 것 같다</li>\n</ul>\n</li>\n<li><strong>inline class</strong>\n<ul>\n<li>프리미티브 타입 대명사 버전???</li>\n<li><code>fun login(id: Id, pw: Password)</code>\n<ul>\n<li>아이디의 타입은 Id 이고 패스워드의 타입은 Password이다</li>\n</ul>\n</li>\n<li>좀 더 명확하게 전달하고자 쓰는건가</li>\n</ul>\n</li>\n</ul>","frontmatter":{"slug":"/blog/kotlin-study-ch7","date":"2021년 4월 29일","title":"보일러플레이트 없는 코틀린의 클래스","subtitle":"Chapter 07 객체와 클래스","tags":["코틀린","스터디","kotlin"]}}},"pageContext":{"id":"3b401d76-de28-5394-a79a-8051ac6f4141","frontmatter__slug":"/blog/kotlin-study-ch7","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["3000541721","3293771174"],"slicesMap":{}}