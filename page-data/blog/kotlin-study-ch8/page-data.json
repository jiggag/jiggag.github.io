{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/kotlin-study-ch8/","result":{"data":{"markdownRemark":{"html":"<pre><code class=\"language-markdown\">[참고 도서]\n- 다재다능 코틀린 프로그래밍\n</code></pre>\n<h1 id=\"클래스\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스</h1>\n<ul>\n<li>객체지향 프로그래밍은 추상화 개념을 바탕으로 한다</li>\n<li>클래스는 다른 클래스의 추상화에 연결되어 있다</li>\n<li>코틀린은 추상화와 상속 과정이 간단하다</li>\n<li>인터페이스를 만들고 중첩클래스와 내부클래스를 정의하고 상속을 사용한다</li>\n<li>인터페이스는 명세에 따라 제공되고, 클래스는 그 명세를 구현하며, 추상 클래스로 재사용할 수 있다</li>\n<li>클래스를 sealed로 정의하여 확장할 수 있는 클래스를 제한한다</li>\n</ul>\n<h1 id=\"인터페이스와-추상-클래스\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%99%80-%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"인터페이스와 추상 클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터페이스와 추상 클래스</h1>\n<h2 id=\"인터페이스\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\"인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터페이스</h2>\n<ul>\n<li>\n<p>인터페이스 안에 컴패니언 객체를 작성하여 static 메서드를 가질 수 있다</p>\n</li>\n<li>\n<p>인터페이스를 상속하여 클래스에서 구현된 메서드를 가져오도록 한다</p>\n<pre><code class=\"language-kotlin\">class TV {\n  var volume = 0\n}\nclass TVRemote(val tv: TV): Remote {\n  override fun up() { tv.volume++ }\n  override fun down() { tv.volume-- }\n}\n\nval tv = TV()\nval remote: Remote = TVRemote(tv)\nremote.doubleUp()\nremote.down()\nremote.up()\nprintln(tv.volume) // 2\n</code></pre>\n<ol>\n<li><code>up, down</code> 처럼 추상 메서드는 인터페이스에 정의만 한다</li>\n<li><code>doubleUp</code> 처럼 구현된 메서드는 클래스와 유사하지만 추가적인 문법이나 인자가 없다</li>\n<li>인터페이스를 구현하는 클래스는 추상 메서드를 오버라이드 해야한다\n<ul>\n<li><code>doubleUp</code> 처럼 구현된 메서드는 구현하지 않아도 된다</li>\n<li><code>class TVRemote(val tv: TV): Remote</code> 형태로 TVRemote가 Remote 인터페이스를 구현한다는 것을 명시하였다 (리턴타입 아닌가ㅜㅜ)</li>\n</ul>\n</li>\n</ol>\n<p>⇒ <code>doubleUp</code> 을 override하지 않았음에도 호출할 수 있다</p>\n</li>\n<li>\n<p>인터페이스 안에 static 메서드를 작성할 수 없다</p>\n<ul>\n<li>\n<p>컴패니언 객체를 사용한다</p>\n<pre><code class=\"language-kotlin\">interface Remote {\n  fun up()\n  fun down()\n  fun doubleUp() {\n    up()\n    up()\n  }\n\n  companion object {\n    fun combine(first: Remote, second: Remote): Remote = object: Remote {\n      override fun up() {\n        first.up()\n        second.up()\n      }\n\n      override fun down() {\n        first.down()\n        second.down()\n      }\n    }\n  }\n}\n\nval tv = TV()\nval remote: Remote = TVRemote(tv)\nval another = TV()\nval anotherRemote = TVRemote(another)\nval combinedRemote = Remote.combine(remote, anotherRemote)\ncombinedRemote.up()\ncombinedRemote.down()\ncombinedRemote.doubleUp()\nprintln(\"${another.volume} ${tv.volume}\") // 2 2\n</code></pre>\n<ul>\n<li>인터페이스 안에 컴패니언 객체를 사용해 override한다</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>인터페이스를 구현할 때에는 모든 추상 메서드를 구현해야한다</p>\n<ul>\n<li>여러개의 인터페이스를 구현하는 경우 이름이 겹치는 메서드를 포함해 모든 메서드를 구현해야한다??!?</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"추상-클래스\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"추상 클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추상 클래스</h2>\n<ul>\n<li>\n<p><code>abstract</code> 로 시작하는 추상 클래스, 추상 메서드를 구현한다</p>\n<pre><code class=\"language-kotlin\">abstract class Musician(val name: String, val activeFrom: Int) {\n  abstract fun instrumentType(): String\n}\nclass Cellist(name: String, activeFrom: Int): Musician(name, activeFrom) {\n  override fun instrumentType(): String = \"String\"\n}\nval ma = Cellist(\"이름\", 2021)\nprintln(\"${ma.name} ${ma.activeFrom}\")\n</code></pre>\n<ul>\n<li><code>abstract fun instrumentType(): String</code></li>\n<li>추상 클래스에서 구현되지 않은 추상 메서드 표시</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"인터페이스-vs-추상-클래스\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-vs-%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"인터페이스 vs 추상 클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터페이스 vs 추상 클래스</h2>\n<ul>\n<li>클래스는 여러 개의 인터페이스는 구현할 수 있다\n<ul>\n<li>여러개를 받으니깐 인터페이는 상태 필드를 갖고 있을 수 없다</li>\n</ul>\n</li>\n<li>추상 클래스는 한번에 하나씩만 구현한다\n<ul>\n<li>하나만 구현하니깐 필드를 가질 수 있다 → 이름이 겹칠일이 없어서!</li>\n</ul>\n</li>\n<li>따라서 여러 클래스 사이에서 상태를 다시 이용해야 한다면 추상 클래스를 사용하는 것이 좋다\n<ul>\n<li>공통 상태를 구현할 수 있다</li>\n</ul>\n</li>\n<li>각각의 클래스에서 구현되지만 공통 요구사항이 있는 경우 인터페이스를 활용한다\n<ul>\n<li>유연한 구현</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"중첩된-내부-클래스\" style=\"position:relative;\"><a href=\"#%EC%A4%91%EC%B2%A9%EB%90%9C-%EB%82%B4%EB%B6%80-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"중첩된 내부 클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>중첩된 내부 클래스</h1>\n<h2 id=\"내부-클래스\" style=\"position:relative;\"><a href=\"#%EB%82%B4%EB%B6%80-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"내부 클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>내부 클래스</h2>\n<pre><code class=\"language-kotlin\">class TV {\n  private var volume = 0\n  val remote: Remote\n  get() = TVRemote()\n\n  override fun toString(): String = \"volume: ${volume}\"\n  inner class TVRemote: Remote {\n    override fun up() { volume++ }\n    override fun down() { volume++ }\n    override fun toString(): String = \"remote: ${this@TV.toString()}\"\n  }\n}\n\nvar tv = TV()\nval remote = tv.remote\nprintln(\"$tv\") // volume: 0\nremote.up()\nprintln(\"$tv\") // volume: 1\nremote.doubleUp()\nprintln(\"$tv\") // volume: 3\nprintln(remote) // remote: volume: 3\n</code></pre>\n<ul>\n<li><code>class TV</code> 안에 중첩된 <code>inner class TVRemote</code> 에서는 TV의 private 속성인 volume에 접근할 수 있다\n<ul>\n<li>클로저?</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"익명-내부-클래스\" style=\"position:relative;\"><a href=\"#%EC%9D%B5%EB%AA%85-%EB%82%B4%EB%B6%80-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"익명 내부 클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>익명 내부 클래스</h2>\n<pre><code class=\"language-kotlin\">class TV {\n  private var volume = 0\n  val remote: Remote get() = object: Remote {\n    override fun up() { volume++ }\n    override fun down() { volume++ }\n    override fun toString(): String = \"remote: ${this@TV.toString()}\"\n  }\n\n  override fun toString(): String = \"volume: ${volume}\"\n}\n</code></pre>\n<ul>\n<li>중첩된 내부 클래스 대신 익명 내부 클래스로 생성할 수 있다</li>\n</ul>\n<h1 id=\"상속\" style=\"position:relative;\"><a href=\"#%EC%83%81%EC%86%8D\" aria-label=\"상속 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상속</h1>\n<ul>\n<li>의도대로 클래스가 동작하도록 <code>의도치 않은 베이스 클래스로의 사용을 제한하고자 권한을 명시</code>적으로 제공한다\n<ul>\n<li>자식 클래스가 해당 메소드를 오버라이드하는 것이 가능하도록 명시한다</li>\n</ul>\n</li>\n<li>코틀린의 클래스는 기본이 <code>final</code>이다\n<ul>\n<li>기본적으로는 상속이 불가능하다</li>\n<li><code>open</code>이라고 명시해주어야만 상속할 수 있다\n<ul>\n<li>interface, abstract랑은 애초에 다르다..!</li>\n</ul>\n</li>\n<li><code>final override</code> 라고 해버리면 그 이후 자식클래스에서는 해당 메서드를 오버라이드 할 수 없다</li>\n</ul>\n</li>\n<li>리턴타입과 헷갈리게도 동일하게도\n<ul>\n<li><code>class 자식클래스(): 부모클래스</code></li>\n<li>상속받을 클래스를 명시한다</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"메서드-오버라이드\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EC%84%9C%EB%93%9C-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%93%9C\" aria-label=\"메서드 오버라이드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메서드 오버라이드</h2>\n<pre><code class=\"language-kotlin\">open class Vehicle(val year: Int, open var color: String) {\n  open val km = 0\n  final override fun toString(): String = \"이건 override 불가능 ${year}, ${color}, ${km}\"\n  fun repaint(newColor: String) {\n    color = newColor\n  }\n}\nopen class Car(year: Int, color: String): Vehicle(year, color) {\n  override var km: Int = 0\n  set(value) {\n    if (value &#x3C; 1) {\n      throw RuntimeException(\"1보다 커야합니다\")\n    }\n    field = value\n  }\n\n  fun drive(distance: Int) {\n    km += distance\n  }\n}\n\nval car = Car(2021, \"파랑\")\nprintln(car) // 이건 override 불가능 2021, 파랑, 0\ncar.drive(200)\nprintln(car) // 이건 override 불가능 2021, 파랑, 200\ncar.repaint(\"빨강\")\nprintln(car) // 이건 override 불가능 2021, 빨강, 200\n</code></pre>\n<ol>\n<li><code>Vehicle</code> 클래스의 <code>repaint</code> 메서드는 open이 명시되지 않아 <code>final</code>이다</li>\n<li><code>Vehicle</code> 클래스의 <code>toString</code> 은 <code>final override</code>로 명시되어 자식 클래스에서 오버라이드 할 수 없다</li>\n<li>자식 클래스 <code>Car</code> 에서 <code>km</code> 을 오버라이드 하였다</li>\n<li><code>println(car)</code> 의 toString은 Vehicle의 toString으로 오버라이드 하지는 못하지만 호출은 할 수 있다</li>\n</ol>\n<h2 id=\"파라미터-오버라이드\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%93%9C\" aria-label=\"파라미터 오버라이드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파라미터 오버라이드</h2>\n<pre><code class=\"language-kotlin\">class FamilyCar(year: Int, color: String): Car(year, color) {\n  override var color: String\n  get() = super.color\n  set(value) {\n    super.color = value\n  }\n}\n</code></pre>\n<ul>\n<li>getter, setter 모두 override해서 부모 color를 가져오고 변경한다</li>\n</ul>\n<h2 id=\"제약사항\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%EC%95%BD%EC%82%AC%ED%95%AD\" aria-label=\"제약사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제약사항</h2>\n<ul>\n<li>오버라이딩 접근 권한에 관한 제약사항</li>\n<li>부모의 public을 자식이 private, protected로 만들 수 없다\n<ul>\n<li>부모가 공개하겠다고 한걸 자식이 숨길 수 없지!</li>\n</ul>\n</li>\n<li>부모의 private, protected를 자식이 public으로 느슨하게 할 수 있다\n<ul>\n<li>부모가 비공개로 막았지만 자식이 이제 공개하겠습니다!</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"sealed-클래스\" style=\"position:relative;\"><a href=\"#sealed-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"sealed 클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>sealed 클래스</h1>\n<ul>\n<li><code>final 클래스</code>\n<ul>\n<li>open으로 표기되어 있지 않아 자식클래스가 하나도 없는 클래스</li>\n</ul>\n</li>\n<li><code>open, abstract 클래스</code>\n<ul>\n<li>자식, 자식, 자식</li>\n<li>어떤 클래스가 상속받았는지 알 수 없다</li>\n</ul>\n</li>\n<li><code>sealed 클래스</code>\n<ul>\n<li>클래스를 생성할 때 어떤 클래스만 상속 가능하다고 제한한다</li>\n<li>동일한 파일에 작성된 다른 클래스들에게만 확장이 가능하다</li>\n<li><code>sealed 클래스의 생성자는 private 표기하지 않아도 private으로 취급된다</code></li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-kotlin\">sealed class Card(val suit: String)\nclass Ace(suit: String): Card(suit)\nclass Kink(suit: String): Card(suit) {\n\toverride fun toString() = \"왕\"\n}\n\nfun process(card: Card) = when (card) {\n\tis Ace -> \"ace\"\n\tis Kink -> \"king\"\n}\n</code></pre>\n<ol>\n<li>여러 자식 클래스가 상속받았다</li>\n<li>sealed 클래스를 when 구문에서 else로 처리하면 안된다\n<ul>\n<li>자식 클래스를 제한해두었는데 else로 처리하면 제한되지 않은 인스턴스가 들어온 경우(?)에 대해 확인할 수 없다</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"enum\" style=\"position:relative;\"><a href=\"#enum\" aria-label=\"enum permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Enum</h1>\n<ul>\n<li>\n<p>해당 클래스의 인스턴스 속성을 참조하여 열거</p>\n</li>\n<li>\n<p><code>enum class Suit { KING, ACE }</code></p>\n</li>\n<li>\n<p>enum 클래스는 상태와 메서드를 가질 수 있다</p>\n<pre><code class=\"language-kotlin\">enum class Suit(val symbol: String) {\n  KING(\"king\") {\n    override fun display() = \"${super.display()} $symbol\"\n  };\n  open fun display() = \"$symbol $name\"\n}\n\nfor (suit in Suit.values()) {\n  println(suit.display()) // king KING king\n}\n</code></pre>\n</li>\n</ul>\n<h1 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h1>\n<ul>\n<li>default 키워드가 없다</li>\n<li>인터페이스에서도 static 메서드를 컴패니언 객체로 사용한다</li>\n<li>클래스의 디폴트는 final이다</li>\n<li>모든 open 클래스가 상속 가능한 것은 아니다</li>\n<li>sealed 클래스를 사용해 상속을 제한할 수 있다\n<ul>\n<li>상속에 제약을 줘서 의도치 않게 사용되는 일이 없다</li>\n</ul>\n</li>\n<li>enum 클래스 인스턴스는 static 멤버로 생성된다\n<ul>\n<li>타입 세이프하게 사용할 수 있다</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"\" style=\"position:relative;\"><a href=\"#\" aria-label=\" permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🚨?!?!?</h1>\n<ul>\n<li><strong>인터페이스 vs 추상클래스</strong>\n<ul>\n<li>인터페이스는 여러개를 extends 할 수 있다</li>\n<li>그러나 추상클래스는 <code>extends가 하나씩만 된다!</code></li>\n<li>인터페이스와 추상클래스는 <code>open</code> 키워드가 없어도 상속받을수 있는데 이건 일반 클래스가 아니라서 그렇다...</li>\n</ul>\n</li>\n<li><strong>그럼 인터페이스를 여러개 상속 했을때 발생하는 일!</strong>\n<ul>\n<li>\n<p>이름이 겹치는 메서드는 어떻게 할까?</p>\n<pre><code class=\"language-kotlin\">interface RemoteA {\n  fun up() // 무조건 override해야 쓸 수 있음\n  fun down()\n  fun doubleUp() { // 블록형 디폴트 메서드 -> override없이 그냥 호출해서 사용할 수 있다\n    up()\n    up()\n  }\n}\ninterface RemoteB {\n  fun up()\n  fun down()\n  fun doubleUp() {\n    up()\n    up()\n  }\n}\n\nclass TV {\n  var volume = 0\n}\n\n// 1. override 하지 않은 경우\nclass TVRemote(val tv: TV): RemoteA, RemoteB {}\n>>> Class 'TVRemote' is not abstract and does not implement abstract member public abstract fun up(): Unit defined in Classstudy.RemoteA\n>>> Class 'TVRemote' must override public open fun doubleUp(): Unit defined in Classstudy.RemoteA because it inherits multiple interface methods of it\n\n// 2. 하나씩 override 한 경우\nclass TVRemote(val tv: TV): RemoteA, RemoteB {\n  override fun up() {\n    TODO(\"Not yet implemented\")\n  }\n\n  override fun down() {\n    TODO(\"Not yet implemented\")\n  }\n\n  override fun doubleUp() {\n    TODO(\"Not yet implemented\")\n  }\n}\n\n// 3. 전부 override 한 경우\nclass TVRemote(val tv: TV): RemoteA, RemoteB {\n  override fun up() {\n    TODO(\"Not yet implemented\")\n  }\n\n  override fun down() {\n    TODO(\"Not yet implemented\")\n  }\n\n  override fun up() {\n    TODO(\"Not yet implemented\")\n  }\n\n  override fun down() {\n    TODO(\"Not yet implemented\")\n  }\n\n  override fun doubleUp() {\n    TODO(\"Not yet implemented\")\n  }\n\n  override fun doubleUp() {\n    TODO(\"Not yet implemented\")\n  }\n}\n>>> Conflicting overloads: public open fun down(): Unit defined in Classstudy.TVRemote, public open fun down(): Unit defined in Classstudy.TVRemote\n</code></pre>\n<ul>\n<li>TVRemote는 메서드 이름이 동일한 RemoteA와 RemoteB 두개의 인터페이스를 상속받는다</li>\n<li>아무것도 override 하지 않은 경우 오류가 발생한다\n<ul>\n<li>이름이 같아서 어떤걸 호출해야할지 모르니깐</li>\n</ul>\n</li>\n<li>이름이 중복되는 메서드를 각각 하나씩 override하면 정상적으로 실행된다</li>\n<li>상속받은 메서드 전부 override하면 다시 오류가 발생한다</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"-더-알아보기\" style=\"position:relative;\"><a href=\"#-%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0\" aria-label=\" 더 알아보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🙈 더 알아보기</h1>\n<ul>\n<li>클래스 인터페이스\n<ul>\n<li>리턴타입처럼 클래스 뒤에 <code>class TVRemote(val tv: TV): Remote</code></li>\n<li>이것은 리턴타입이 아니라 인터페이스를 구현한다는 의미...</li>\n</ul>\n</li>\n<li>파라미터 오버라이드\n<ul>\n<li><code>class FamilyCar(year: Int, color: String): Car(year, color) {}</code>\n<ul>\n<li>여기에는 var, val이 없는데 이건 마치 인자를 그대로 전달하는듯</li>\n<li>FamilyCar: color → Car: color → Vehicle: car 까지 가는길</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"slug":"/blog/kotlin-study-ch8","date":"2021년 5월 7일","title":"클래스, 인터페이스, 상속","subtitle":"Chapter 08 클래스 계층과 상속","tags":["코틀린","스터디","kotlin"]}}},"pageContext":{"id":"a3a576ee-96e1-590d-8d93-8f5c0e645003","frontmatter__slug":"/blog/kotlin-study-ch8","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["3000541721","3293771174"]}