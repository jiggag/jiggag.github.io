{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/blog/kotlin-study-ch9/",
    "result": {"data":{"markdownRemark":{"html":"<pre><code class=\"language-markdown\">[참고 도서]\n- 다재다능 코틀린 프로그래밍\n</code></pre>\n<h1>상속과 델리게이션</h1>\n<ul>\n<li>둘 다 객체지향 프로그래밍 디자인 방식으로 클래스를 다른 클래스로부터 확장시킨다</li>\n<li>상속은 베이스 클래스에 귀속된다</li>\n<li>델리게이션은 보다 유연하게 객체 자신이 처리해야 할 일을 다른 클래스의 인스턴스에게 위임한다</li>\n</ul>\n<h1>언제 델리게이션을 써야할까</h1>\n<ul>\n<li>\n<p>상속과 델리게이션 어느 것이 더 유용할까</p>\n<ul>\n<li>클래스의 객체가 단순하게 다른 클래스의 객체를 <code>사용</code>하기만 한다면 <code>델리게이션</code></li>\n<li>클래스의 객체가 다른 클래스의 객체의 자리에 <code>대체</code>되어야한다면 <code>상속</code></li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/665babd59fb6fb8c0b0b9bcfa0cdcbea/a6ec4/delegation.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAA+0lEQVQoz3WRuYqGUAyFff93sFUstLBVwcrCXVFxA/f9Ic6QDPdHfmaKQEhuvnOSK63rCoplWXAcB/Z951zUt2375CKu6+IQvfd7iYoEep4HVVWh6zrOz/P8DJAIAUQtCAL4vs8gqt33zQzqSfM8I89zJEnCwLZtEUURwjDEMAwM6/secRyjKAoWdF0Xtm3zewrP81CW5a/DaZpgWRYMw2AwNXRdh6qqDCdlAlHfcRw0TQPTNKFpGtI0ZSOyLLMIA8VKNDiOI0ggyzKGv+8m7itysf77jrzy++iUkxtyqCgKQ2nwDf7+JAEVdem7SUq0al3X7PivX/4vyOEP2jz0FBn79j4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"delegation\"\n        title=\"delegation\"\n        src=\"/static/665babd59fb6fb8c0b0b9bcfa0cdcbea/0a47e/delegation.png\"\n        srcset=\"/static/665babd59fb6fb8c0b0b9bcfa0cdcbea/8a4e8/delegation.png 150w,\n/static/665babd59fb6fb8c0b0b9bcfa0cdcbea/5a46d/delegation.png 300w,\n/static/665babd59fb6fb8c0b0b9bcfa0cdcbea/0a47e/delegation.png 600w,\n/static/665babd59fb6fb8c0b0b9bcfa0cdcbea/1cfc2/delegation.png 900w,\n/static/665babd59fb6fb8c0b0b9bcfa0cdcbea/c1b63/delegation.png 1200w,\n/static/665babd59fb6fb8c0b0b9bcfa0cdcbea/a6ec4/delegation.png 1438w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>첫번째는 Candidate는 BaseClass를 상속받았고 Caller가 Candidate가 항상 들고 다니는 BaseClass에 접근한다\n<ul>\n<li>자식클래스(Candidate)는 부모클래스(BaseClass)의 동작을 변경할 수 없다</li>\n<li>베이스 클래스의 외부 동작을 유지해야한다</li>\n</ul>\n</li>\n<li>두번째는 Caller가 Candidate를 통해 BaseClass에 접근한다\n<ul>\n<li>상속과는 다르게 인스턴스 분리가 가능하다</li>\n<li>필요에 따라 Candidate가 BaseClass를 변경해서 요청할 수 있다</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1>델리게이션을 사용한 디자인</h1>\n<h2>상속 디자인의 문제점</h2>\n<pre><code class=\"language-kotlin\">interface Worker {\n\tfun work()\n\tfun takeVacation()\n}\n\nopen class JavaProgrammer: Worker {\n\toverride fun work() = println(\"자바 개발자가 일하는 중\")\n\toverride fun takeVacation() = println(\"자바 개발자 휴가\")\n}\nopen class KotlinProgrammer: Worker {\n\toverride fun work() = println(\"코틀린 개발자가 일하는 중\")\n\toverride fun takeVacation() = println(\"코틀린 개발자 휴가\")\n}\n\nclass Manager: JavaProgrammer()\n</code></pre>\n<ol>\n<li>\n<p>Worker 인터페이스를 구현한 각각의 클래스에서 함수를 override했다</p>\n</li>\n<li>\n<p>이들을 관리하는 새로운 클래스 Manager를 추가하고 상속받았다</p>\n</li>\n<li>\n<p><code>JavaProgrammer</code> 를 상속받은 Manager에서는 부모클래스의 메소드를 호출한다</p>\n<pre><code class=\"language-kotlin\">val java = Manager()\njava.work() // 자바 개발자가 일하는 중\n</code></pre>\n<p>⇒ 이렇게 되면 Manager는 JavaProgrammer에만 한정된다</p>\n<p>⇒ 한정된 클래스에서는 <code>KotlinProgrammer</code> 클래스도  같이 구현할 수 없다...</p>\n<p>⇒ 따라서 Manager가 모든 클래스의 인터페이스인 Worker에 의존하도록 델리게이션을 사용한다</p>\n</li>\n</ol>\n<h2>자바에서의 델리게이션을 어려웠다</h2>\n<ul>\n<li>\n<p>한정된 상속을 풀어내고나 델리게이션을 구현하였다</p>\n<pre><code class=\"language-kotlin\">class Manager(val worker: Worker) {\n\tfun work() = worker.work()\n\tfun takeVacation() = worker.takeVacation()\n}\n\nval java = Manager(JavaProgrammer())\njava.work() // 자바 개발자가 일하는 중\n</code></pre>\n<ol>\n<li>델리게이션하려는 대상 인스턴스를 생성자로 전달하였다</li>\n<li>그리고 그 인스턴스의 메소드를 각각 다시 구현하였다</li>\n</ol>\n<p>⇒ 인자로 전달받은 인스턴스를 호출하므로써 한정적이지 않지만 각각의 메소드를 직접 구현해주어야한다</p>\n<ul>\n<li>Worker에 메소드가 추가된다면 Manager에서 해당 메소드 호출을 위해 한번 더 추가 구현작업이 필요하다\n<ul>\n<li>중복된 메소드 호출, DRY, OCP 원칙 위반</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>코틀린의 by 델리게이션</h2>\n<ul>\n<li>\n<p>자바와는 다르게 <code>코틀린 컴파일러가 델리게이션 코드를 직접 요청</code>하도록 할 수 있다</p>\n<ul>\n<li>추가되는 메소드를 각각 다시 추가할 필요가없다</li>\n</ul>\n<pre><code class=\"language-kotlin\">class Manager(): Worker by JavaProgrammer()\n</code></pre>\n<ol>\n<li>\n<p>Manager는 아무런 메소드도 갖고 있지 않다</p>\n</li>\n<li>\n<p>JavaProgrammer을 이용해 Worker 인터페이스를 구현한 Manager</p>\n</li>\n<li>\n<p>Manager의 메소드는 by 키워드가 컴파일 시간에 델리게이션을 대신 해준다</p>\n</li>\n<li>\n<p>여기서 <code>Manager는 델리게이션 했을뿐 타입이 JavaProgrammer인 것이 아니다</code></p>\n<pre><code class=\"language-kotlin\">val person: JavaProgrammer = Manager() // Error: Type mismatch.\n</code></pre>\n</li>\n</ol>\n</li>\n<li>\n<p><code>코틀린의 델리게이션을 사용하면 컴파일러가 내부적으로 메소드를 생성하고 요청한다</code></p>\n<ul>\n<li>코틀린 컴파일러에 의해 메소드가 합성되었고 델리게이션에게 호출을 요청하는 것이다</li>\n</ul>\n</li>\n</ul>\n<h1>파라미터 위임</h1>\n<h2>기존의 델리게이션에서의 단점</h2>\n<pre><code class=\"language-kotlin\">class Manager(): Worker by JavaProgrammer()\n</code></pre>\n<ol>\n<li>Manager 인스턴스가 JavaProgrammer 인스턴스로 델리게이트 한다\n<ul>\n<li>Manager는 무조건 JavaProgrammer로만 요청할 수 있기에 다른 종류의 Worker 인터페이스를 구현한 클래스(ex. KotlinProgrammer)에게는 요청할 수 없다</li>\n</ul>\n</li>\n<li><code>**Manager 인스턴스는 델리게이션에 접근 할 수 없다**</code>\n<ul>\n<li>Manager 클래스 안에 다른 메소드를 작성하여도 해당 메소드에서는 델리게이션을 통한 메소드 호출을 할 수 없다</li>\n</ul>\n</li>\n</ol>\n<h2>델리게이션 생성자 파라미터</h2>\n<ul>\n<li>\n<p>기존의 델리게이션 단점들을 해결하기 위해 <code>생성자로 델리게이션 파라미터</code>를 전달한다</p>\n<pre><code class=\"language-kotlin\">class Manager(val staff: Worker): Worker by staff {\n\tfun meeting() = println(\"회의 ${staff.javaClass.simpleName}\")\n}\n\nval java = Manager(JavaProgrammer())\njava.work() // 자바 개발자가 일하는 중\njava.meeting() // 회의 JavaProgrammer\n</code></pre>\n<ul>\n<li>생성자 파라미터 <code>staff</code> 를 by 키워드로 델리게이션 한다</li>\n<li>Manager 클래스의 meeting 메소드가 추가되었다</li>\n<li>이 메소드에서는 staff 파라미터를 통해 델리게이션 인스턴스의 메소드를 호출 할 수 있게 되었다\n<ul>\n<li>델리게이션의 유연함</li>\n<li>Manager에 추가 구현하지 않은 work 메소드를 호출하면 델리게이션 인스턴스의 work 메소드가 호출되고 추가 구현된 meeting 메소드를 호출하면 Manager 인스턴스의 메소드가 호출된다</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1>메소드 충돌 관리</h1>\n<ul>\n<li>만약 델리게이션을 사용하는 클래스와 델리게이션 클래스에 동일한 이름의 메소드가 있다면?\n<ul>\n<li>코틀린 상속에서 이런 상황을 해결하였다</li>\n<li>이름이 같은 메소드를 각각 하나씩 재구현해주었다</li>\n</ul>\n</li>\n<li>코틀린 컴파일러가 <code>델리게이션 클래스의 모든 인터페이스를 위한 랩퍼</code>를 만든다\n<ul>\n<li>컴파일러가 메소드 요청을 할 수 있게 해주는 기능</li>\n</ul>\n</li>\n<li>델리게이션 클래스의 메소드를 이용하려는 클래스에서 다시 구현하려는 경우 <code>override 키워드</code>를 사용한다\n<ul>\n<li>\n<p>구현한 메소드에 우선순위를 주고 컴파일러가 해당 메소드에 대해 델리게이션 클래스의 랩퍼 메소드를 생성하지 않는다</p>\n<pre><code class=\"language-kotlin\">class Manager(val staff: Worker): Worker by staff {\n\toverride fun takeVacation() = println(\"특별휴가주기\")\n}\n</code></pre>\n<ol>\n<li>override를 사용해 해당 메소드가 델리게이션된 메소드가 아니라 인터페이스의 메소드를 직접 구현했다는 것을 명확하게 전달한다</li>\n<li>코틀린 컴파일러가 Worker 인터페이스의 work 랩퍼 메소드만 생성할 것이다</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h1>델리게이션 주의사항</h1>\n<ul>\n<li>\n<p>상속과는 다르게 델리게이션은 기존 클래스를 대체할 수 없다</p>\n<ul>\n<li>Manager는 JavaProgrammer 인스턴스를 가지고 있을뿐 JavaProgrammer의 한 종류가 아니다</li>\n<li>델리게이션 인스턴스는 인터페이스 그 자체의 한종류이다</li>\n<li><code>val manager: Worker = Manager()</code>\n<ul>\n<li>이는 델리게이션의 부작용인데 Manager가 Worker를 이용만 해야하는데 Worker로 취급되버린다...</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>생성자를 mutable로 정의하면 인스턴스와 델리게이션 참조가 다른 상황이 발생한다</p>\n<pre><code class=\"language-kotlin\">class Manager(var staff: Worker): Worker by staff {\n  fun meeting() = println(\"회의 ${staff.javaClass.simpleName}\")\n}\n\nval java = Manager(JavaProgrammer())\njava.work() // 자바 개발자가 일하는 중\njava.meeting() // 회의 JavaProgrammer\njava.staff = KotlinProgrammer()\njava.work() // 자바 개발자가 일하는 중\njava.meeting() // 회의 KotlinProgrammer\n</code></pre>\n<ol>\n<li>Manager의 델리게이션를 전달하는 생성자를 var로 정의했다</li>\n<li>처음에는 의도대로 JavaProgrammer로 동작한다</li>\n<li><code>java.staff = KotlinProgrammer()</code> 뮤터블한 생성자 필드를 변경해버렸다</li>\n<li>생성자를 변경했으니깐 델리게이션 메소드를 호출하는 <code>java.work()</code> 에서도 Kotlin이 나올것이라 기대했지만 Java가 나왔다</li>\n<li>델리게이션 메소드가 아닌 직접 구현한 메서드에서 호출한 staff에는 Kotlin이 나왔다</li>\n</ol>\n<p>⇒ 생성자를 변경한 것은 내부적으로 <code>this.staff = staff</code> 처럼 백킹 필드를 변경했을뿐이다</p>\n<p>⇒ 델리게이션 메소드는 처음 만들어진 그대로를 참조하고 있다</p>\n<p>⇒ 현재 Manager에서는 JavaProgrammer와 KotlinProgrammer 둘 다 사용중이다</p>\n</li>\n</ul>\n<h1>변수와 속성 델리게이션</h1>\n<h2>변수 델리게이션</h2>\n<ul>\n<li>\n<p>클래스가 아니라 변수 자체를 델리게이션 할 수 있다</p>\n<pre><code class=\"language-kotlin\">// 델리게이션 클래스\npackage 패키지경로\nimport kotlin.reflect.KProperty\n\nclass Delegation(var content: String) {\n  operator fun getValue(thisRef: Any?, property: KProperty&#x3C;*>) = \"$content 에 이걸 더해서 가져오기\"\n  operator fun setValue(thisRef: Any, property: KProperty&#x3C;*>, value: String) {\n    println(\">>> property ${property.name}\") // yourName\n    content = value\n  }\n}\n\n// 사용하는 곳\nimport 패키지경로.Delegation\n\nvar yourName: String by Delegation(\"이 값을 델리게이션\")\nprintln(yourName) // 이 값을 델리게이션 에 이걸 더해서 가져오기\nyourName = \"변경\"\nprintln(yourName) // 변경 에 이걸 더해서 가져오기\n</code></pre>\n</li>\n<li>\n<p>델리게이션 인스턴스를 통해 변수를 델리게이션해서 사용할 수 있게 되었다</p>\n</li>\n</ul>\n<h2>속성 델리게이션</h2>\n<ul>\n<li>\n<p>객체의 속성값에도 델리게이션을 사용할 수 있다</p>\n</li>\n<li>\n<p>기존 데이터를 파라미터로 받아서 속성값에 주는 델리게이션 인스턴스 인자로 넘겨주고 델리게이션이 반환하는 값이 속성이 된다</p>\n<pre><code class=\"language-kotlin\">class PostComment(dataSource: MutableMap&#x3C;String, Any>) {\n  val title: String by dataSource\n}\nvar data = PostComment(mutableMapOf(\n  \"title\" to \"이름\"\n))\n</code></pre>\n</li>\n<li>\n<p>객체 전체를 델리게이션 하지 않아도 부분적으로 속성만 위임할 수 있다</p>\n</li>\n</ul>\n<h1>빌트인 스탠다드 델리게이션</h1>\n<ul>\n<li>지연 델리게이션으로 객체의 생성이나 연산 실행이 실제 필요한 순간까지 지연시킨다</li>\n<li>observable 델리게이션은 속성의 값이 변경되는 순간을 지켜보고 있다가 핸들링 할 수 있다</li>\n<li>vatoable 델리게이션은 속성의 값을 변경 요청하는 순간을 핸들링하여 실제로 값의 변경을 허락 또는 거절 할 수 있다</li>\n</ul>\n<h2>위임을 지연시키는 lazy</h2>\n<ul>\n<li>\n<p>실제로 사용되지 않는 순간임에도 불필요하게 연산되는 것을 방지하고자 사용한다</p>\n</li>\n<li>\n<p>결과가 정말 필요할때 실행해서 가져온다</p>\n<pre><code class=\"language-kotlin\">var value by lazy { getValue() }\n\nif (false &#x26;&#x26; value) {\n\t...\n}\n</code></pre>\n<ol>\n<li>value를 지연시켜두었다</li>\n<li>value를 사용하는 조건문이 항상 false이므로 지연된 value는 항상 실행되지 않는다</li>\n</ol>\n</li>\n<li>\n<p><code>by lazy { 람다 함수 }</code></p>\n<ul>\n<li>lazy 함수는 람다 표현식의 실행과 <code>동기화</code> 된다</li>\n</ul>\n</li>\n</ul>\n<h2>변경을 감지하는 observable()</h2>\n<ul>\n<li>\n<p>변수나 속성의 변화를 가로채서 observable이 등록한 이벤트 핸들러를 호출한다</p>\n<ul>\n<li>핸들러를 호출할 뿐 아무것도 리턴하지 않는다</li>\n<li>Unit, void</li>\n</ul>\n<pre><code class=\"language-kotlin\">var count by Delegates.observable(0) { property, oldValue, newValue ->\n  println(\"property: ${property}, old: ${oldValue}, new: ${newValue}\")\n}\nprintln(count)\ncount++\nprintln(count)\n\n>>>\n0\nproperty: var Delegate.count: kotlin.Int, old: 0, new: 1\n1\n</code></pre>\n<ol>\n<li>변경을 감지하고자하는 변수 count에 observable 델리게이션을 사용하였다</li>\n<li>0 으로 초기화하였고 count가 변경되자 등록한 핸들러가 실행되었다</li>\n</ol>\n</li>\n<li>\n<p>모니터링, 디버깅에 유용하다</p>\n</li>\n</ul>\n<h2>변경을 거부하는 vetoable()</h2>\n<ul>\n<li>\n<p>observable과 유사하지만 다르다</p>\n</li>\n<li>\n<p>변수나 속성의 변화를 가로채서 핸들러를 실행하고 Boolean을 반환한다</p>\n<ul>\n<li>true이면 변화를 허용한다</li>\n<li>false이면 값은 변경되지 않는다</li>\n</ul>\n<pre><code class=\"language-kotlin\">var count by Delegates.vetoable(0) { _, oldValue, newValue -> newValue > oldValue }\nprintln(count)\ncount--\nprintln(count)\ncount++\nprintln(count)\n\n>>>\n0\n0\n1\n</code></pre>\n<ol>\n<li>count를 변경하려고하자 핸들러가 실행되었다</li>\n<li>조건문을 실행하여 true/false에 따라 값이 변경되었다</li>\n</ol>\n</li>\n<li>\n<p>특정 규칙에 따라 변화를 허용하고자 하는 경우 사용한다</p>\n</li>\n</ul>\n<h1>마무리</h1>\n<ul>\n<li>상속보다는 델리게이션을 사용해 더 유연한 객체지향 프로그래밍</li>\n<li>by 키워드를 통한 코틀린의 델리게이션\n<ul>\n<li>객체 호출</li>\n<li>지역변수, 속성에 대한 접근, 변경</li>\n</ul>\n</li>\n</ul>\n<h1>🚨?!?!?</h1>\n<ul>\n<li>\n<p><strong>상속</strong></p>\n<ul>\n<li>\n<p><code>class Manager: JavaProgrammer()</code> 한정되는 인스턴스</p>\n</li>\n<li>\n<p>다른 클래스들을 여러개 상속 받을 수 없을까</p>\n</li>\n<li>\n<p>응 안된다</p>\n<pre><code class=\"language-kotlin\">class Manager: JavaProgrammer(), KotlinProgrammer()\n// Only one class may appear in a supertype list\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>by 키워드</strong></p>\n<ul>\n<li><code>class Manager(): Worker by JavaProgrammer()</code></li>\n<li>마치 타입 같은데?</li>\n<li>상속과 비슷해보이는데?</li>\n<li>Worker 인터페이스를 구현한 <code>JavaProgrammer</code> 를 델리게이션했다는 것은 어떻게 보면 <code>class Manager: JavaProgrammer()</code> 상속과 같아보인다...</li>\n<li>그러나 델리게이션한 인스턴스 Manager의 타입은 JavaProgrammer가 아님을 위에서 확인했다</li>\n<li>상속이라면 결국 JavaProgrammer에만 한정적으로 되어버리는데 델리게이션이기에 한정되지 않고 유연해진다</li>\n</ul>\n</li>\n<li>\n<p><strong>파라미터</strong></p>\n<ul>\n<li>코틀린은 파라미터에 있는 변수를 바로 사용 할 수 있어서...</li>\n<li><code>class Name(val staff: String): Worker by staff</code></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1>🙈 더 알아보기</h1>\n<ul>\n<li><strong>속성 델리게이션</strong>\n<ul>\n<li>\n<p><code>val title: String by dataSource</code></p>\n</li>\n<li>\n<p>title이 dataSource를 델리게이션</p>\n</li>\n<li>\n<p>by 키워드를 따라가보면 내부적으로 <code>property.name</code> 이 불리고 있다😱</p>\n<pre><code class=\"language-kotlin\">@kotlin.jvm.JvmName(\"getVar\")\n@kotlin.internal.InlineOnly\npublic inline operator fun &#x3C;V, V1 : V> MutableMap&#x3C;in String, out @Exact V>.getValue(thisRef: Any?, property: KProperty&#x3C;*>): V1 =\n    @Suppress(\"UNCHECKED_CAST\") (getOrImplicitDefault(property.name) as V1)\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"slug":"/blog/kotlin-study-ch9","date":"2021년 5월 12일","title":"코틀린 델리게이션"}}},"pageContext":{"id":"311bfb74-a651-599a-9f18-82a079056e09","frontmatter__slug":"/blog/kotlin-study-ch9","__params":{"frontmatter__slug":"blog"}}},
    "staticQueryHashes": ["3000541721","3293771174"]}