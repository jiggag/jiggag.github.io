{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/blog/monthly-log/2019-10/",
    "result": {"data":{"markdownRemark":{"html":"<h4>10/27 - 11/2</h4>\n<h4><code>Memoization</code></h4>\n<ul>\n<li>React.memo\n<ul>\n<li>Memoization</li>\n<li>Component</li>\n<li><code>React.memo(({ value }) => { /* value가 변경되면 render */ })</code></li>\n</ul>\n</li>\n<li>React.useMemo\n<ul>\n<li>Memoization</li>\n<li>Value</li>\n<li><code>React.useMemo(() => { /* value가 변경되면 render */ }, [value])</code></li>\n</ul>\n</li>\n<li>React.useCallback\n<ul>\n<li>Memoization</li>\n<li>Function</li>\n<li><code>React.callback(() => { /* value가 변경되면 호출 */ }, [value])</code></li>\n</ul>\n</li>\n<li>메모이제이션하는 대상, 목표가 다른듯 목적은 동일해 보인다. 그렇다면 과연 재사용하는 모든 값, 컴포넌트, 함수에 메모이제이션을 적용하는게 좋을까? <a href=\"https://rinae.dev/posts/review-when-to-usememo-and-usecallback\">번역: 언제 useMemo와 useCallback을 사용하는가</a> 해당 블로그를 읽고 고민이 생겼고 작성해둔 코드를 지웠다가 다시 그려보며 생각해본다. 과연 이게 꼭 필요한 메모이제이션일까.</li>\n</ul>\n<h4><code>Redux saga</code></h4>\n<ul>\n<li>Action type\n<ul>\n<li><code>Request</code></li>\n<li><code>Success</code></li>\n<li><code>Failure</code></li>\n<li>액션 타입별로 3가지 종류 선언 > 반복 > createAction 함수 사용</li>\n</ul>\n</li>\n<li>Effect\n<ul>\n<li><code>take</code>-<code>fork</code>: while 계속 take 해둔 액션을 대기하다가 들어오면 fork 집어둔 내용 실행</li>\n<li><code>take</code>: 해당 액션 호출 대기</li>\n<li><code>fork</code>: 해당 액션 실행 대기</li>\n<li><code>takeEvery</code>: 모든 액션 실행</li>\n<li><code>takeLatest</code>: 마지막 액션만 실행</li>\n<li><code>put</code>: 액션 함수 실행</li>\n<li><code>call</code>: api 실행</li>\n<li><code>select</code>: saga state 호출</li>\n</ul>\n</li>\n</ul>\n<h4><code>Redux vs Mobx</code></h4>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=sBda75wojt4&#x26;list=PLcqDmjxt30Rv-M6nWVS6xRABBYpjYyt-O&#x26;index=1\">제로초님의 유튜브 강의</a></li>\n</ul>\n<h2></h2>\n<h4>10/20 - 10/26</h4>\n<h4><code>Container Presenter Pattern</code></h4>\n<ul>\n<li>Container와 Presenter로 분리하여 작업(index, container, presenter, style)</li>\n<li>Container: redux state를 제어하는 컴포넌트(smart component)</li>\n<li>Component: 단순 props로 제어하는 컴포넌트(dumb component)</li>\n<li>Container -> Component -> Presenter -> Action -> Container 반복</li>\n<li><a href=\"https://www.zerocho.com/category/React/post/57e1428c11a9b10015e803aa\">참고: Container와 Component</a></li>\n</ul>\n<h4><code>Ducks Pattern</code></h4>\n<ul>\n<li>Redux Action, Action Creator를 한 파일로 관리</li>\n<li>action, creator, reducer 각각 나눠서 작업하면 USER 관련된 리덕스를 수정하려면 3파일을 전부 수정해야하는 불편</li>\n<li>기능별로 묶어서 관리하자</li>\n<li>\n<pre><code>// action\nconst EX_ACTION_LIST = ‘ex_action_list’;\n\n// action creator\nconst getList = () => {\n    return { type: EX_ACTION_LIST };\n}\n</code></pre>\n</li>\n<li><a href=\"http://guswnsxodlf.github.io/redux-ducks-pattern\">참고: Ducks Pattern</a></li>\n</ul>\n<h4><code>React Native: Flatlist</code></h4>\n<ul>\n<li>스크롤이 자동 생성되며 뷰 밖에 있는 것은 lazy</li>\n<li>인스타나 페이스북처럼 무한 로드 페이징에 효과적</li>\n<li>scrollview 안에서 사용하면 flatlist의 기능을 이용하지 못함</li>\n</ul>\n<h4><code>FE 성능 최적화</code></h4>\n<ul>\n<li>네이버테크콘서트 유튜브</li>\n<li>측정 > 분석 > 최적화 반복</li>\n<li>어디를? 유저가 가장 많이 사용하는 화면, 가장 가치 있는 화면</li>\n<li>무엇을? Loading and Interaction</li>\n<li>어떻게? waterfall의 높이, 폭, 간격 개선\n<ol>\n<li>request 수 줄이기 - 불필요한 자원 호출 삭제</li>\n<li>request 시간 줄이기 - 파일 경량, 난독, 압축</li>\n<li>request 중첩 - 파일 로드 우선순위</li>\n</ol>\n</li>\n<li><a href=\"https://medium.com/@bbirec/http-%EC%BA%90%EC%89%AC%EB%A1%9C-api-%EC%86%8D%EB%8F%84-%EC%98%AC%EB%A6%AC%EA%B8%B0-2effb1bfab12\">참고: http 캐시</a></li>\n</ul>\n<h4><code>Server Side Rendering / Client Side Rendering</code></h4>\n<ul>\n<li>SSR (ex. jsp): 요청마다 서버에서 내려줘야함</li>\n<li>CSR (ex. spa): 초기 접속 시 파일 전부 가져와서 보여주기만</li>\n</ul>\n<h4><code>Was(web application server) / Web Server</code></h4>\n<ul>\n<li>Apache, tomcat, nginx</li>\n<li>동적 vs 정적</li>\n<li>~/getList vs ~/list.js</li>\n<li>특정 URL로 요청 할 경우 웹서버에서 확인 후 WAS로 보낸다</li>\n<li>User(~/example.do) > Web Server(해당 URL을 어디로 보낼지 확인) > WAS(해당 URL 호출) > Web Server(WAS에서 데이터 리턴) > User(데이터 확인)</li>\n<li>사용자 요청 > 아파치가 톰캣에 보내야 하는 요청인지 확인 > 톰캣 요청 > 톰캣이 아파치에게 데이터 리턴 > 아파치가 사용자에게 데이터 리턴</li>\n<li><a href=\"https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html\">WAS vs Web Server</a></li>\n<li><a href=\"https://www.ntu.edu.sg/home/ehchua/programming/howto/ApachePlusTomcat_HowTo.html\">Request에 따라 WAS 또는 Web Server</a></li>\n</ul>\n<h2></h2>\n<h4>10/13 - 10/19</h4>\n<h4><code>Functional-Javascript</code></h4>\n<ul>\n<li>지난주 스터디를 진행하며 궁금했던 Call과 curry의 차이점</li>\n<li>Curry: 인자로 받은 function에 args를 하나씩 함수 인자로 분리하여 반환</li>\n<li>Call: 인자로 받은 function에 args를 넣은 Curry 함수를 실행</li>\n<li>function의 args 갯수가 맞지 않는 경우 curry는 해당 함수를 반환하지만 call은 해당 인자를 Undefined로 인식하여 실행됨</li>\n<li><a href=\"https://github.com/Functional-JavaScript/FunctionalES\">유인동님의 함수형 프로그래밍</a></li>\n</ul>\n<h4><code>유사배열</code></h4>\n<ul>\n<li>유사배열에서 Array.prototype을 사용하려면 call, bind, apply</li>\n<li>call(this, 1, 2), apply(this, [1, 2]) = bind(this)(1, 2)</li>\n<li>call, apply는 실행까지, bind는 반환만</li>\n<li><a href=\"https://www.zerocho.com/category/JavaScript/post/57433645a48729787807c3fd\">제로초님의 call, bind, apply</a></li>\n<li><a href=\"https://www.zerocho.com/category/JavaScript/post/5af6f9e707d77a001bb579d2\">제로초님의 유사배열</a></li>\n</ul>\n<h2></h2>\n<h4>10/6 - 10/12</h4>\n<h4><code>TDD?</code></h4>\n<ul>\n<li><a href=\"https://youtu.be/bIeqAlmNRrA\">참고 영상 - 우아한테크</a></li>\n<li>내 능력을 살짝 넘어가는 작업을 구체적인 목표를 가지고 지속적으로 시도</li>\n<li>Test 코드 작성 > 리팩토링 > 테스트 실패 > 재작성</li>\n</ul>\n<h4>SPA에서 구글 애널리틱스(ga)를 route url 별로 자동 구현한 라이브러리 오픈소스가 있는지 찾아보고 없다면 만들면 좋을것 같다.</h4>\n<ul>\n<li>이미 <code>history</code> 라이브러리에서 <code>history.listen</code>으로 응답에 따라 <code>ga</code>를 보낼 수 있도록 되어있다.</li>\n<li>내가 생각한 것은 react-router-dom의 link가 호출되어 url이 변경되는 순간 해당 url로 ga가 보내지는 것… 라이브러리 내장 지원</li>\n<li>이게 nextjs일까</li>\n</ul>\n<h4>한달동안</h4>\n<ol>\n<li><a href=\"https://jiggag.github.io/10%EC%9B%94-%ED%95%9C%EB%8B%AC%EB%8F%99%EC%95%88/\"><code>10월 한달동안</code></a></li>\n<li><a href=\"https://jiggag.github.io/11%EC%9B%94-%ED%95%9C%EB%8B%AC%EB%8F%99%EC%95%88/\"><code>11월 한달동안</code></a></li>\n<li><a href=\"https://jiggag.github.io/12%EC%9B%94-%ED%95%9C%EB%8B%AC%EB%8F%99%EC%95%88/\"><code>12월 한달동안</code></a></li>\n</ol>","frontmatter":{"slug":"/blog/monthly-log/2019-10","date":"2019년 11월 2일","title":"10월 한달동안 로그"}}},"pageContext":{"id":"d20e48b9-13e3-5424-8a5e-208d49587de2","frontmatter__slug":"/blog/monthly-log/2019-10","__params":{"frontmatter__slug":"blog"}}},
    "staticQueryHashes": ["3000541721","3293771174"]}