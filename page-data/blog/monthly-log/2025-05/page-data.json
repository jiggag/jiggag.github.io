{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/monthly-log/2025-05/","result":{"data":{"markdownRemark":{"html":"<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EB%B2%88%EC%97%AD-use-client%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%84-%ED%95%98%EB%82%98%EC%9A%94\"><strong>(번역) \"use client\"는 무엇을 하나요?</strong></a></li>\n<li><a href=\"#react-reconciliation-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%92%A4%EC%97%90-%EC%88%A8%EA%B2%A8%EC%A7%84-%EC%97%94%EC%A7%84\"><strong>React Reconciliation: 컴포넌트 뒤에 숨겨진 엔진</strong></a></li>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EC%B4%98%EC%B4%98%ED%95%98%EA%B2%8C-%EB%A7%8C%EB%93%9C%EB%8A%94-%EC%82%AC%EB%9E%8C\">프로세스를 촘촘하게 만드는 사람</a></li>\n</ul>\n</div>\n<h3 id=\"번역-use-client는-무엇을-하나요\" style=\"position:relative;\"><a href=\"#%EB%B2%88%EC%97%AD-use-client%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%84-%ED%95%98%EB%82%98%EC%9A%94\" aria-label=\"번역 use client는 무엇을 하나요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://velog.io/@sehyunny/what-does-use-client-do\"><strong>(번역) \"use client\"는 무엇을 하나요?</strong></a></h3>\n<ul>\n<li>use client, use server</li>\n<li>서로 다른 런타임 환경이 존재하지만 각각의 파일이 서로의 환경에서 export 되어서 다른 환경으로 import 할 수 있음을 의미\n<ul>\n<li><code>use client</code> - 클라이언트 함수를 서버로 export\n<ul>\n<li>서버에서는 이 파일을 import 하면 <script> 태그로 가져와 읽으며</li>\n</ul>\n</li>\n<li><code>use server</code> - 서버 함수를 클라이언트로 export\n<ul>\n<li>클라이언트에서는 import 된 함수를 fetch 하는 형태</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>지시어를 추가 하는 것만으로 호출 되는 것은 아니고\n<ul>\n<li>\n<script>, fetch 할 수 있도록 허용해주는 것\n\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"react-reconciliation-컴포넌트-뒤에-숨겨진-엔진\" style=\"position:relative;\"><a href=\"#react-reconciliation-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%92%A4%EC%97%90-%EC%88%A8%EA%B2%A8%EC%A7%84-%EC%97%94%EC%A7%84\" aria-label=\"react reconciliation 컴포넌트 뒤에 숨겨진 엔진 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://roy-jung.github.io/250414-react-reconciliation-deep-dive\"><strong>React Reconciliation: 컴포넌트 뒤에 숨겨진 엔진</strong></a></h3>\n<ul>\n<li>\n<p>메모이제이션을 사용할 필요 없다는 리액트 컴파일러</p>\n<ul>\n<li>그 사실은 무지성 메모이제이션에게 큰 위협</li>\n</ul>\n</li>\n<li>\n<p>리렌더가 많이 일어난다는 사실은 컴포넌트 최소화가 되지 않았다는 것을 의미하는데</p>\n<ul>\n<li>분리하고 싶은데 분리하다보면 결국 다 필요한데 ⁉️</li>\n<li>무언가 잘못되었다는 사실에 분리하지 못한다</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://cekrem.github.io/posts/react-reconciliation-deep-dive/#component-identity-and-state-persistence\">DOM 은 변경되지 않았다</a></p>\n<ul>\n<li>상태를 조건으로 리렌더 되고 있는데</li>\n<li>같은 요소 input에 대하여 DOM 자체를 변경되지 않는다는 사실</li>\n<li>input > div 로 바뀌는 경우에만 언마운트 되면서 DOM 변경</li>\n<li><code>컴포넌트 자체가 그려지는데에는 리액트 요소가 중요하다는 것</code></li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://cekrem.github.io/posts/react-reconciliation-deep-dive/#how-reconciliation-works\">조정이 작동하는 방식</a></p>\n<ul>\n<li>리액트 요소 트리 비교</li>\n</ul>\n<pre><code class=\"language-tsx\">{isBoolean ? &#x3C;div>&#x3C;A />&#x3C;/div> : &#x3C;span>&#x3C;A />&#x3C;/span>}\n</code></pre>\n<ul>\n<li>상위 요소가 div > span 으로 변경되었다면 리렌더된다</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://cekrem.github.io/posts/react-reconciliation-deep-dive/#2-position-in-the-tree-matters\">단 요소가 아닌 props만 변경되는 경우에는</a></p>\n<pre><code class=\"language-tsx\">{isBoolean ? &#x3C;A /> : &#x3C;B />}\n{isBoolean ? &#x3C;A type=\"a\" /> : &#x3C;A type=\"b\" />\n</code></pre>\n<ul>\n<li>props만 변경되었으므로 컴포넌트 인스턴스는 그대로 유지된다</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://cekrem.github.io/posts/react-reconciliation-deep-dive/#3-keys-override-position-based-comparison\">동일한 key를 사용하는 컴포넌트는</a></p>\n<ul>\n<li>어느 곳에 위치하던 동일한 컴포넌트로 취급된다</li>\n<li><code>서로 다른 위치에 나타나더라도, 리액트는 동일한 key를 가진 컴포넌트를 동일한 컴포넌트로 간주합니다</code></li>\n<li>리액트 요소, key가 모두 동일하다면 컴포넌트를 리렌더링 하지 않고 props만 바꾸어 그린다</li>\n</ul>\n</li>\n<li>\n<p>리스트에서는 key가 없다면 위치를 기반으로 컴포넌트가 변경되었는지 판단하기에 위치가 변경되면 리스트가 변경되었다고 판단하고 새로 그린다</p>\n<ul>\n<li>하지만 key를 전달하므로써 데이터가 새로 추가되어 위치가 변경되더라도 리렌더링 하지 않고 그대로 사용하게 된다</li>\n<li><a href=\"https://cekrem.github.io/posts/react-reconciliation-deep-dive/#mixing-dynamic-and-static-elements\">위치가 변경되었더라도 동일한 key를 사용하는 경우 해당 컴포넌트는 위치만 변경되었다고 인식할뿐 새로 그려지지 않는다</a>\n<ul>\n<li>컴포넌트의 위치를 비교하기 때문에</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://cekrem.github.io/posts/react-reconciliation-deep-dive/#state-colocation-a-powerful-performance-pattern\">비싼 비용의 컴포넌트는</a></p>\n<ul>\n<li>리렌더링 되지 않도록 상태를 지역화하여</li>\n<li>상태가 변경되는 컴포넌트를 최대한 분리하여 위치를 나눈다</li>\n<li><code>상태가 필요 이상으로 트리 상단에 위치하면 더 많은 컴포넌트가 재렌더링됩니다.</code></li>\n<li><code>메모이제이션 없이도 컴포넌트 경계를 잘 설정하면 성능을 최적화할 수 있습니다.</code></li>\n</ul>\n</li>\n<li>\n<p><code>과도한 메모이제이션으로 리액트의 조정 알고리즘과 싸우는 대신, 리액트가 컴포넌트를 식별하고 업데이트하는 방식에 맞춰 컴포넌트 구조를 설계하자</code></p>\n<ul>\n<li><strong>🙏</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"프로세스를-촘촘하게-만드는-사람\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EC%B4%98%EC%B4%98%ED%95%98%EA%B2%8C-%EB%A7%8C%EB%93%9C%EB%8A%94-%EC%82%AC%EB%9E%8C\" aria-label=\"프로세스를 촘촘하게 만드는 사람 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://jojoldu.tistory.com/829\">프로세스를 촘촘하게 만드는 사람</a></h3>\n<ul>\n<li>프로세스가 항상 모든 것을 커버할 수 없다</li>\n<li>비어있는 영역이 있을텐데, 이것이 자연스럽게 채워질때</li>\n</ul>","frontmatter":{"slug":"/blog/monthly-log/2025-05","date":"2025년 6월 3일","title":"5월 한달동안 로그","subtitle":"찾아보고, 읽어보고, 적어두기","tags":["log"]}}},"pageContext":{"id":"163130af-208a-5770-88d2-ab09be5db057","frontmatter__slug":"/blog/monthly-log/2025-05","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["3000541721","3293771174"]}