{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/monthly-log/2025-08/","result":{"data":{"markdownRemark":{"html":"<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#kotlin-conf\">Kotlin conf</a></li>\n<li><a href=\"#%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%96%B8%EB%A7%88%EC%9A%B4%ED%8A%B8-vs-%EB%A6%AC%EB%A0%8C%EB%8D%94%EB%A7%81\">리액트 언마운트 vs 리렌더링</a></li>\n</ul>\n</div>\n<h3 id=\"kotlin-conf\" style=\"position:relative;\"><a href=\"#kotlin-conf\" aria-label=\"kotlin conf permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Kotlin conf</h3>\n<ul>\n<li>키노트 KMP/CMP\n<ul>\n<li>앱도 이제 stable release 라고 한다\n<ul>\n<li>여태 아니였다는게 놀랍기도</li>\n</ul>\n</li>\n<li>compose UI 가 너무 매력적으로 들린다</li>\n</ul>\n</li>\n<li><strong>Compose로 만드는 창의적인 UI</strong>\n<ul>\n<li>직사각형을 배열하는 것</li>\n<li>그리고 멋을 내고 싶다면 곡선을 추가한다</li>\n<li>여기서는 게임 UI를 compose ui 로 구현해내었는데</li>\n<li>진짜 영끌이다</li>\n<li>좌표 계산하고 애니메이션 효과를 줄때 느낄 수 있는 희열 🥳</li>\n</ul>\n</li>\n<li><strong>Compose Hot Reload 구현하기</strong>\n<ul>\n<li>핫리로드를 구현하면서 겪은 문제들\n<ul>\n<li>사용자에게 제한을 주고 싶지 않다</li>\n<li>최대한 자연스럽게</li>\n<li>사용자는 모르게</li>\n</ul>\n</li>\n<li>방금 변경된 코드가 어디서 사용중인지 역으로 따라가 핫리로드 구현하는 방식\n<ul>\n<li>리액트 vdom 처럼 변경된 곳을 찾아 그 부분을 바꿔준다는 것이 비슷해보이는데</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>실전 투입 가능한 iOS용 Compose Multiplatform</strong>\n<ul>\n<li>iOS API를 모두 kotlin 으로 그릴 수 있긴 하지만</li>\n<li>어느정도 네이티브 API 알고 있어야 수월하겠다</li>\n</ul>\n</li>\n<li>여기까지 듣다보니 KMP/CMP 차이가 있나?\n<ul>\n<li>KMP 에서 kotlin으로 구성할 수 있던 안드로이드가 아닌</li>\n<li>iOS나 웹, 데탑앱을 그리기 위해 CMP를 만들었고</li>\n<li>실제로는 KMP 프로젝트에서 CMP를 통해 각각의 네이티브 UI API를 호출하게 되는 모양</li>\n<li>compose UI 를 멀티플랫폼에서 확장하여 사용하기 위한 것</li>\n<li><a href=\"https://www.jetbrains.com/ko-kr/kotlin-multiplatform/\">참고</a>\n<ul>\n<li>Kotlin Multiplatform은 네이티브 프로그래밍의 이점을 유지하면서 다양한 플랫폼에 적합한 애플리케이션을 제작하고 여러 플랫폼에서 코드를 효율적으로 재사용할 수 있도록 해주는 기술입니다. 애플리케이션이 iOS, Android, macOS, Windows 및 Linux 등에서 실행됩니다.</li>\n<li>JetBrains의 선언형 UI 프레임워크인 <a href=\"https://www.jetbrains.com/ko-kr/compose-multiplatform/\">Compose Multiplatform</a>을 활용하면 Android, iOS, 데스크톱과 웹에서 공유되는 UI를 개발할 수 있습니다. Compose Multiplatform을 Kotlin Multiplatform 프로젝트에 통합하여 UI 구현을 여러 개 유지할 필요 없이 앱과 기능을 더 빠르게 전달하세요.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Duolingo + KMP: 개발자 생산성에 대한 사례 연구</strong>\n<ul>\n<li>듀오링고가 리액네, 플러터를 KMP로 전환했다</li>\n<li>플랫폼의 공통된 안정성을 높이는데 집중했다\n<ul>\n<li>특정 OS에서만 문제가 발생한다는 등</li>\n</ul>\n</li>\n<li>기능적인 것부터 포팅을 시작했고</li>\n<li>그리고 CMP에 큰 관심이 가고 넥스트 스텝으로 갈 예정이라고 한다</li>\n<li>각각 분리되어있을때보다 더 나은 생산성을 느낀다고 하는데\n<ul>\n<li>처음 학습할때의 어려움은 있을테지만</li>\n<li>최종적으로는 점점 출시가 빨라짐</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>KMP를 처음 들었을때부터 관심이 있었다\n<ul>\n<li>KMM 이였는데 어느샌가 사라졌다 M 🤔</li>\n<li>당연히 멀티 플랫폼이라는 것이 휘둥그레지게하였다</li>\n<li>그리고 네이티브 언어를 익힐 수 있다는 것도 한 몫</li>\n<li>호기롭게 시작한 프로젝트는 바로 접었는데</li>\n<li>코틀린을 적당히 읽고 쓸 수 있었지만\n<ul>\n<li>코틀린에 대해서만 스터디 했다</li>\n<li>(그러고보니 스터디 하면서 사이드 앱을 만들었는데, 각자 코틀린으로 서버/앱을 만들다 책을 다 읽은 시점에 플젝도 마감 처리 했다는 슬픈 사실)</li>\n</ul>\n</li>\n<li>UI를 그리기 위해서는 결국 xml을 손대야만 했다\n<ul>\n<li>이것은 엄청난 장벽이였다</li>\n<li>개발을 독학해보겠어 하던 시절에도 부딪혔던 벽</li>\n</ul>\n</li>\n<li>비즈니스 로직이라도 공유할 수 있다는 장점이 있지만\n<ul>\n<li>UI가 큰 장벽인 나에겐 결국 네이티브 앱을 각각 만드는 것과 비슷했다</li>\n</ul>\n</li>\n<li>지금은 AI가 도와줄 수 있으니\n<ul>\n<li>그 당시보다 상황은 나았을지도 모르겠다</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"리액트-언마운트-vs-리렌더링\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%96%B8%EB%A7%88%EC%9A%B4%ED%8A%B8-vs-%EB%A6%AC%EB%A0%8C%EB%8D%94%EB%A7%81\" aria-label=\"리액트 언마운트 vs 리렌더링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리액트 언마운트 vs 리렌더링</h3>\n<ul>\n<li>🥊 key가 바뀌면 어떻게 되나\n<ul>\n<li>언마운트 vs 리렌더링</li>\n<li><strong><code>key 가 바뀌면 이전 컴포넌트는 언마운트 후 새로운 컴포넌트 마운트</code></strong>\n<ul>\n<li>언마운트: DOM에서 제거</li>\n<li>마운트: DOM에 추가</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-jsx\">&#x3C;User key={userId}>\n  &#x3C;Common />\n&#x3C;/User>\n</code></pre>\n<ul>\n<li>userId 라는 key 가 바뀌면 User 라는 컴포넌트 자체가 DOM에서 사라졌다가 다시 추가 되는 것이기에\n<ul>\n<li>그 아래에 있는 Common 도 아예 새로 추가 되는 것</li>\n</ul>\n</li>\n<li>리렌더링 되는 것이 아니기에 아래 Common이 유지될 수 없음\n<ul>\n<li>따라서 상태나 애니메이션이 초기화 됨</li>\n</ul>\n</li>\n<li>key가 동일하면 동일한 DOM을 유지하기 때문에\n<ul>\n<li>다른 props는 변경되어도 리렌더링 되는데</li>\n<li>key는 언마운트 처리 되는 차이가 있다</li>\n</ul>\n</li>\n<li>리액트 재조정 과정에서 key가 변경되었는지를 우선 확인하여 트리 구조가 변경되었는지 판단하기 때문에 고유한 key를 사용하도록 하여 퍼포먼스 이점을 가지도록 한다</li>\n</ul>\n</li>\n<li>🥊 diffing과 reconciliation\n<ul>\n<li><a href=\"https://roseline.oopy.io/dev/react-advanced-deep-dive-into-diffing-and-reconciliation\">https://roseline.oopy.io/dev/react-advanced-deep-dive-into-diffing-and-reconciliation</a> 내용을 따라가며 학습한다</li>\n<li>조건부 렌더링 하는 경우\n<pre><code class=\"language-jsx\">{\n  isCompany ? (\n    &#x3C;Input id=\"company-tax-id\" placeholder=\"Enter your company Tax ID\" onChange={handleCompanyChange} />\n  ) : (\n    &#x3C;Input id=\"personal-tax-id\" placeholder=\"Enter your personal Tax ID\" onChange={handlePersonalChange} />\n  );\n}\n</code></pre>\n<ul>\n<li>조건에 따라 props가 모두 바뀌었고 아예 다른 동작을 해야하도록 구현했다</li>\n<li>하지만 isCompany라는 상태에 따라 새로 그려지리라 기대했던 텍스트 인풋에 입력된 내용은 사라지지 않고 유지되었다\n<ul>\n<li>새로운 컴포넌트로 마운트 되었다면 인풋도 초기화 되었어야하는데 말이다</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>리액트가 컴포넌트가 바뀌었다고 판단하는 조건\n<ul>\n<li><code>type이나 key가 바뀌었을때</code></li>\n<li>위 예시에서는 type이 Input으로 동일하며 key가 존재하지 않기 때문에</li>\n<li>동일한 컴포넌트의 props만 바뀌어서 리렌더링 되었다\n<ul>\n<li>따라서 인풋에 입력했던 내용은 그대로 유지되었다</li>\n</ul>\n</li>\n<li>reconciliation에 의한 것으로\n<ul>\n<li>type을 바꿀 수 없다면 위 예시에서는 key를 다르게 주어 새로 마운트 하도록 해야한다</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Virtual DOM 트리 비교\n<pre><code class=\"language-jsx\">const Component = () => {\n  const [isCompany, setIsCompany] = useState(false);\n\n  return (\n    &#x3C;div>\n      &#x3C;Input id=\"id1\" placeholder=\"placeholder1\" />\n      {isCompany ? &#x3C;Input id=\"id2\" placeholder=\"placeholder2\" /> : &#x3C;TextPlaceholder />}\n    &#x3C;/div>\n  );\n};\n</code></pre>\n</li>\n<li>Component 컴포넌트를 Virtual DOM 트리로 바꾸면\n<ul>\n<li>사용자 컴포넌트는 type에 함수 그대로 참조된다</li>\n</ul>\n<pre><code class=\"language-jsx\">{\n  type: 'div',\n  props: {\n    children: [\n      {\n        type: Input,\n        props: { id: \"id1\", placeholder: \"placeholder1\" }\n      },\n      {\n        type: TextPlaceholder,\n      },\n    ]\n  }\n}\n</code></pre>\n</li>\n<li>이러한 형태인데 state가 바뀌면 Component 자체가 다시 렌더링을 시작하며 변경된 Virtual DOM 트리와 비교 과정을 통한다\n<pre><code class=\"language-jsx\">{\n  type: 'div',\n  props: {\n    children: [\n      {\n        type: Input,\n        props: { id: \"id1\", placeholder: \"placeholder1\" }\n      },\n      {\n        type: Input,\n        props: { id: \"id2\", placeholder: \"placeholder2\" }\n      },\n    ]\n  }\n}\n</code></pre>\n<ul>\n<li>첫번째 type인 div 는 변하지 않았으므로 패스</li>\n<li>그 아래 children의 첫번째 type도 Input 그대로 동일하므로 패스</li>\n<li>하지만 두번째 type 이 TextPlaceholder에서 Input으로 바뀌었으므로 새로 마운트 하며</li>\n<li>children 자체도 바뀐게 되므로 div도 리렌더 된다</li>\n</ul>\n</li>\n<li>이런식으로 Component가 상태 변경에 의해 리렌더링 되는데\n<ul>\n<li>그 안에 인라인으로 작성한 경우\n<pre><code class=\"language-jsx\">const TextPlaceholder = () => {};\n\nconst Component = () => {\n  const [isCompany, setIsCompany] = useState(false);\n  const Input = () => {};\n\n  return (\n    &#x3C;div>\n      &#x3C;Input id=\"id1\" placeholder=\"placeholder1\" />\n      {isCompany ? &#x3C;Input id=\"id2\" placeholder=\"placeholder2\" /> : &#x3C;TextPlaceholder />}\n    &#x3C;/div>\n  );\n};\n</code></pre>\n<ul>\n<li>트리 type 에서 참조하는 Input 은 리렌더링마다 새로운 함수로 반환되므로</li>\n<li>항상 리액트 type 비교에 실패하므로 항상 새로 마운트 된다 🚨\n<ul>\n<li>성능에 무척 치명적이다</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>key가 동일한데 위치가 바뀐 경우엔 어떻게 될까?\n<pre><code class=\"language-jsx\">&#x3C;>\n  &#x3C;Checkbox />\n  {isCompany ? &#x3C;Input key=\"company\" id=\"company-tax-id\" /> : null}\n  {!isCompany ? &#x3C;Input key=\"person\" id=\"person-tax-id1\" /> : null}\n  {isCompany ? &#x3C;Input key=\"person\" id=\"person-tax-id2\" /> : null}\n&#x3C;/>\n</code></pre>\n<pre><code class=\"language-jsx\">// isCompany = true\n[\n  { type: Checkbox },\n  { type: Input, props: { id: 'company-tax-id' } },\n  null,\n  { type: Input, props: { id: 'person-tax-id2' } }, // key=person\n][\n  // isCompany = false\n  ({ type: Checkbox },\n  null,\n  { type: Input, props: { id: 'person-tax-id1' } }, // key=person 언마운트 후 마운트\n  null)\n];\n</code></pre>\n<ul>\n<li>상태 변경에 따라 Checkbox의 type은 동일하기에 컴포넌트 유지된다</li>\n<li>key가 company인 Input 컴포넌트는 언마운트 되었다\n<ul>\n<li>null이 되어 사라졌다</li>\n</ul>\n</li>\n<li>key가 person인 Input 컴포넌트는 새로 마운트 되었다\n<ul>\n<li>DOM에서 위치만 바뀌었을뿐 key가 같아 동일한 컴포넌트로 유지되지 않을까 싶지만</li>\n<li>배열이 아닌 일반 요소에서는 유지 되지 않고 새로 마운트 된다</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>만약 배열이였다면\n<pre><code class=\"language-jsx\">// data가 [1,2,3] 에서 [2,1,3] 으로 바뀌었을때\n&#x3C;>\n\t{data.map(item => &#x3C;Input key={item} value={item} />}\n\t&#x3C;Input key=\"1\" value={111} />\n&#x3C;/>\n</code></pre>\n<pre><code class=\"language-jsx\">// data = [1,2,3]\n{\n  [\n    { type: Input, props: { value: 1 } },\n    { type: Input, props: { value: 2 } },\n    { type: Input, props: { value: 3 } },\n  ], // 배열 요소\n    { type: Input, props: { value: 111 } }; // 일반 요소\n}\n\n// data = [2,1,3]\n{\n  [\n    { type: Input, props: { value: 2 } }, // 리렌더링\n    { type: Input, props: { value: 1 } }, // 리렌더링\n    { type: Input, props: { value: 3 } }, // 리렌더링 되지 않음\n  ],\n    { type: Input, props: { value: 111 } }; // 리렌더링 되지 않음\n}\n</code></pre>\n<ul>\n<li>배열과 일반 요소의 트리는 아예 분리되어있으며</li>\n<li>같은 배열 내에서 동일한 key의 컴포넌트가 위치만 바뀌었으므로\n<ul>\n<li>Input 컴포넌트 언마운트 되지 않고 리렌더링 된다</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>🥊</strong> key와 type을 다시 정리해보면\n<ul>\n<li>key가 같은 경우\n<ul>\n<li>위치와 타입이 같은 경우 > 리렌더링</li>\n<li>타입이 다른 경우 > 언마운트 후 마운트\n<ul>\n<li>이때 위치는 같던 다르던 상관없다</li>\n</ul>\n</li>\n<li>위치가 다르지만 타입이 같은 경우\n<ul>\n<li>배열 요소 > 리렌더\n<ul>\n<li>다른 위치로 이동했다고 판단</li>\n</ul>\n</li>\n<li>일반 요소 > 언마운트 후 마운트\n<ul>\n<li>위치가 달라지면 아예 다른 컴포넌트로 판단</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>key가 다른 경우\n<ul>\n<li>위치, 타입 모두 상관 없이 > 언마운트 후 마운트</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"slug":"/blog/monthly-log/2025-08","date":"2025년 9월 6일","title":"8월 한달동안 로그","subtitle":"찾아보고, 읽어보고, 적어두기","tags":["log"]}}},"pageContext":{"id":"1889deeb-f56f-5152-bad9-ab092c087843","frontmatter__slug":"/blog/monthly-log/2025-08","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["3000541721","3293771174"],"slicesMap":{}}