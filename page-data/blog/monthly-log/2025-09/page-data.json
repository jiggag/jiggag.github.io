{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/monthly-log/2025-09/","result":{"data":{"markdownRemark":{"html":"<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EB%B2%88%EC%97%AD-%EB%82%B4-%EC%83%9D%EC%95%A0-%EA%B0%80%EC%9E%A5-%EC%9E%90%EB%9E%91%EC%8A%A4%EB%9F%AC%EC%9A%B4-128%ED%82%AC%EB%A1%9C%EB%B0%94%EC%9D%B4%ED%8A%B8\"><strong>(번역) 내 생애 가장 자랑스러운 128킬로바이트</strong></a></li>\n<li><a href=\"#%EB%B2%88%EC%97%AD-useoptimistic%EC%9C%BC%EB%A1%9C-%EC%A6%89%EA%B0%81-%EB%B0%98%EC%9D%91%ED%95%98%EB%8A%94-%EC%95%B1-%EB%A7%8C%EB%93%A4%EA%B8%B0\">[번역] <code>useOptimistic</code>으로 즉각 반응하는 앱 만들기</a></li>\n<li><a href=\"#%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%8F%84-%ED%9A%8C%EC%82%AC%EC%9D%98-%EC%A1%B0%EC%A7%81%EC%9B%90%EC%9D%B4%EB%8B%A4\"><strong>개발자도 회사의 조직원이다</strong></a></li>\n<li><a href=\"#%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%96%B4%EB%96%A4-%EA%B0%80%EC%B9%98%EA%B0%80-%EC%9E%88%EC%9D%84%EA%B9%8C\">블로그를 작성하는 것이 어떤 가치가 있을까</a></li>\n<li><a href=\"#%EC%BD%94%EB%93%9C-%EB%A6%AC%EB%B7%B0%EB%8A%94-%EB%8D%94-%EB%82%98%EC%95%84%EC%A7%88-%EC%88%98-%EC%9E%88%EC%9D%8C\"><strong>코드 리뷰는 더 나아질 수 있음</strong></a></li>\n<li><a href=\"#%EB%B2%88%EC%97%AD-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%BB%A4%EB%AE%A4%EB%8B%88%ED%8B%B0%EA%B0%80-%EC%82%AC%EB%9D%BC%EC%A7%88-%EB%95%8C-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%EC%9D%BC-%EC%84%9C%EC%84%9C%ED%9E%88-%EC%A7%84%ED%96%89%EB%90%98%EB%8A%94-%EC%8A%A4%ED%83%9D-%EC%98%A4%EB%B2%84%ED%94%8C%EB%A1%9C%EC%9A%B0%EC%9D%98-%EC%87%A0%ED%87%B4\"><strong>(번역) 개발자 커뮤니티가 사라질 때 발생하는 일: 서서히 진행되는 스택 오버플로우의 쇠퇴</strong></a></li>\n<li><a href=\"#%EB%B2%88%EC%97%AD-%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%97%90%EC%84%9C-flushsync%EB%A1%9C-%ED%8F%AC%EC%BB%A4%EC%8A%A4-%EA%B4%80%EB%A6%AC-%EB%A7%88%EC%8A%A4%ED%84%B0%ED%95%98%EA%B8%B0\"><strong>(번역) 리액트에서 <code>flushSync</code>로 포커스 관리 마스터하기</strong></a></li>\n</ul>\n</div>\n<h3 id=\"번역-내-생애-가장-자랑스러운-128킬로바이트\" style=\"position:relative;\"><a href=\"#%EB%B2%88%EC%97%AD-%EB%82%B4-%EC%83%9D%EC%95%A0-%EA%B0%80%EC%9E%A5-%EC%9E%90%EB%9E%91%EC%8A%A4%EB%9F%AC%EC%9A%B4-128%ED%82%AC%EB%A1%9C%EB%B0%94%EC%9D%B4%ED%8A%B8\" aria-label=\"번역 내 생애 가장 자랑스러운 128킬로바이트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://emewjin.github.io/proud-128-kb\"><strong>(번역) 내 생애 가장 자랑스러운 128킬로바이트</strong></a></h3>\n<ul>\n<li><code>제가 가장 좋아하는 ‘디자인’의 정의 중 하나는 ‘주어진 제약 조건 내에서 주어진 문제를 해결하는 것’입니다. 우리가 문제를 해결하는 방식은 우리가 작업하는 제약 조건에 의해 형성됩니다. 다른 제약 조건 하의 동일한 문제는 근본적으로 다른 해결책을 가질 수 있으며, 경험을 통해 빡빡한 제약 조건이 종종 더 나은 해결책을 이끌어냄을 배웠습니다.</code></li>\n<li>다양한 조건에서 안정적으로 실행되어야한다는 제약 조건</li>\n<li>웹폰트 대신 시스템 폰트를 사용함\n<ul>\n<li>스타일 없는 텍스트의 깜빡임(FOUT)에 대해 걱정할 필요가 없었습니다. 이는 브라우저가 폰트가 로드되기 전에 텍스트를 렌더링하고, 로드된 후에 다시 렌더링하여 잠시 동안 잘못된 스타일의 텍스트가 깜빡이는 현상입니다.</li>\n<li>안드로이드(시스템 폰트로 Roboto를 사용) 고객은 아이폰(San Francisco, 또는 구형 기기에서는 Helvetica Neue) 고객이나 심지어 윈도우폰(Segoe UI) 고객과는 약간 다른 레이아웃을 보게 될 것입니다.\n<ul>\n<li>그럼에도 시스템 폰트를 사용했을때 가장 큰 이점</li>\n<li>추가 리소스가 없다는 것</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>프레임워크를 사용하기 보다 라이브러리를 사용함\n<ul>\n<li><code>*라이브러리는 당신의 코드**가** 호출하는 것이고, 프레임워크는 당신의 코드**를** 호출하는 것입니다.*</code></li>\n<li>최소한의 기능만을 구현한 라이브러리</li>\n</ul>\n</li>\n<li>이미지 파일 자체는 호락호락 하지 않았다\n<ul>\n<li>그 어떤 파일도 작지 않음</li>\n<li>xml 기반의 svg 를 최적화하여 사용하도록</li>\n</ul>\n</li>\n<li><code>3-4KB를 절약하는 것조차도 우리가 가진 예산에서는 승리로 간주되었고 시간을 들일 가치가 있었습니다</code>\n<ul>\n<li><code>모든 바이트가 중요하다</code></li>\n</ul>\n</li>\n<li><a href=\"https://emewjin.github.io/proud-128-kb/#%EC%A0%9C%EC%95%BD%EB%90%9C-%EB%94%94%EC%9E%90%EC%9D%B8%EC%9D%98-%EC%97%AD%EC%84%A4\">제약 조건은 우리가 다른 방식으로는 고려하지 않았을 방식으로 문제를 해결하도록 강요했습니다</a></li>\n</ul>\n<h3 id=\"번역-useoptimistic으로-즉각-반응하는-앱-만들기\" style=\"position:relative;\"><a href=\"#%EB%B2%88%EC%97%AD-useoptimistic%EC%9C%BC%EB%A1%9C-%EC%A6%89%EA%B0%81-%EB%B0%98%EC%9D%91%ED%95%98%EB%8A%94-%EC%95%B1-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"번역 useoptimistic으로 즉각 반응하는 앱 만들기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://velog.io/@eunbinn/use-optimistic-to-make-your-app-feel-instant\">[번역] <code>useOptimistic</code>으로 즉각 반응하는 앱 만들기</a></h3>\n<ul>\n<li>useOptimistic 으로 상태 업데이트 + 비동기 처리를 빠르게 동시에 마치 그런것처럼\n<ul>\n<li><code>React의 동시 렌더링(Concurrent Rendering)과 트랜지션(Transition) 기능에 최적화되어 있습니다. 단순한 상태 업데이트만으로는 구현하기 어려운 정교한 UI 동기화를 도와주며</code>...</li>\n<li><code>또한 React 트랜지션의 특성상, 트랜지션 안에서 setState를 호출해도 즉시 리렌더링이 발생하지 않을 수 있습니다.</code></li>\n<li>setState만으로는 한계가 있는데 이를 useOptimistic를 이용해 마치 즉각 반응하는 것처럼 처리한다</li>\n</ul>\n</li>\n<li>reanimated + setState 조합에서 겪고 있는 문제\n<ul>\n<li>UI 스레드에서 발생하는 JS 스레드 상태 업데이트에 의한 리렌더 발생 시 애니메이션 끊김 이슈도</li>\n<li>이와 비슷하게 마치 동작하는 것처럼 처리할 수 있지 않을까?</li>\n<li>reanimated callback에서 호출하는 상태 업데이트는 useOptimistic를 이용하도록 테스트</li>\n</ul>\n</li>\n<li>근데 리액트 19 라는 것…\n<ul>\n<li>RN 78에서</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"개발자도-회사의-조직원이다\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%8F%84-%ED%9A%8C%EC%82%AC%EC%9D%98-%EC%A1%B0%EC%A7%81%EC%9B%90%EC%9D%B4%EB%8B%A4\" aria-label=\"개발자도 회사의 조직원이다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://www.thestartupbible.com/2024/03/business-before-technology.html\"><strong>개발자도 회사의 조직원이다</strong></a></h3>\n<ul>\n<li>회사의 가장 큰 목표인 매출로 이어지는 제품과 서비스를 만드는 건데</li>\n<li>개발자가 회사의 목표와는 먼 내용에 집중하는 것에 대한 내용</li>\n<li>문제 해결이라는 것이 비즈니스 목표와 매출에 직접적으로 기여해야하나</li>\n<li>엄청난 기술을 도입하여 아무도 선보이지 못한 무언가를 구현해내어도</li>\n<li>KPI 달성이 되지 않는다면 도움이 되지 않을 것이다 라는 이야기</li>\n<li><a href=\"https://news.hada.io/topic?id=20212\">엔지니어 연봉은 어디서 나오는가?</a> 의 내용과 이어진다</li>\n<li>개인의 성장을 찾으면서도 회사의 목표를 달성할 수 있는 방향으로</li>\n</ul>\n<h3 id=\"블로그를-작성하는-것이-어떤-가치가-있을까\" style=\"position:relative;\"><a href=\"#%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%96%B4%EB%96%A4-%EA%B0%80%EC%B9%98%EA%B0%80-%EC%9E%88%EC%9D%84%EA%B9%8C\" aria-label=\"블로그를 작성하는 것이 어떤 가치가 있을까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>블로그를 작성하는 것이 어떤 가치가 있을까</h3>\n<ul>\n<li>스스로 학습했던 것을 정리하자는 의도로 시작하였다</li>\n<li>아무도 보지 않는 곳에 정리하기도 했지만</li>\n<li>깃헙에 올리는 것 자체가 나에게 가치가 있으리라는 판단으로 지금까지 이어지고 있다\n<ul>\n<li>꾸준하다기에 창피할만큼</li>\n<li>너무 들쑥날쑥 하다</li>\n</ul>\n</li>\n<li>그럼에도 <a href=\"https://news.hada.io/topic?id=19461\">**AI 시대에도 블로깅은 여전히 가치가 있습니다</a>** 를 보며</li>\n<li>이 글을 쓴다는 것 자체가 주는 가치는 높구나 생각한다\n<ul>\n<li>보통 업무에도 과정을 남겨 생각을 공유하는 것이 가치 있는 것으로 여겨지고 있다\n<ul>\n<li>나는 그러하다</li>\n</ul>\n</li>\n<li>AI에게 몇개의 키워드를 던져 글을 작성해달라고 요청 할 수 있다</li>\n</ul>\n</li>\n<li>그럼에도 나의 이 생각나는 단어를 흐름대로 모음집 이라고 부를 수 있는 이 글을 가치있다고 부를 수 있다면\n<ul>\n<li><code>생각나는대로</code> 가 중요한듯</li>\n</ul>\n</li>\n<li>보다 정확한 사실을 파악하는데에 예전의 내가 썼던 글을 보는 것보다 GPT에게 물어보는게 나을지 모르겠다\n<ul>\n<li>다만 내 글을 다시 돌아보면</li>\n<li>당시 고민했던 흐름이 그대로 떠오르고 그렇게 다시 생각으로 이어질 수 있다는 것</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"코드-리뷰는-더-나아질-수-있음\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%93%9C-%EB%A6%AC%EB%B7%B0%EB%8A%94-%EB%8D%94-%EB%82%98%EC%95%84%EC%A7%88-%EC%88%98-%EC%9E%88%EC%9D%8C\" aria-label=\"코드 리뷰는 더 나아질 수 있음 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://news.hada.io/topic?id=22651\"><strong>코드 리뷰는 더 나아질 수 있음</strong></a></h3>\n<ul>\n<li>깃헙 웹페이지가 아닌 깃 기반으로 리뷰 하는 것에 대한 내용인데</li>\n<li>PR이 너무 커서 웹이 느려지는 경우를 제외하고는 어려움을 겪지 못해 공감하지 못한 상태\n<ul>\n<li>어려움을 겪는 정도가 된다면 더 나은 리뷰를 하게 되는 것일까 🤔</li>\n</ul>\n</li>\n<li>본문 보다는 아래 적힌 코멘트에서 적힌 내용 중 되새겨볼만한 내용\n<ul>\n<li><code>진짜 유용한 피드백(사소한 취향 지적 외의 것)이 거의 항상 너무 늦게 나온다는 점</code></li>\n<li><code>리뷰의 유일한(혹은 희귀한) 결과물이 \"이거 다 다시 새 설계로 시작해야 함\" 혹은 \"애초에 이 작업은 할 필요 없었음\"이라는 상황이 생김</code> 🚨</li>\n</ul>\n</li>\n<li>코드리뷰 단계에서야 이 작업에 대한 전반적인 공유가 이뤄졌다는 것이 위의 피드백을 하게 되었다는 문제\n<ul>\n<li>그래서 필요한 것이 <code>디자인 리뷰</code></li>\n<li>과연 지금부터 작업하려는 설계 방향이 우리의 방향이 맞는지 선검토</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"번역-개발자-커뮤니티가-사라질-때-발생하는-일-서서히-진행되는-스택-오버플로우의-쇠퇴\" style=\"position:relative;\"><a href=\"#%EB%B2%88%EC%97%AD-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%BB%A4%EB%AE%A4%EB%8B%88%ED%8B%B0%EA%B0%80-%EC%82%AC%EB%9D%BC%EC%A7%88-%EB%95%8C-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%EC%9D%BC-%EC%84%9C%EC%84%9C%ED%9E%88-%EC%A7%84%ED%96%89%EB%90%98%EB%8A%94-%EC%8A%A4%ED%83%9D-%EC%98%A4%EB%B2%84%ED%94%8C%EB%A1%9C%EC%9A%B0%EC%9D%98-%EC%87%A0%ED%87%B4\" aria-label=\"번역 개발자 커뮤니티가 사라질 때 발생하는 일 서서히 진행되는 스택 오버플로우의 쇠퇴 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://velog.io/@sehyunny/stack-overflow-collapse\"><strong>(번역) 개발자 커뮤니티가 사라질 때 발생하는 일: 서서히 진행되는 스택 오버플로우의 쇠퇴</strong></a></h3>\n<ul>\n<li>스택오버플로우\n<ul>\n<li>무언가 문제가 생겼을때 혹은 모르는게 생겼을때</li>\n<li>코멘트를 서로 주고 받으며 가장 많은 의견을 찾을 수 있는 곳</li>\n<li>개인 블로그나 레딧에서도 볼 수 있었으나</li>\n<li>최근에는 AI를 통해 대부분 해결하고 있는 상황</li>\n</ul>\n</li>\n<li><code>모든 개발자가 스택 오버플로우와 전통적인 인간 중심의 수동적 문제 해결 방식을 버리고, 새롭고 빠른 생성형 AI 도구 기반 접근 방식을 선택한다면 어떤 일이 벌어질까요</code></li>\n<li>기존에는 문제를 해결하는 과정에서 다양한 접근 방식으로 여러 의견을 나눌 수 있었다면</li>\n<li>이미 기존에 등록된 여러 해결 방법에서 찾아낸 것들을 검증하지 못한채 제안함으로써</li>\n<li>더 새로운 방식의 해결 방법을 찾아갈 수 있을지에 대한 의문과 검증되지 않은 결과에 대한 위험성</li>\n<li><code>지금 현재 AI가 유망해 보이는 이유는 최신 데이터로 모델을 학습시키기 때문입니다. 하지만 신선한 자료가 포함되지 않으면, AI는 구식의 부정확고 장황한 답변을 내놓게 되어 인기를 잃을 것입니다</code></li>\n<li>공존으로부터 서로 상호 보완</li>\n</ul>\n<h3 id=\"번역-리액트에서-flushsync로-포커스-관리-마스터하기\" style=\"position:relative;\"><a href=\"#%EB%B2%88%EC%97%AD-%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%97%90%EC%84%9C-flushsync%EB%A1%9C-%ED%8F%AC%EC%BB%A4%EC%8A%A4-%EA%B4%80%EB%A6%AC-%EB%A7%88%EC%8A%A4%ED%84%B0%ED%95%98%EA%B8%B0\" aria-label=\"번역 리액트에서 flushsync로 포커스 관리 마스터하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://ykss.netlify.app/translation/mastering_focus_management_in_react_with_flushsync\"><strong>(번역) 리액트에서 <code>flushSync</code>로 포커스 관리 마스터하기</strong></a></h3>\n<pre><code class=\"language-jsx\">const onShow = () => {\n\tsetIsShow(true);\n\tref.current?.focus();\n};\n\n...\n{isShow &#x26;&#x26; &#x3C;Input ref={ref} />}\n</code></pre>\n<ul>\n<li>\n<p>예를 들어 위와 같은 느낌의 구조에서</p>\n</li>\n<li>\n<p>isShow 조건에 따라 마운트되는 Input 컴포넌트의 ref를 바로 호출할 수 있을까?</p>\n</li>\n<li>\n<p>내용 그대로 마운트 되고 나서야 ref를 할당할 수 있기 때문에 onShow에서 setIsShow과 ref 기대 동작은 한번에 이뤄지지 않는다</p>\n<ul>\n<li>한번에 호출은 되겠지만 <code>setIsShow(true)</code> 이 호출되고</li>\n<li><code>ref.current?.focus()</code> 할때엔 아직 Input 컴포넌트가 마운트 되기 전일테니</li>\n<li>이럴때엔 setTimeout으로 ref.current?.focus() 를 감싸서 처리하고는 했다</li>\n<li><code>하지만 이건 그냥 운에 맡기는 겁니다. 매직 넘버에 의존하거나 브라우저가 빨리 업데이트해 주길 기대하는 건 좋은 방법이 아닙니다. 우리는 확실히 보장된 방법이 필요합니다.</code></li>\n<li>뜨끔 🙈</li>\n</ul>\n</li>\n<li>\n<p>이를 해결할 수 있는 방법으로 즉시 상태를 업데이트 요청하는 flushSync로 감싸도록 한다</p>\n<pre><code class=\"language-jsx\">flushSync(() => {\n\tsetIsShow(true);\n});\nref.current?.focus();\n</code></pre>\n<ul>\n<li>이렇게 하면 isShow가 업데이트 되고 마운트된 ref 에 접근할 수 있게 된다</li>\n<li><code>리액트에게 “성능을 위해 배치 업데이트를 하는 걸 알지만, 이번 업데이트는 *지금 당장* 처리해야 해”라고 알려주는 역할을 합니다. flushSync 콜백 안에서 발생한 상태 업데이트는 즉시 적용되어, 콜백이 끝날 때 DOM이 최신 상태가 됩니다.</code></li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://ykss.netlify.app/translation/mastering_focus_management_in_react_with_flushsync/#code-classlanguage-textflushsynccode%EB%A5%BC-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C%EC%9A%94\">하지만 <code>flushSync는 성능 최적화 측면에서 손해를 보는 선택입니다.</code></a></p>\n<ul>\n<li>리액트는 상태 업데이트 요청된 것들을 모아 비동기로 일괄 업데이트하여 성능을 끌어올리는 방식을 선택했다</li>\n<li>그런데 flushSync를 사용함으로써 동기적으로 상태 업데이트를 즉시 요청하는 것은 성능에 반대되는 요청이기에 이러한 문구가 있다</li>\n<li><code>Using flushSync is uncommon and can hurt the performance of your app.</code></li>\n<li><a href=\"https://react.dev/reference/react-dom/flushSync#flushing-updates-for-third-party-integrations\">DOM을 직접 동기 제어 해야하는 경우에는 어쩔 수 없는 선택일듯하다</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"slug":"/blog/monthly-log/2025-09","date":"2025년 10월 6일","title":"9월 한달동안 로그","subtitle":"찾아보고, 읽어보고, 적어두기","tags":["log"]}}},"pageContext":{"id":"2b9eef1b-a351-500d-90d9-536829966e04","frontmatter__slug":"/blog/monthly-log/2025-09","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["3000541721","3293771174"],"slicesMap":{}}