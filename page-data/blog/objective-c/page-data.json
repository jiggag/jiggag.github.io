{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-tsx",
    "path": "/blog/objective-c/",
    "result": {"data":{"markdownRemark":{"html":"<p><code>react-native-biometics</code> 라이브러리의 네이티브 코드를 수정하고자 파일을 열었다. <code>안드로이드는 자바로, iOS는 Objective C</code>로 개발되어있었다.\n응답형태를 키-값으로 통일하고 싶었으나 iOS 코드를 도대체 어떻게 수정해야하는지 감이 오지 않았다. 다른 코드를 읽어보며 그럴듯하게 작업은 마무리가 되었지만,\n다음에 있을 기회에는 좀 더 발전됨을 준비하고자 <code>프로그래밍 오브젝트 C</code> 책과 <code>react-native-biometrics</code> 코드를 읽어보며 <code>Objective C</code>를 알아두고자 한다.</p>\n<h4><code>자바랑 비슷한데 너무 C다</code></h4>\n<p>객체지향인 것은 자바랑 같다. 그러나 스타일은 C이다. C를 하나도 모르는데 이해할 수 있을까 걱정했지만, 오브젝티브 씨를 공부하면서 얻고자 하는 방향성에 대해 생각해보면서 부담없이 알아보도록 하였다.</p>\n<h4><code>interface + implementation</code></h4>\n<p><code>interface</code>에서 클래스의 데이터, 메소드를 선언하고 <code>implementation</code>에서 이를 오버라이딩하는 개념으로 구현해낸다.</p>\n<h4><code>객체 선언</code></h4>\n<p><code>my = [myClass alloc]</code>으로 객체를 할당하였고 <code>[my init]</code>으로 초기화를 진행한다.\n이를 한번에 나타내면 <code>[[myClass alloc] init]</code>으로 표현할 수 있으며 <code>[myClass new]</code>와 같다.</p>\n<h4><code>가비지 콜렉션</code></h4>\n<p>자바에서는 사용하고 있지 않은 메모리에 대해 정리해주는 <code>가비지 콜렉션</code>이 존재한다. 그러나 iOS에서는 이걸 지원하지 않고 있다. (왜 인지 모르겠지만...)\n그래서 사용한 메모리에 대해 사용하지 않는 경우 항상 정리를 직접 해줘야한다. 이때, 어디선가 사용하고 있는 경우 <code>retain</code>으로 <code>레퍼런스 카운트</code>가 증가하고 사용하지 않는 경우 <code>release</code>로 감소시킨다. 그리고 <code>레퍼런스 카운트</code>가 0이 되면 해당 메모리가 완전하게 정리된다.</p>\n<h4><code>포인터</code></h4>\n<p>그냥 값을 가져오면 되는거 아닐까 생각했는데, 만약 엄청 큰 데이터가 있고 이를 들고서 왔다갔다 해야한다면 그때마다 메모리가 소비된다.\n이때 이 데이터가 들어있는 주소만 알아내서 들고다닌다면 훨씬 효율적으로 움직일 수 있다.</p>\n<h4><code>카테고리, 프로토콜</code></h4>\n<pre><code>카테코리: 라이브러리, 모듈화\n프로토콜: 구현되어야 하는 메서드 모음\n</code></pre>\n<h4><code>react-native-biometrics</code></h4>\n<p>직접 커스텀했던 라이브러리 코드를 다시 열어보았다.</p>\n<pre><code>#import &#x3C;React/RCTBridgeModule.h>\n\n@interface ReactNativeBiometrics : NSObject &#x3C;RCTBridgeModule>\n\n@end\n</code></pre>\n<p><code>ReactNativceBiometrics.h</code> 파일로 <code>interface</code> 선언 부분이다. 안타깝게도 여기에 선언된 변수와 메소드가 없다... 아마 <code>React Native</code> 특성상 브릿지로 호출하게 되어서 그런건 아닐까 생각해본다.</p>\n<p><code>NSObject</code>를 상속받고 있으며 프로토콜로 <code>RCTBridgeModule</code>이 눈에 보인다.</p>\n<pre><code>#import \"ReactNativeBiometrics.h\"\n#import &#x3C;LocalAuthentication/LocalAuthentication.h>\n#import &#x3C;Security/Security.h>\n#import &#x3C;React/RCTConvert.h>\n\n@implementation ReactNativeBiometrics\n\nRCT_EXPORT_MODULE(ReactNativeBiometrics);\n\nRCT_EXPORT_METHOD(isSensorAvailable:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n{\n  LAContext *context = [[LAContext alloc] init];\n  NSError *la_error = nil;\n  BOOL canEvaluatePolicy = [context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&#x26;la_error];\n\n  if (canEvaluatePolicy) {\n    NSString *biometryType = [self getBiometryType:context];\n    NSDictionary *result = @{\n      @\"available\": @(YES),\n      @\"biometryType\": biometryType\n    };\n\n    resolve(result);\n  } else {\n    NSString *errorMessage = [NSString stringWithFormat:@\"%@\", la_error];\n    NSDictionary *result = @{\n      @\"available\": @(NO),\n      @\"error\": errorMessage\n    };\n\n    resolve(result);\n  }\n}\n</code></pre>\n<p>그리고 이 코드는 <code>ReactNativeBiometrics.m</code>으로 <code>implementation</code> 구현 내용이다.</p>\n<p><code>RCT_EXPORT_MODULE</code>으로 명시된 이름올 네이티브 모듈을 사용할 수 있는데 여기에는 <code>isSensorAvailable</code>이 있고 인자로 <code>resolve</code>와 <code>reject</code>를 받는다.</p>\n<p>첫번째 코드로 <code>LAContext *context = [[LAContext alloc] init];</code>이 있는데 이는 <code>LAContext</code>를 할당 <code>alloc</code>하고 <code>init</code>으로 초기화된 포인터가 <code>context</code>이다.</p>\n<p>그다음에 <code>NSError *la_error = nil;</code>로 에러 변수를 초기화하였다.</p>\n<p>위에서 초기화한 <code>context</code>의 메소드 <code>canEvaluatePolicy</code>을 바로 아래에서 사용하고 있다.</p>\n<p>리턴된 값에 따라 아래 조건이 분기되며 <code>[self getBiometryType:context]</code>에서 <code>ReactNativeBiometrics.m</code> 파일에 같이 구현되어있는 <code>getBiometryType</code> 메서드를 호출한다.</p>\n<p>그리고 <code>NSDictionary</code>에 키-값 형태로 만들어서 응답값을 돌려주면 해당 네이티브 모듈이 완성된다.</p>\n<h4>결론</h4>\n<p>황금 연휴에 쓱 읽어내려간 책 한권으로 이해하기에는 너무나 방대했고, C를 너무 몰랐다. 지금도 헷갈리는 부분은 많지만 읽기 전과 후가 다르게 라이브러리를 읽는데 눈에 더 보이는 것들이 있으니 앞으로 도움이 될거라 생각한다.</p>","frontmatter":{"slug":"/blog/objective-c","date":"2020년 5월 1일","title":"Objective C를 react-native-biometrics와 함께 읽기"}}},"pageContext":{"id":"f1901ecc-d465-597a-a791-b5eaa4cd59fb","frontmatter__slug":"/blog/objective-c","__params":{"frontmatter__slug":"blog"}}},
    "staticQueryHashes": ["3000541721","3293771174"]}